{"id":"c9c5e5df-52b9-40d9-bd5e-cd2bf4dcf0c6","zed":"context","version":"0.4.0","text":"\n\n\nHow do I execute an async request in a non-async function in rust?\nThere are several ways to execute an async request in a non-async function in Rust. Here are some common approaches:\n\n1. Using `tokio::runtime::Runtime`:\n```rust\nuse tokio;\n\nfn non_async_function() {\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    let result = rt.block_on(async {\n        // Your async code here\n        let response = reqwest::get(\"https://www.example.com\").await?;\n        response.text().await\n    });\n    println!(\"{:?}\", result);\n}\n```\n\n2. Using `tokio::runtime::Handle`:\n```rust\nfn non_async_function() {\n    let rt = tokio::runtime::Handle::current();\n    let result = rt.block_on(async {\n        // Your async code here\n    });\n}\n```\n\n3. Using a single-threaded runtime:\n```rust\nfn non_async_function() {\n    let rt = tokio::runtime::Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap();\n    let result = rt.block_on(async {\n        // Your async code here\n    });\n}\n```\n\n4. If you're in a context where you know a runtime exists, using `futures::executor::block_on`:\n```rust\nuse futures::executor::block_on;\n\nfn non_async_function() {\n    let result = block_on(async {\n        // Your async code here\n    });\n}\n```\n\nComplete example using reqwest:\n```rust\nuse reqwest;\nuse tokio;\n\nfn fetch_url() -> Result<String, Box<dyn std::error::Error>> {\n    let rt = tokio::runtime::Runtime::new()?;\n    \n    let result = rt.block_on(async {\n        let response = reqwest::get(\"https://www.example.com\").await?;\n        response.text().await\n    })?;\n    \n    Ok(result)\n}\n\nfn main() {\n    match fetch_url() {\n        Ok(text) => println!(\"Response: {}\", text),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n```\n\nImportant notes:\n1. Creating a new runtime has overhead, so if possible, create it once and reuse it\n2. If you're already in an async context, you shouldn't need to do this\n3. Be careful about blocking the thread in async contexts\n4. Some of these approaches might not work in all contexts (like web frameworks that manage their own async runtime)\n\nChoose the approach that best fits your specific use case and context. If you're writing new code, it's generally better to make the entire call chain async rather than mixing async and sync code.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":39}}},{"id":{"replica_id":0,"value":17},"start":70,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":40}}},{"id":{"replica_id":0,"value":18},"start":2296,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":41}}}],"summary":"Async in Synchronous Rust Functions","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}