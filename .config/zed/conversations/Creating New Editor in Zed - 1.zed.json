{"id":"3c3ae61c-c993-4af2-92e0-6ab71473c3d3","zed":"context","version":"0.4.0","text":"\n\n\n```rs zed/crates/zed/src/main.rs\n// Disable command line from opening on release mode\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nmod reliability;\nmod zed;\n\nuse anyhow::{anyhow, Context as _, Result};\nuse chrono::Offset;\nuse clap::{command, Parser};\nuse cli::FORCE_CLI_MODE_ENV_VAR_NAME;\nuse client::{parse_zed_link, Client, ProxySettings, UserStore};\nuse collab_ui::channel_view::ChannelView;\nuse collections::HashMap;\nuse db::kvp::{GLOBAL_KEY_VALUE_STORE, KEY_VALUE_STORE};\nuse editor::Editor;\nuse env_logger::Builder;\nuse extension::ExtensionHostProxy;\nuse fs::{Fs, RealFs};\nuse futures::{future, StreamExt};\nuse git::GitHostingProviderRegistry;\nuse gpui::{App, AppContext as _, Application, AsyncApp, UpdateGlobal as _};\n\nuse gpui_tokio::Tokio;\nuse http_client::{read_proxy_from_env, Uri};\nuse language::LanguageRegistry;\nuse log::LevelFilter;\nuse prompt_library::PromptBuilder;\nuse reqwest_client::ReqwestClient;\n\nuse assets::Assets;\nuse node_runtime::{NodeBinaryOptions, NodeRuntime};\nuse parking_lot::Mutex;\nuse project::project_settings::ProjectSettings;\nuse recent_projects::{open_ssh_project, SshSettings};\nuse release_channel::{AppCommitSha, AppVersion, ReleaseChannel};\nuse session::{AppSession, Session};\nuse settings::{handle_settings_file_changes, watch_config_file, Settings, SettingsStore};\nuse simplelog::ConfigBuilder;\nuse std::{\n    env,\n    fs::OpenOptions,\n    io::{self, IsTerminal, Write},\n    path::{Path, PathBuf},\n    process,\n    sync::Arc,\n};\nuse theme::{ActiveTheme, SystemAppearance, ThemeRegistry, ThemeSettings};\nuse time::UtcOffset;\nuse util::{maybe, ResultExt, TryFutureExt};\nuse uuid::Uuid;\nuse welcome::{show_welcome_view, BaseKeymap, FIRST_OPEN};\nuse workspace::{AppState, SerializedWorkspaceLocation, WorkspaceSettings, WorkspaceStore};\nuse zed::{\n    app_menus, build_window_options, derive_paths_with_position, handle_cli_connection,\n    handle_keymap_file_changes, handle_settings_changed, initialize_workspace,\n    inline_completion_registry, open_paths_with_positions, OpenListener, OpenRequest,\n};\n\n#[cfg(unix)]\nuse util::{load_login_shell_environment, load_shell_from_passwd};\n\n#[cfg(feature = \"mimalloc\")]\n#[global_allocator]\nstatic GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;\n\nfn files_not_created_on_launch(errors: HashMap<io::ErrorKind, Vec<&Path>>) {\n    let message = \"Zed failed to launch\";\n    let error_details = errors\n        .into_iter()\n        .flat_map(|(kind, paths)| {\n            #[allow(unused_mut)] // for non-unix platforms\n            let mut error_kind_details = match paths.len() {\n                0 => return None,\n                1 => format!(\n                    \"{kind} when creating directory {:?}\",\n                    paths.first().expect(\"match arm checks for a single entry\")\n                ),\n                _many => format!(\"{kind} when creating directories {paths:?}\"),\n            };\n\n            #[cfg(unix)]\n            {\n                match kind {\n                    io::ErrorKind::PermissionDenied => {\n                        error_kind_details.push_str(\"\\n\\nConsider using chown and chmod tools for altering the directories permissions if your user has corresponding rights.\\\n                            \\nFor example, `sudo chown $(whoami):staff ~/.config` and `chmod +uwrx ~/.config`\");\n                    }\n                    _ => {}\n                }\n            }\n\n            Some(error_kind_details)\n        })\n        .collect::<Vec<_>>().join(\"\\n\\n\");\n\n    eprintln!(\"{message}: {error_details}\");\n    Application::new().run(move |cx| {\n        if let Ok(window) = cx.open_window(gpui::WindowOptions::default(), |_, cx| {\n            cx.new(|_| gpui::Empty)\n        }) {\n            window\n                .update(cx, |_, window, cx| {\n                    let response = window.prompt(\n                        gpui::PromptLevel::Critical,\n                        message,\n                        Some(&error_details),\n                        &[\"Exit\"],\n                        cx,\n                    );\n\n                    cx.spawn_in(window, |_, mut cx| async move {\n                        response.await?;\n                        cx.update(|_, cx| cx.quit())\n                    })\n                    .detach_and_log_err(cx);\n                })\n                .log_err();\n        } else {\n            fail_to_open_window(anyhow::anyhow!(\"{message}: {error_details}\"), cx)\n        }\n    })\n}\n\nfn fail_to_open_window_async(e: anyhow::Error, cx: &mut AsyncApp) {\n    cx.update(|cx| fail_to_open_window(e, cx)).log_err();\n}\n\nfn fail_to_open_window(e: anyhow::Error, _cx: &mut App) {\n    eprintln!(\n        \"Zed failed to open a window: {e:?}. See https://zed.dev/docs/linux for troubleshooting steps.\"\n    );\n    #[cfg(not(any(target_os = \"linux\", target_os = \"freebsd\")))]\n    {\n        process::exit(1);\n    }\n\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n    {\n        use ashpd::desktop::notification::{Notification, NotificationProxy, Priority};\n        _cx.spawn(|_cx| async move {\n            let Ok(proxy) = NotificationProxy::new().await else {\n                process::exit(1);\n            };\n\n            let notification_id = \"dev.zed.Oops\";\n            proxy\n                .add_notification(\n                    notification_id,\n                    Notification::new(\"Zed failed to launch\")\n                        .body(Some(\n                            format!(\n                                \"{e:?}. See https://zed.dev/docs/linux for troubleshooting steps.\"\n                            )\n                            .as_str(),\n                        ))\n                        .priority(Priority::High)\n                        .icon(ashpd::desktop::Icon::with_names(&[\n                            \"dialog-question-symbolic\",\n                        ])),\n                )\n                .await\n                .ok();\n\n            process::exit(1);\n        })\n        .detach();\n    }\n}\n\nfn main() {\n    menu::init();\n    zed_actions::init();\n\n    let file_errors = init_paths();\n    if !file_errors.is_empty() {\n        files_not_created_on_launch(file_errors);\n        return;\n    }\n\n    init_logger();\n\n    log::info!(\"========== starting zed ==========\");\n\n    let app = Application::new().with_assets(Assets);\n\n    let system_id = app.background_executor().block(system_id()).ok();\n    let installation_id = app.background_executor().block(installation_id()).ok();\n    let session_id = Uuid::new_v4().to_string();\n    let session = app.background_executor().block(Session::new());\n    let app_version = AppVersion::init(env!(\"CARGO_PKG_VERSION\"));\n\n    reliability::init_panic_hook(\n        app_version,\n        system_id.as_ref().map(|id| id.to_string()),\n        installation_id.as_ref().map(|id| id.to_string()),\n        session_id.clone(),\n    );\n\n    let (open_listener, mut open_rx) = OpenListener::new();\n\n    let failed_single_instance_check =\n        if *db::ZED_STATELESS || *release_channel::RELEASE_CHANNEL == ReleaseChannel::Dev {\n            false\n        } else {\n            #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n            {\n                crate::zed::listen_for_cli_connections(open_listener.clone()).is_err()\n            }\n\n            #[cfg(target_os = \"windows\")]\n            {\n                !crate::zed::windows_only_instance::check_single_instance()\n            }\n\n            #[cfg(target_os = \"macos\")]\n            {\n                use zed::mac_only_instance::*;\n                ensure_only_instance() != IsOnlyInstance::Yes\n            }\n        };\n    if failed_single_instance_check {\n        println!(\"zed is already running\");\n        return;\n    }\n\n    let git_hosting_provider_registry = Arc::new(GitHostingProviderRegistry::new());\n    let git_binary_path =\n        if cfg!(target_os = \"macos\") && option_env!(\"ZED_BUNDLE\").as_deref() == Some(\"true\") {\n            app.path_for_auxiliary_executable(\"git\")\n                .context(\"could not find git binary path\")\n                .log_err()\n        } else {\n            None\n        };\n    log::info!(\"Using git binary path: {:?}\", git_binary_path);\n\n    let fs = Arc::new(RealFs::new(\n        git_hosting_provider_registry.clone(),\n        git_binary_path,\n    ));\n    let user_settings_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::settings_file().clone(),\n    );\n    let user_keymap_file_rx = watch_config_file(\n        &app.background_executor(),\n        fs.clone(),\n        paths::keymap_file().clone(),\n    );\n\n    #[cfg(unix)]\n    if !stdout_is_a_pty() {\n        app.background_executor()\n            .spawn(async {\n                load_shell_from_passwd().log_err();\n                load_login_shell_environment().log_err();\n            })\n            .detach()\n    };\n\n    app.on_open_urls({\n        let open_listener = open_listener.clone();\n        move |urls| open_listener.open_urls(urls)\n    });\n    app.on_reopen(move |cx| {\n        if let Some(app_state) = AppState::try_global(cx).and_then(|app_state| app_state.upgrade())\n        {\n            cx.spawn({\n                let app_state = app_state.clone();\n                |mut cx| async move {\n                    if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                        fail_to_open_window_async(e, &mut cx)\n                    }\n                }\n            })\n            .detach();\n        }\n    });\n\n    app.run(move |cx| {\n        release_channel::init(app_version, cx);\n        gpui_tokio::init(cx);\n        if let Some(build_sha) = option_env!(\"ZED_COMMIT_SHA\") {\n            AppCommitSha::set_global(AppCommitSha(build_sha.into()), cx);\n        }\n        settings::init(cx);\n        handle_settings_file_changes(user_settings_file_rx, cx, handle_settings_changed);\n        handle_keymap_file_changes(user_keymap_file_rx, cx);\n        client::init_settings(cx);\n        let user_agent = format!(\n            \"Zed/{} ({}; {})\",\n            AppVersion::global(cx),\n            std::env::consts::OS,\n            std::env::consts::ARCH\n        );\n        let proxy_str = ProxySettings::get_global(cx).proxy.to_owned();\n        let proxy_url = proxy_str\n            .as_ref()\n            .and_then(|input| {\n                input\n                    .parse::<Uri>()\n                    .inspect_err(|e| log::error!(\"Error parsing proxy settings: {}\", e))\n                    .ok()\n            })\n            .or_else(read_proxy_from_env);\n        let http = {\n            let _guard = Tokio::handle(cx).enter();\n            ReqwestClient::proxy_and_user_agent(proxy_url, &user_agent)\n                .expect(\"could not start HTTP client\")\n        };\n        cx.set_http_client(Arc::new(http));\n\n        <dyn Fs>::set_global(fs.clone(), cx);\n\n        GitHostingProviderRegistry::set_global(git_hosting_provider_registry, cx);\n        git_hosting_providers::init(cx);\n\n        OpenListener::set_global(cx, open_listener.clone());\n\n        extension::init(cx);\n        let extension_host_proxy = ExtensionHostProxy::global(cx);\n\n        let client = Client::production(cx);\n        cx.set_http_client(client.http_client().clone());\n        let mut languages = LanguageRegistry::new(cx.background_executor().clone());\n        languages.set_language_server_download_dir(paths::languages_dir().clone());\n        let languages = Arc::new(languages);\n        let (tx, rx) = async_watch::channel(None);\n        cx.observe_global::<SettingsStore>(move |cx| {\n            let settings = &ProjectSettings::get_global(cx).node;\n            let options = NodeBinaryOptions {\n                allow_path_lookup: !settings.ignore_system_version.unwrap_or_default(),\n                // TODO: Expose this setting\n                allow_binary_download: true,\n                use_paths: settings.path.as_ref().map(|node_path| {\n                    let node_path = PathBuf::from(shellexpand::tilde(node_path).as_ref());\n                    let npm_path = settings\n                        .npm_path\n                        .as_ref()\n                        .map(|path| PathBuf::from(shellexpand::tilde(&path).as_ref()));\n                    (\n                        node_path.clone(),\n                        npm_path.unwrap_or_else(|| {\n                            let base_path = PathBuf::new();\n                            node_path.parent().unwrap_or(&base_path).join(\"npm\")\n                        }),\n                    )\n                }),\n            };\n            tx.send(Some(options)).log_err();\n        })\n        .detach();\n        let node_runtime = NodeRuntime::new(client.http_client(), rx);\n\n        language::init(cx);\n        language_extension::init(extension_host_proxy.clone(), languages.clone());\n        languages::init(languages.clone(), node_runtime.clone(), cx);\n        let user_store = cx.new(|cx| UserStore::new(client.clone(), cx));\n        let workspace_store = cx.new(|cx| WorkspaceStore::new(client.clone(), cx));\n\n        Client::set_global(client.clone(), cx);\n\n        zed::init(cx);\n        project::Project::init(&client, cx);\n        client::init(&client, cx);\n        let telemetry = client.telemetry();\n        telemetry.start(\n            system_id.as_ref().map(|id| id.to_string()),\n            installation_id.as_ref().map(|id| id.to_string()),\n            session_id.clone(),\n            cx,\n        );\n\n        // We should rename these in the future to `first app open`, `first app open for release channel`, and `app open`\n        if let (Some(system_id), Some(installation_id)) = (&system_id, &installation_id) {\n            match (&system_id, &installation_id) {\n                (IdType::New(_), IdType::New(_)) => {\n                    telemetry::event!(\"App First Opened\");\n                    telemetry::event!(\"App First Opened For Release Channel\");\n                }\n                (IdType::Existing(_), IdType::New(_)) => {\n                    telemetry::event!(\"App First Opened For Release Channel\");\n                }\n                (_, IdType::Existing(_)) => {\n                    telemetry::event!(\"App Opened\");\n                }\n            }\n        }\n        let app_session = cx.new(|cx| AppSession::new(session, cx));\n\n        let app_state = Arc::new(AppState {\n            languages: languages.clone(),\n            client: client.clone(),\n            user_store: user_store.clone(),\n            fs: fs.clone(),\n            build_window_options,\n            workspace_store,\n            node_runtime: node_runtime.clone(),\n            session: app_session,\n        });\n        AppState::set_global(Arc::downgrade(&app_state), cx);\n\n        auto_update::init(client.http_client(), cx);\n        auto_update_ui::init(cx);\n        reliability::init(\n            client.http_client(),\n            system_id.as_ref().map(|id| id.to_string()),\n            installation_id.clone().map(|id| id.to_string()),\n            session_id.clone(),\n            cx,\n        );\n\n        SystemAppearance::init(cx);\n        theme::init(theme::LoadThemes::All(Box::new(Assets)), cx);\n        theme_extension::init(\n            extension_host_proxy.clone(),\n            ThemeRegistry::global(cx),\n            cx.background_executor().clone(),\n        );\n        command_palette::init(cx);\n        let copilot_language_server_id = app_state.languages.next_language_server_id();\n        copilot::init(\n            copilot_language_server_id,\n            app_state.fs.clone(),\n            app_state.client.http_client(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n        supermaven::init(app_state.client.clone(), cx);\n        language_model::init(cx);\n        language_models::init(\n            app_state.user_store.clone(),\n            app_state.client.clone(),\n            app_state.fs.clone(),\n            cx,\n        );\n        snippet_provider::init(cx);\n        inline_completion_registry::init(\n            app_state.client.clone(),\n            app_state.user_store.clone(),\n            app_state.fs.clone(),\n            cx,\n        );\n        let prompt_builder = PromptBuilder::load(app_state.fs.clone(), stdout_is_a_pty(), cx);\n        assistant::init(\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            prompt_builder.clone(),\n            cx,\n        );\n        assistant2::init(\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            prompt_builder.clone(),\n            cx,\n        );\n        assistant_tools::init(cx);\n        repl::init(app_state.fs.clone(), cx);\n        extension_host::init(\n            extension_host_proxy,\n            app_state.fs.clone(),\n            app_state.client.clone(),\n            app_state.node_runtime.clone(),\n            cx,\n        );\n        recent_projects::init(cx);\n\n        load_embedded_fonts(cx);\n\n        #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n        crate::zed::linux_prompts::init(cx);\n\n        app_state.languages.set_theme(cx.theme().clone());\n        editor::init(cx);\n        image_viewer::init(cx);\n        repl::notebook::init(cx);\n        diagnostics::init(cx);\n\n        audio::init(Assets, cx);\n        workspace::init(app_state.clone(), cx);\n\n        go_to_line::init(cx);\n        file_finder::init(cx);\n        tab_switcher::init(cx);\n        outline::init(cx);\n        project_symbols::init(cx);\n        project_panel::init(Assets, cx);\n        git_ui::git_panel::init(cx);\n        outline_panel::init(Assets, cx);\n        tasks_ui::init(cx);\n        snippets_ui::init(cx);\n        channel::init(&app_state.client.clone(), app_state.user_store.clone(), cx);\n        search::init(cx);\n        vim::init(cx);\n        terminal_view::init(cx);\n        journal::init(app_state.clone(), cx);\n        language_selector::init(cx);\n        toolchain_selector::init(cx);\n        theme_selector::init(cx);\n        language_tools::init(cx);\n        call::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        notifications::init(app_state.client.clone(), app_state.user_store.clone(), cx);\n        collab_ui::init(&app_state, cx);\n        git_ui::init(cx);\n        vcs_menu::init(cx);\n        feedback::init(cx);\n        markdown_preview::init(cx);\n        welcome::init(cx);\n        settings_ui::init(cx);\n        extensions_ui::init(cx);\n        zeta::init(cx);\n\n        cx.observe_global::<SettingsStore>({\n            let languages = app_state.languages.clone();\n            let http = app_state.client.http_client();\n            let client = app_state.client.clone();\n\n            move |cx| {\n                for &mut window in cx.windows().iter_mut() {\n                    let background_appearance = cx.theme().window_background_appearance();\n                    window\n                        .update(cx, |_, window, _| {\n                            window.set_background_appearance(background_appearance)\n                        })\n                        .ok();\n                }\n                languages.set_theme(cx.theme().clone());\n                let new_host = &client::ClientSettings::get_global(cx).server_url;\n                if &http.base_url() != new_host {\n                    http.set_base_url(new_host);\n                    if client.status().borrow().is_connected() {\n                        client.reconnect(&cx.to_async());\n                    }\n                }\n            }\n        })\n        .detach();\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"theme\",\n            value = cx.theme().name.to_string()\n        );\n        telemetry::event!(\n            \"Settings Changed\",\n            setting = \"keymap\",\n            value = BaseKeymap::get_global(cx).to_string()\n        );\n        telemetry.flush_events();\n\n        let fs = app_state.fs.clone();\n        load_user_themes_in_background(fs.clone(), cx);\n        watch_themes(fs.clone(), cx);\n        watch_languages(fs.clone(), app_state.languages.clone(), cx);\n        watch_file_types(fs.clone(), cx);\n\n        cx.set_menus(app_menus());\n        initialize_workspace(app_state.clone(), prompt_builder, cx);\n\n        cx.activate(true);\n\n        cx.spawn({\n            let client = app_state.client.clone();\n            |cx| async move { authenticate(client, &cx).await }\n        })\n        .detach_and_log_err(cx);\n\n        let args = Args::parse();\n        let urls: Vec<_> = args\n            .paths_or_urls\n            .iter()\n            .filter_map(|arg| parse_url_arg(arg, cx).log_err())\n            .collect();\n\n        if !urls.is_empty() {\n            open_listener.open_urls(urls)\n        }\n\n        match open_rx\n            .try_next()\n            .ok()\n            .flatten()\n            .and_then(|urls| OpenRequest::parse(urls, cx).log_err())\n        {\n            Some(request) => {\n                handle_open_request(request, app_state.clone(), cx);\n            }\n            None => {\n                cx.spawn({\n                    let app_state = app_state.clone();\n                    |mut cx| async move {\n                        if let Err(e) = restore_or_create_workspace(app_state, &mut cx).await {\n                            fail_to_open_window_async(e, &mut cx)\n                        }\n                    }\n                })\n                .detach();\n            }\n        }\n\n        let app_state = app_state.clone();\n        cx.spawn(move |cx| async move {\n            while let Some(urls) = open_rx.next().await {\n                cx.update(|cx| {\n                    if let Some(request) = OpenRequest::parse(urls, cx).log_err() {\n                        handle_open_request(request, app_state.clone(), cx);\n                    }\n                })\n                .ok();\n            }\n        })\n        .detach();\n    });\n}\n\nfn handle_open_request(request: OpenRequest, app_state: Arc<AppState>, cx: &mut App) {\n    if let Some(connection) = request.cli_connection {\n        let app_state = app_state.clone();\n        cx.spawn(move |cx| handle_cli_connection(connection, app_state, cx))\n            .detach();\n        return;\n    }\n\n    if let Some(connection_options) = request.ssh_connection {\n        cx.spawn(|mut cx| async move {\n            let paths_with_position =\n                derive_paths_with_position(app_state.fs.as_ref(), request.open_paths).await;\n            open_ssh_project(\n                connection_options,\n                paths_with_position.into_iter().map(|p| p.path).collect(),\n                app_state,\n                workspace::OpenOptions::default(),\n                &mut cx,\n            )\n            .await\n        })\n        .detach_and_log_err(cx);\n        return;\n    }\n\n    let mut task = None;\n    if !request.open_paths.is_empty() {\n        let app_state = app_state.clone();\n        task = Some(cx.spawn(|mut cx| async move {\n            let paths_with_position =\n                derive_paths_with_position(app_state.fs.as_ref(), request.open_paths).await;\n            let (_window, results) = open_paths_with_positions(\n                &paths_with_position,\n                app_state,\n                workspace::OpenOptions::default(),\n                &mut cx,\n            )\n            .await?;\n            for result in results.into_iter().flatten() {\n                if let Err(err) = result {\n                    log::error!(\"Error opening path: {err}\",);\n                }\n            }\n            anyhow::Ok(())\n        }));\n    }\n\n    if !request.open_channel_notes.is_empty() || request.join_channel.is_some() {\n        cx.spawn(|mut cx| async move {\n            let result = maybe!(async {\n                if let Some(task) = task {\n                    task.await?;\n                }\n                let client = app_state.client.clone();\n                // we continue even if authentication fails as join_channel/ open channel notes will\n                // show a visible error message.\n                authenticate(client, &cx).await.log_err();\n\n                if let Some(channel_id) = request.join_channel {\n                    cx.update(|cx| {\n                        workspace::join_channel(\n                            client::ChannelId(channel_id),\n                            app_state.clone(),\n                            None,\n                            cx,\n                        )\n                    })?\n                    .await?;\n                }\n\n                let workspace_window =\n                    workspace::get_any_active_workspace(app_state, cx.clone()).await?;\n                let workspace = workspace_window.entity(&cx)?;\n\n                let mut promises = Vec::new();\n                for (channel_id, heading) in request.open_channel_notes {\n                    promises.push(cx.update_window(workspace_window.into(), |_, window, cx| {\n                        ChannelView::open(\n                            client::ChannelId(channel_id),\n                            heading,\n                            workspace.clone(),\n                            window,\n                            cx,\n                        )\n                        .log_err()\n                    })?)\n                }\n                future::join_all(promises).await;\n                anyhow::Ok(())\n            })\n            .await;\n            if let Err(err) = result {\n                fail_to_open_window_async(err, &mut cx);\n            }\n        })\n        .detach()\n    } else if let Some(task) = task {\n        cx.spawn(|mut cx| async move {\n            if let Err(err) = task.await {\n                fail_to_open_window_async(err, &mut cx);\n            }\n        })\n        .detach();\n    }\n}\n\nasync fn authenticate(client: Arc<Client>, cx: &AsyncApp) -> Result<()> {\n    if stdout_is_a_pty() {\n        if *client::ZED_DEVELOPMENT_AUTH {\n            client.authenticate_and_connect(true, cx).await?;\n        } else if client::IMPERSONATE_LOGIN.is_some() {\n            client.authenticate_and_connect(false, cx).await?;\n        }\n    } else if client.has_credentials(cx).await {\n        client.authenticate_and_connect(true, cx).await?;\n    }\n    Ok::<_, anyhow::Error>(())\n}\n\nasync fn system_id() -> Result<IdType> {\n    let key_name = \"system_id\".to_string();\n\n    if let Ok(Some(system_id)) = GLOBAL_KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(system_id));\n    }\n\n    let system_id = Uuid::new_v4().to_string();\n\n    GLOBAL_KEY_VALUE_STORE\n        .write_kvp(key_name, system_id.clone())\n        .await?;\n\n    Ok(IdType::New(system_id))\n}\n\nasync fn installation_id() -> Result<IdType> {\n    let legacy_key_name = \"device_id\".to_string();\n    let key_name = \"installation_id\".to_string();\n\n    // Migrate legacy key to new key\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&legacy_key_name) {\n        KEY_VALUE_STORE\n            .write_kvp(key_name, installation_id.clone())\n            .await?;\n        KEY_VALUE_STORE.delete_kvp(legacy_key_name).await?;\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    if let Ok(Some(installation_id)) = KEY_VALUE_STORE.read_kvp(&key_name) {\n        return Ok(IdType::Existing(installation_id));\n    }\n\n    let installation_id = Uuid::new_v4().to_string();\n\n    KEY_VALUE_STORE\n        .write_kvp(key_name, installation_id.clone())\n        .await?;\n\n    Ok(IdType::New(installation_id))\n}\n\nasync fn restore_or_create_workspace(app_state: Arc<AppState>, cx: &mut AsyncApp) -> Result<()> {\n    if let Some(locations) = restorable_workspace_locations(cx, &app_state).await {\n        for location in locations {\n            match location {\n                SerializedWorkspaceLocation::Local(location, _) => {\n                    let task = cx.update(|cx| {\n                        workspace::open_paths(\n                            location.paths().as_ref(),\n                            app_state.clone(),\n                            workspace::OpenOptions::default(),\n                            cx,\n                        )\n                    })?;\n                    task.await?;\n                }\n                SerializedWorkspaceLocation::Ssh(ssh) => {\n                    let connection_options = cx.update(|cx| {\n                        SshSettings::get_global(cx)\n                            .connection_options_for(ssh.host, ssh.port, ssh.user)\n                    })?;\n                    let app_state = app_state.clone();\n                    cx.spawn(move |mut cx| async move {\n                        recent_projects::open_ssh_project(\n                            connection_options,\n                            ssh.paths.into_iter().map(PathBuf::from).collect(),\n                            app_state,\n                            workspace::OpenOptions::default(),\n                            &mut cx,\n                        )\n                        .await\n                        .log_err();\n                    })\n                    .detach();\n                }\n            }\n        }\n    } else if matches!(KEY_VALUE_STORE.read_kvp(FIRST_OPEN), Ok(None)) {\n        cx.update(|cx| show_welcome_view(app_state, cx))?.await?;\n    } else {\n        cx.update(|cx| {\n            workspace::open_new(\n                Default::default(),\n                app_state,\n                cx,\n                |workspace, window, cx| {\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n        })?\n        .await?;\n    }\n\n    Ok(())\n}\n\npub(crate) async fn restorable_workspace_locations(\n    cx: &mut AsyncApp,\n    app_state: &Arc<AppState>,\n) -> Option<Vec<SerializedWorkspaceLocation>> {\n    let mut restore_behavior = cx\n        .update(|cx| WorkspaceSettings::get(None, cx).restore_on_startup)\n        .ok()?;\n\n    let session_handle = app_state.session.clone();\n    let (last_session_id, last_session_window_stack) = cx\n        .update(|cx| {\n            let session = session_handle.read(cx);\n\n            (\n                session.last_session_id().map(|id| id.to_string()),\n                session.last_session_window_stack(),\n            )\n        })\n        .ok()?;\n\n    if last_session_id.is_none()\n        && matches!(\n            restore_behavior,\n            workspace::RestoreOnStartupBehavior::LastSession\n        )\n    {\n        restore_behavior = workspace::RestoreOnStartupBehavior::LastWorkspace;\n    }\n\n    match restore_behavior {\n        workspace::RestoreOnStartupBehavior::LastWorkspace => {\n            workspace::last_opened_workspace_location()\n                .await\n                .map(|location| vec![location])\n        }\n        workspace::RestoreOnStartupBehavior::LastSession => {\n            if let Some(last_session_id) = last_session_id {\n                let ordered = last_session_window_stack.is_some();\n\n                let mut locations = workspace::last_session_workspace_locations(\n                    &last_session_id,\n                    last_session_window_stack,\n                )\n                .filter(|locations| !locations.is_empty());\n\n                // Since last_session_window_order returns the windows ordered front-to-back\n                // we need to open the window that was frontmost last.\n                if ordered {\n                    if let Some(locations) = locations.as_mut() {\n                        locations.reverse();\n                    }\n                }\n\n                locations\n            } else {\n                None\n            }\n        }\n        _ => None,\n    }\n}\n\nfn init_paths() -> HashMap<io::ErrorKind, Vec<&'static Path>> {\n    [\n        paths::config_dir(),\n        paths::extensions_dir(),\n        paths::languages_dir(),\n        paths::database_dir(),\n        paths::logs_dir(),\n        paths::temp_dir(),\n    ]\n    .into_iter()\n    .fold(HashMap::default(), |mut errors, path| {\n        if let Err(e) = std::fs::create_dir_all(path) {\n            errors.entry(e.kind()).or_insert_with(Vec::new).push(path);\n        }\n        errors\n    })\n}\n\nfn init_logger() {\n    if stdout_is_a_pty() {\n        init_stdout_logger();\n    } else {\n        let level = LevelFilter::Info;\n\n        // Prevent log file from becoming too large.\n        const KIB: u64 = 1024;\n        const MIB: u64 = 1024 * KIB;\n        const MAX_LOG_BYTES: u64 = MIB;\n        if std::fs::metadata(paths::log_file())\n            .map_or(false, |metadata| metadata.len() > MAX_LOG_BYTES)\n        {\n            let _ = std::fs::rename(paths::log_file(), paths::old_log_file());\n        }\n\n        match OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(paths::log_file())\n        {\n            Ok(log_file) => {\n                let mut config_builder = ConfigBuilder::new();\n\n                config_builder.set_time_format_rfc3339();\n                let local_offset = chrono::Local::now().offset().fix().local_minus_utc();\n                if let Ok(offset) = UtcOffset::from_whole_seconds(local_offset) {\n                    config_builder.set_time_offset(offset);\n                }\n\n                #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n                {\n                    config_builder.add_filter_ignore_str(\"zbus\");\n                    config_builder.add_filter_ignore_str(\"blade_graphics::hal::resource\");\n                    config_builder.add_filter_ignore_str(\"naga::back::spv::writer\");\n                }\n\n                let config = config_builder.build();\n                simplelog::WriteLogger::init(level, config, log_file)\n                    .expect(\"could not initialize logger\");\n            }\n            Err(err) => {\n                init_stdout_logger();\n                log::error!(\n                    \"could not open log file, defaulting to stdout logging: {}\",\n                    err\n                );\n            }\n        }\n    }\n}\n\nfn init_stdout_logger() {\n    Builder::new()\n        .parse_default_env()\n        .format(|buf, record| {\n            use env_logger::fmt::style::{AnsiColor, Style};\n\n            let subtle = Style::new().fg_color(Some(AnsiColor::BrightBlack.into()));\n            write!(buf, \"{subtle}[{subtle:#}\")?;\n            write!(\n                buf,\n                \"{} \",\n                chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S%:z\")\n            )?;\n            let level_style = buf.default_level_style(record.level());\n            write!(buf, \"{level_style}{:<5}{level_style:#}\", record.level())?;\n            if let Some(path) = record.module_path() {\n                write!(buf, \" {path}\")?;\n            }\n            write!(buf, \"{subtle}]{subtle:#}\")?;\n            writeln!(buf, \" {}\", record.args())\n        })\n        .init();\n}\n\nfn stdout_is_a_pty() -> bool {\n    std::env::var(FORCE_CLI_MODE_ENV_VAR_NAME).ok().is_none() && io::stdout().is_terminal()\n}\n\n#[derive(Parser, Debug)]\n#[command(name = \"zed\", disable_version_flag = true)]\nstruct Args {\n    /// A sequence of space-separated paths or urls that you want to open.\n    ///\n    /// Use `path:line:row` syntax to open a file at a specific location.\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    ///\n    /// URLs can either be `file://` or `zed://` scheme, or relative to <https://zed.dev>.\n    paths_or_urls: Vec<String>,\n\n    /// Instructs zed to run as a dev server on this machine. (not implemented)\n    #[arg(long)]\n    dev_server_token: Option<String>,\n}\n\n#[derive(Clone, Debug)]\nenum IdType {\n    New(String),\n    Existing(String),\n}\n\nimpl ToString for IdType {\n    fn to_string(&self) -> String {\n        match self {\n            IdType::New(id) | IdType::Existing(id) => id.clone(),\n        }\n    }\n}\n\nfn parse_url_arg(arg: &str, cx: &App) -> Result<String> {\n    match std::fs::canonicalize(Path::new(&arg)) {\n        Ok(path) => Ok(format!(\"file://{}\", path.display())),\n        Err(error) => {\n            if arg.starts_with(\"file://\")\n                || arg.starts_with(\"zed-cli://\")\n                || arg.starts_with(\"ssh://\")\n                || parse_zed_link(arg, cx).is_some()\n            {\n                Ok(arg.into())\n            } else {\n                Err(anyhow!(\"error parsing path argument: {}\", error))\n            }\n        }\n    }\n}\n\nfn load_embedded_fonts(cx: &App) {\n    let asset_source = cx.asset_source();\n    let font_paths = asset_source.list(\"fonts\").unwrap();\n    let embedded_fonts = Mutex::new(Vec::new());\n    let executor = cx.background_executor();\n\n    executor.block(executor.scoped(|scope| {\n        for font_path in &font_paths {\n            if !font_path.ends_with(\".ttf\") {\n                continue;\n            }\n\n            scope.spawn(async {\n                let font_bytes = asset_source.load(font_path).unwrap().unwrap();\n                embedded_fonts.lock().push(font_bytes);\n            });\n        }\n    }));\n\n    cx.text_system()\n        .add_fonts(embedded_fonts.into_inner())\n        .unwrap();\n}\n\n/// Spawns a background task to load the user themes from the themes directory.\nfn load_user_themes_in_background(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    cx.spawn({\n        let fs = fs.clone();\n        |cx| async move {\n            if let Some(theme_registry) =\n                cx.update(|cx| ThemeRegistry::global(cx).clone()).log_err()\n            {\n                let themes_dir = paths::themes_dir().as_ref();\n                match fs\n                    .metadata(themes_dir)\n                    .await\n                    .ok()\n                    .flatten()\n                    .map(|m| m.is_dir)\n                {\n                    Some(is_dir) => {\n                        anyhow::ensure!(is_dir, \"Themes dir path {themes_dir:?} is not a directory\")\n                    }\n                    None => {\n                        fs.create_dir(themes_dir).await.with_context(|| {\n                            format!(\"Failed to create themes dir at path {themes_dir:?}\")\n                        })?;\n                    }\n                }\n                theme_registry.load_user_themes(themes_dir, fs).await?;\n                cx.update(ThemeSettings::reload_current_theme)?;\n            }\n            anyhow::Ok(())\n        }\n    })\n    .detach_and_log_err(cx);\n}\n\n/// Spawns a background task to watch the themes directory for changes.\nfn watch_themes(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    use std::time::Duration;\n    cx.spawn(|cx| async move {\n        let (mut events, _) = fs\n            .watch(paths::themes_dir(), Duration::from_millis(100))\n            .await;\n\n        while let Some(paths) = events.next().await {\n            for event in paths {\n                if fs.metadata(&event.path).await.ok().flatten().is_some() {\n                    if let Some(theme_registry) =\n                        cx.update(|cx| ThemeRegistry::global(cx).clone()).log_err()\n                    {\n                        if let Some(()) = theme_registry\n                            .load_user_theme(&event.path, fs.clone())\n                            .await\n                            .log_err()\n                        {\n                            cx.update(ThemeSettings::reload_current_theme).log_err();\n                        }\n                    }\n                }\n            }\n        }\n    })\n    .detach()\n}\n\n#[cfg(debug_assertions)]\nfn watch_languages(fs: Arc<dyn fs::Fs>, languages: Arc<LanguageRegistry>, cx: &mut App) {\n    use std::time::Duration;\n\n    let path = {\n        let p = Path::new(\"crates/languages/src\");\n        let Ok(full_path) = p.canonicalize() else {\n            return;\n        };\n        full_path\n    };\n\n    cx.spawn(|_| async move {\n        let (mut events, _) = fs.watch(path.as_path(), Duration::from_millis(100)).await;\n        while let Some(event) = events.next().await {\n            let has_language_file = event.iter().any(|event| {\n                event\n                    .path\n                    .extension()\n                    .map(|ext| ext.to_string_lossy().as_ref() == \"scm\")\n                    .unwrap_or(false)\n            });\n            if has_language_file {\n                languages.reload();\n            }\n        }\n    })\n    .detach()\n}\n\n#[cfg(not(debug_assertions))]\nfn watch_languages(_fs: Arc<dyn fs::Fs>, _languages: Arc<LanguageRegistry>, _cx: &mut App) {}\n\n#[cfg(debug_assertions)]\nfn watch_file_types(fs: Arc<dyn fs::Fs>, cx: &mut App) {\n    use std::time::Duration;\n\n    use file_icons::FileIcons;\n    use gpui::UpdateGlobal;\n\n    let path = {\n        let p = Path::new(\"assets\").join(file_icons::FILE_TYPES_ASSET);\n        let Ok(full_path) = p.canonicalize() else {\n            return;\n        };\n        full_path\n    };\n\n    cx.spawn(|cx| async move {\n        let (mut events, _) = fs.watch(path.as_path(), Duration::from_millis(100)).await;\n        while (events.next().await).is_some() {\n            cx.update(|cx| {\n                FileIcons::update_global(cx, |file_types, _cx| {\n                    *file_types = file_icons::FileIcons::new(Assets);\n                });\n            })\n            .ok();\n        }\n    })\n    .detach()\n}\n\n#[cfg(not(debug_assertions))]\nfn watch_file_types(_fs: Arc<dyn fs::Fs>, _cx: &mut App) {}\n```\n\nHow would I instantiate a new editor?\nBased on the code, you can create a new editor in a few ways. Here's the most straightforward way using the `Editor::new_file()` method:\n\n```rust\nuse editor::Editor;\n\n// Inside a context where you have access to a workspace, window and cx:\nEditor::new_file(workspace, &Default::default(), window, cx)\n```\n\nThis creates a new empty editor buffer. The method requires:\n\n1. A reference to a workspace\n2. Default settings (passed as `&Default::default()`)\n3. A window handle \n4. A context (`cx`)\n\nYou can see this pattern used in the code where it creates a new workspace with an empty editor:\n\n```rust\nworkspace::open_new(\n    Default::default(),\n    app_state,\n    cx,\n    |workspace, window, cx| {\n        Editor::new_file(workspace, &Default::default(), window, cx)\n    },\n)\n```\n\nIf you want to open an existing file instead of creating a new one, you can use `Editor::open()` instead:\n\n```rust\nEditor::open(workspace, file_path, &Default::default(), window, cx)\n```\n\nBoth methods return a Result containing the new Editor instance.\n\nThe key difference is:\n- `new_file()` creates an empty editor buffer\n- `open()` opens an existing file in the editor\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":704}}},{"id":{"replica_id":0,"value":673},"start":41080,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":705}}},{"id":{"replica_id":0,"value":674},"start":42231,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":706}}}],"summary":"Creating New Editor in Zed","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":41041},"icon":"File","label":"zed/crates/zed/src/main.rs","metadata":{"path":"zed/crates/zed/src/main.rs"}}]}