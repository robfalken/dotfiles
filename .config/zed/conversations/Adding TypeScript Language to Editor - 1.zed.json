{"id":"76f2c504-1619-46f1-b055-0dafbd1f100b","zed":"context","version":"0.4.0","text":"\n\n\n```rs zed/crates/zed/src/body_editor.rs\nuse std::sync::Arc;\n\nuse editor::{Editor, EditorElement, EditorMode, EditorStyle, MultiBuffer};\nuse gpui::Focusable;\nuse gpui::*;\nuse gpui::{Context, Entity};\nuse language::{tree_sitter_typescript, Buffer, CursorShape, Language, LanguageConfig};\nuse theme::ActiveTheme;\nuse ui::{div, App, IntoElement, Render, Window};\n\npub struct BodyEditor {\n    pub editor: Entity<Editor>,\n}\n\nimpl BodyEditor {\n    pub fn new(window: &mut Window, cx: &mut App) -> Self {\n        let editor = cx.new(|cx| {\n            let buffer = cx.new(|cx| {\n                let buffer = cx.new(|cx| {\n                    let buffer = Buffer::local(\"Hello?\", cx);\n                    let config = LanguageConfig {\n                        name: \"JSON\".into(),\n                        grammar: Some(\"JSON\".into()),\n                        ..LanguageConfig::default()\n                    };\n                    let language = Language::new(config, None);\n                    let language = Arc::new(language);\n                    buffer.with_language(language, cx)\n                });\n                MultiBuffer::singleton(buffer, cx)\n            });\n            let mut editor = Editor::new(EditorMode::Full, buffer, None, true, window, cx);\n\n            editor.set_placeholder_text(\"Just some placeholder\", cx);\n            editor.set_show_cursor_when_unfocused(true, cx);\n            editor.set_cursor_shape(CursorShape::Block, cx);\n\n            editor\n        });\n\n        Self { editor }\n    }\n}\n\nimpl Render for BodyEditor {\n    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {\n        let handle = self.editor.focus_handle(cx);\n        handle.focus(window);\n\n        let style = EditorStyle {\n            background: cx.theme().colors().surface_background,\n            ..Default::default()\n        };\n\n        div().child(EditorElement::new(&self.editor, style))\n    }\n}\n```\n\nHow can I pass in JSON as a ts_languiage into \"Language::new\" here?\nTo use TypeScript/JSON language support, you'll need to use the tree-sitter TypeScript parser. Here's how you can modify the code to properly set up JSON language support:\n\n```rust\nuse language::tree_sitter_json; // Add this import\n\n// In the buffer creation part:\nlet buffer = cx.new(|cx| {\n    let buffer = Buffer::local(\"Hello?\", cx);\n    let config = LanguageConfig {\n        name: \"JSON\".into(),\n        grammar: Some(\"json\".into()),\n        ..LanguageConfig::default()\n    };\n    let language = Language::new(\n        config,\n        Some(tree_sitter_json()), // Pass the JSON parser here\n    );\n    let language = Arc::new(language);\n    buffer.with_language(language, cx)\n});\n```\n\nThe key changes are:\n1. Import `tree_sitter_json` from the language module\n2. Pass `Some(tree_sitter_json())` as the second argument to `Language::new`\n\nThis will provide proper JSON syntax highlighting and parsing support for your editor. Make sure your project has the necessary dependencies for tree-sitter JSON support in your `Cargo.toml`.\n\nIf you want to use TypeScript instead, you would use:\n```rust\nuse language::tree_sitter_typescript; // For TypeScript\n\n// And then:\nlet language = Language::new(\n    config,\n    Some(tree_sitter_typescript()), // For TypeScript\n);\n```\n\nChoose the appropriate parser based on whether you want JSON or TypeScript support.\n```rs zed/crates/language/src/language.rs\n//! The `language` crate provides a large chunk of Zed's language-related\n//! features (the other big contributors being project and lsp crates that revolve around LSP features).\n//! Namely, this crate:\n//! - Provides [`Language`], [`Grammar`] and [`LanguageRegistry`] types that\n//!   use Tree-sitter to provide syntax highlighting to the editor; note though that `language` doesn't perform the highlighting by itself. It only maps ranges in a buffer to colors. Treesitter is also used for buffer outlines (lists of symbols in a buffer)\n//! - Exposes [`LanguageConfig`] that describes how constructs (like brackets or line comments) should be handled by the editor for a source file of a particular language.\n//!\n//! Notably we do *not* assign a single language to a single file; in real world a single file can consist of multiple programming languages - HTML is a good example of that - and `language` crate tends to reflect that status quo in its API.\nmod buffer;\nmod diagnostic_set;\nmod highlight_map;\nmod language_registry;\npub mod language_settings;\nmod outline;\npub mod proto;\nmod syntax_map;\nmod task_context;\nmod toolchain;\n\n#[cfg(test)]\npub mod buffer_tests;\npub mod markdown;\n\npub use crate::language_settings::EditPredictionsMode;\nuse crate::language_settings::SoftWrap;\nuse anyhow::{anyhow, Context as _, Result};\nuse async_trait::async_trait;\nuse collections::{HashMap, HashSet};\nuse fs::Fs;\nuse futures::Future;\nuse gpui::{App, AsyncApp, Entity, SharedString, Task};\npub use highlight_map::HighlightMap;\nuse http_client::HttpClient;\npub use language_registry::{LanguageName, LoadedLanguage};\nuse lsp::{CodeActionKind, InitializeParams, LanguageServerBinary, LanguageServerBinaryOptions};\nuse parking_lot::Mutex;\nuse regex::Regex;\nuse schemars::{\n    gen::SchemaGenerator,\n    schema::{InstanceType, Schema, SchemaObject},\n    JsonSchema,\n};\nuse serde::{de, Deserialize, Deserializer, Serialize, Serializer};\nuse serde_json::Value;\nuse settings::WorktreeId;\nuse smol::future::FutureExt as _;\nuse std::num::NonZeroU32;\nuse std::{\n    any::Any,\n    ffi::OsStr,\n    fmt::Debug,\n    hash::Hash,\n    mem,\n    ops::{DerefMut, Range},\n    path::{Path, PathBuf},\n    pin::Pin,\n    str,\n    sync::{\n        atomic::{AtomicU64, AtomicUsize, Ordering::SeqCst},\n        Arc, LazyLock,\n    },\n};\nuse syntax_map::{QueryCursorHandle, SyntaxSnapshot};\nuse task::RunnableTag;\npub use task_context::{ContextProvider, RunnableRange};\nuse theme::SyntaxTheme;\npub use toolchain::{LanguageToolchainStore, Toolchain, ToolchainList, ToolchainLister};\nuse tree_sitter::{self, wasmtime, Query, QueryCursor, WasmStore};\nuse util::serde::default_true;\n\npub use buffer::Operation;\npub use buffer::*;\npub use diagnostic_set::{DiagnosticEntry, DiagnosticGroup};\npub use language_registry::{\n    AvailableLanguage, LanguageNotFound, LanguageQueries, LanguageRegistry,\n    LanguageServerBinaryStatus, QUERY_FILENAME_PREFIXES,\n};\npub use lsp::{LanguageServerId, LanguageServerName};\npub use outline::*;\npub use syntax_map::{OwnedSyntaxLayer, SyntaxLayer, ToTreeSitterPoint, TreeSitterOptions};\npub use text::{AnchorRangeExt, LineEnding};\npub use tree_sitter::{Node, Parser, Tree, TreeCursor};\n\n/// Initializes the `language` crate.\n///\n/// This should be called before making use of items from the create.\npub fn init(cx: &mut App) {\n    language_settings::init(cx);\n}\n\nstatic QUERY_CURSORS: Mutex<Vec<QueryCursor>> = Mutex::new(vec![]);\nstatic PARSERS: Mutex<Vec<Parser>> = Mutex::new(vec![]);\n\npub fn with_parser<F, R>(func: F) -> R\nwhere\n    F: FnOnce(&mut Parser) -> R,\n{\n    let mut parser = PARSERS.lock().pop().unwrap_or_else(|| {\n        let mut parser = Parser::new();\n        parser\n            .set_wasm_store(WasmStore::new(&WASM_ENGINE).unwrap())\n            .unwrap();\n        parser\n    });\n    parser.set_included_ranges(&[]).unwrap();\n    let result = func(&mut parser);\n    PARSERS.lock().push(parser);\n    result\n}\n\npub fn with_query_cursor<F, R>(func: F) -> R\nwhere\n    F: FnOnce(&mut QueryCursor) -> R,\n{\n    let mut cursor = QueryCursorHandle::new();\n    func(cursor.deref_mut())\n}\n\nstatic NEXT_LANGUAGE_ID: LazyLock<AtomicUsize> = LazyLock::new(Default::default);\nstatic NEXT_GRAMMAR_ID: LazyLock<AtomicUsize> = LazyLock::new(Default::default);\nstatic WASM_ENGINE: LazyLock<wasmtime::Engine> = LazyLock::new(|| {\n    wasmtime::Engine::new(&wasmtime::Config::new()).expect(\"Failed to create Wasmtime engine\")\n});\n\n/// A shared grammar for plain text, exposed for reuse by downstream crates.\npub static PLAIN_TEXT: LazyLock<Arc<Language>> = LazyLock::new(|| {\n    Arc::new(Language::new(\n        LanguageConfig {\n            name: \"Plain Text\".into(),\n            soft_wrap: Some(SoftWrap::EditorWidth),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![\"txt\".to_owned()],\n                first_line_pattern: None,\n            },\n            ..Default::default()\n        },\n        None,\n    ))\n});\n\n/// Types that represent a position in a buffer, and can be converted into\n/// an LSP position, to send to a language server.\npub trait ToLspPosition {\n    /// Converts the value into an LSP position.\n    fn to_lsp_position(self) -> lsp::Position;\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct Location {\n    pub buffer: Entity<Buffer>,\n    pub range: Range<Anchor>,\n}\n\n/// Represents a Language Server, with certain cached sync properties.\n/// Uses [`LspAdapter`] under the hood, but calls all 'static' methods\n/// once at startup, and caches the results.\npub struct CachedLspAdapter {\n    pub name: LanguageServerName,\n    pub disk_based_diagnostic_sources: Vec<String>,\n    pub disk_based_diagnostics_progress_token: Option<String>,\n    language_ids: HashMap<String, String>,\n    pub adapter: Arc<dyn LspAdapter>,\n    pub reinstall_attempt_count: AtomicU64,\n    cached_binary: futures::lock::Mutex<Option<LanguageServerBinary>>,\n}\n\nimpl Debug for CachedLspAdapter {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"CachedLspAdapter\")\n            .field(\"name\", &self.name)\n            .field(\n                \"disk_based_diagnostic_sources\",\n                &self.disk_based_diagnostic_sources,\n            )\n            .field(\n                \"disk_based_diagnostics_progress_token\",\n                &self.disk_based_diagnostics_progress_token,\n            )\n            .field(\"language_ids\", &self.language_ids)\n            .field(\"reinstall_attempt_count\", &self.reinstall_attempt_count)\n            .finish_non_exhaustive()\n    }\n}\n\nimpl CachedLspAdapter {\n    pub fn new(adapter: Arc<dyn LspAdapter>) -> Arc<Self> {\n        let name = adapter.name();\n        let disk_based_diagnostic_sources = adapter.disk_based_diagnostic_sources();\n        let disk_based_diagnostics_progress_token = adapter.disk_based_diagnostics_progress_token();\n        let language_ids = adapter.language_ids();\n\n        Arc::new(CachedLspAdapter {\n            name,\n            disk_based_diagnostic_sources,\n            disk_based_diagnostics_progress_token,\n            language_ids,\n            adapter,\n            cached_binary: Default::default(),\n            reinstall_attempt_count: AtomicU64::new(0),\n        })\n    }\n\n    pub fn name(&self) -> LanguageServerName {\n        self.adapter.name().clone()\n    }\n\n    pub async fn get_language_server_command(\n        self: Arc<Self>,\n        delegate: Arc<dyn LspAdapterDelegate>,\n        toolchains: Arc<dyn LanguageToolchainStore>,\n        binary_options: LanguageServerBinaryOptions,\n        cx: &mut AsyncApp,\n    ) -> Result<LanguageServerBinary> {\n        let cached_binary = self.cached_binary.lock().await;\n        self.adapter\n            .clone()\n            .get_language_server_command(delegate, toolchains, binary_options, cached_binary, cx)\n            .await\n    }\n\n    pub fn code_action_kinds(&self) -> Option<Vec<CodeActionKind>> {\n        self.adapter.code_action_kinds()\n    }\n\n    pub fn process_diagnostics(&self, params: &mut lsp::PublishDiagnosticsParams) {\n        self.adapter.process_diagnostics(params)\n    }\n\n    pub async fn process_completions(&self, completion_items: &mut [lsp::CompletionItem]) {\n        self.adapter.process_completions(completion_items).await\n    }\n\n    pub async fn labels_for_completions(\n        &self,\n        completion_items: &[lsp::CompletionItem],\n        language: &Arc<Language>,\n    ) -> Result<Vec<Option<CodeLabel>>> {\n        self.adapter\n            .clone()\n            .labels_for_completions(completion_items, language)\n            .await\n    }\n\n    pub async fn labels_for_symbols(\n        &self,\n        symbols: &[(String, lsp::SymbolKind)],\n        language: &Arc<Language>,\n    ) -> Result<Vec<Option<CodeLabel>>> {\n        self.adapter\n            .clone()\n            .labels_for_symbols(symbols, language)\n            .await\n    }\n\n    pub fn language_id(&self, language_name: &LanguageName) -> String {\n        self.language_ids\n            .get(language_name.as_ref())\n            .cloned()\n            .unwrap_or_else(|| language_name.lsp_id())\n    }\n}\n\n/// [`LspAdapterDelegate`] allows [`LspAdapter]` implementations to interface with the application\n// e.g. to display a notification or fetch data from the web.\n#[async_trait]\npub trait LspAdapterDelegate: Send + Sync {\n    fn show_notification(&self, message: &str, cx: &mut App);\n    fn http_client(&self) -> Arc<dyn HttpClient>;\n    fn worktree_id(&self) -> WorktreeId;\n    fn worktree_root_path(&self) -> &Path;\n    fn update_status(&self, language: LanguageServerName, status: LanguageServerBinaryStatus);\n    async fn language_server_download_dir(&self, name: &LanguageServerName) -> Option<Arc<Path>>;\n\n    async fn npm_package_installed_version(\n        &self,\n        package_name: &str,\n    ) -> Result<Option<(PathBuf, String)>>;\n    async fn which(&self, command: &OsStr) -> Option<PathBuf>;\n    async fn shell_env(&self) -> HashMap<String, String>;\n    async fn read_text_file(&self, path: PathBuf) -> Result<String>;\n    async fn try_exec(&self, binary: LanguageServerBinary) -> Result<()>;\n}\n\n#[async_trait(?Send)]\npub trait LspAdapter: 'static + Send + Sync {\n    fn name(&self) -> LanguageServerName;\n\n    fn get_language_server_command<'a>(\n        self: Arc<Self>,\n        delegate: Arc<dyn LspAdapterDelegate>,\n        toolchains: Arc<dyn LanguageToolchainStore>,\n        binary_options: LanguageServerBinaryOptions,\n        mut cached_binary: futures::lock::MutexGuard<'a, Option<LanguageServerBinary>>,\n        cx: &'a mut AsyncApp,\n    ) -> Pin<Box<dyn 'a + Future<Output = Result<LanguageServerBinary>>>> {\n        async move {\n            // First we check whether the adapter can give us a user-installed binary.\n            // If so, we do *not* want to cache that, because each worktree might give us a different\n            // binary:\n            //\n            //      worktree 1: user-installed at `.bin/gopls`\n            //      worktree 2: user-installed at `~/bin/gopls`\n            //      worktree 3: no gopls found in PATH -> fallback to Zed installation\n            //\n            // We only want to cache when we fall back to the global one,\n            // because we don't want to download and overwrite our global one\n            // for each worktree we might have open.\n            if binary_options.allow_path_lookup {\n                if let Some(binary) = self.check_if_user_installed(delegate.as_ref(), toolchains, cx).await {\n                    log::info!(\n                        \"found user-installed language server for {}. path: {:?}, arguments: {:?}\",\n                        self.name().0,\n                        binary.path,\n                        binary.arguments\n                    );\n                    return Ok(binary);\n                }\n            }\n\n            if !binary_options.allow_binary_download {\n                return Err(anyhow!(\"downloading language servers disabled\"));\n            }\n\n            if let Some(cached_binary) = cached_binary.as_ref() {\n                return Ok(cached_binary.clone());\n            }\n\n            let Some(container_dir) = delegate.language_server_download_dir(&self.name()).await else {\n                anyhow::bail!(\"no language server download dir defined\")\n            };\n\n            let mut binary = try_fetch_server_binary(self.as_ref(), &delegate, container_dir.to_path_buf(), cx).await;\n\n            if let Err(error) = binary.as_ref() {\n                if let Some(prev_downloaded_binary) = self\n                    .cached_server_binary(container_dir.to_path_buf(), delegate.as_ref())\n                    .await\n                {\n                    log::info!(\n                        \"failed to fetch newest version of language server {:?}. error: {:?}, falling back to using {:?}\",\n                        self.name(),\n                        error,\n                        prev_downloaded_binary.path\n                    );\n                    binary = Ok(prev_downloaded_binary);\n                } else {\n                    delegate.update_status(\n                        self.name(),\n                        LanguageServerBinaryStatus::Failed {\n                            error: format!(\"{error:?}\"),\n                        },\n                    );\n                }\n            }\n\n            if let Ok(binary) = &binary {\n                *cached_binary = Some(binary.clone());\n            }\n\n            binary\n        }\n        .boxed_local()\n    }\n\n    async fn check_if_user_installed(\n        &self,\n        _: &dyn LspAdapterDelegate,\n        _: Arc<dyn LanguageToolchainStore>,\n        _: &AsyncApp,\n    ) -> Option<LanguageServerBinary> {\n        None\n    }\n\n    async fn fetch_latest_server_version(\n        &self,\n        delegate: &dyn LspAdapterDelegate,\n    ) -> Result<Box<dyn 'static + Send + Any>>;\n\n    fn will_fetch_server(\n        &self,\n        _: &Arc<dyn LspAdapterDelegate>,\n        _: &mut AsyncApp,\n    ) -> Option<Task<Result<()>>> {\n        None\n    }\n\n    async fn check_if_version_installed(\n        &self,\n        _version: &(dyn 'static + Send + Any),\n        _container_dir: &PathBuf,\n        _delegate: &dyn LspAdapterDelegate,\n    ) -> Option<LanguageServerBinary> {\n        None\n    }\n\n    async fn fetch_server_binary(\n        &self,\n        latest_version: Box<dyn 'static + Send + Any>,\n        container_dir: PathBuf,\n        delegate: &dyn LspAdapterDelegate,\n    ) -> Result<LanguageServerBinary>;\n\n    async fn cached_server_binary(\n        &self,\n        container_dir: PathBuf,\n        delegate: &dyn LspAdapterDelegate,\n    ) -> Option<LanguageServerBinary>;\n\n    fn process_diagnostics(&self, _: &mut lsp::PublishDiagnosticsParams) {}\n\n    /// Post-processes completions provided by the language server.\n    async fn process_completions(&self, _: &mut [lsp::CompletionItem]) {}\n\n    async fn labels_for_completions(\n        self: Arc<Self>,\n        completions: &[lsp::CompletionItem],\n        language: &Arc<Language>,\n    ) -> Result<Vec<Option<CodeLabel>>> {\n        let mut labels = Vec::new();\n        for (ix, completion) in completions.iter().enumerate() {\n            let label = self.label_for_completion(completion, language).await;\n            if let Some(label) = label {\n                labels.resize(ix + 1, None);\n                *labels.last_mut().unwrap() = Some(label);\n            }\n        }\n        Ok(labels)\n    }\n\n    async fn label_for_completion(\n        &self,\n        _: &lsp::CompletionItem,\n        _: &Arc<Language>,\n    ) -> Option<CodeLabel> {\n        None\n    }\n\n    async fn labels_for_symbols(\n        self: Arc<Self>,\n        symbols: &[(String, lsp::SymbolKind)],\n        language: &Arc<Language>,\n    ) -> Result<Vec<Option<CodeLabel>>> {\n        let mut labels = Vec::new();\n        for (ix, (name, kind)) in symbols.iter().enumerate() {\n            let label = self.label_for_symbol(name, *kind, language).await;\n            if let Some(label) = label {\n                labels.resize(ix + 1, None);\n                *labels.last_mut().unwrap() = Some(label);\n            }\n        }\n        Ok(labels)\n    }\n\n    async fn label_for_symbol(\n        &self,\n        _: &str,\n        _: lsp::SymbolKind,\n        _: &Arc<Language>,\n    ) -> Option<CodeLabel> {\n        None\n    }\n\n    /// Returns initialization options that are going to be sent to a LSP server as a part of [`lsp::InitializeParams`]\n    async fn initialization_options(\n        self: Arc<Self>,\n        _: &dyn Fs,\n        _: &Arc<dyn LspAdapterDelegate>,\n    ) -> Result<Option<Value>> {\n        Ok(None)\n    }\n\n    async fn workspace_configuration(\n        self: Arc<Self>,\n        _: &dyn Fs,\n        _: &Arc<dyn LspAdapterDelegate>,\n        _: Arc<dyn LanguageToolchainStore>,\n        _cx: &mut AsyncApp,\n    ) -> Result<Value> {\n        Ok(serde_json::json!({}))\n    }\n\n    /// Returns a list of code actions supported by a given LspAdapter\n    fn code_action_kinds(&self) -> Option<Vec<CodeActionKind>> {\n        Some(vec![\n            CodeActionKind::EMPTY,\n            CodeActionKind::QUICKFIX,\n            CodeActionKind::REFACTOR,\n            CodeActionKind::REFACTOR_EXTRACT,\n            CodeActionKind::SOURCE,\n        ])\n    }\n\n    fn disk_based_diagnostic_sources(&self) -> Vec<String> {\n        Default::default()\n    }\n\n    fn disk_based_diagnostics_progress_token(&self) -> Option<String> {\n        None\n    }\n\n    fn language_ids(&self) -> HashMap<String, String> {\n        Default::default()\n    }\n\n    /// Support custom initialize params.\n    fn prepare_initialize_params(&self, original: InitializeParams) -> Result<InitializeParams> {\n        Ok(original)\n    }\n}\n\nasync fn try_fetch_server_binary<L: LspAdapter + 'static + Send + Sync + ?Sized>(\n    adapter: &L,\n    delegate: &Arc<dyn LspAdapterDelegate>,\n    container_dir: PathBuf,\n    cx: &mut AsyncApp,\n) -> Result<LanguageServerBinary> {\n    if let Some(task) = adapter.will_fetch_server(delegate, cx) {\n        task.await?;\n    }\n\n    let name = adapter.name();\n    log::info!(\"fetching latest version of language server {:?}\", name.0);\n    delegate.update_status(name.clone(), LanguageServerBinaryStatus::CheckingForUpdate);\n\n    let latest_version = adapter\n        .fetch_latest_server_version(delegate.as_ref())\n        .await?;\n\n    if let Some(binary) = adapter\n        .check_if_version_installed(latest_version.as_ref(), &container_dir, delegate.as_ref())\n        .await\n    {\n        log::info!(\"language server {:?} is already installed\", name.0);\n        delegate.update_status(name.clone(), LanguageServerBinaryStatus::None);\n        Ok(binary)\n    } else {\n        log::info!(\"downloading language server {:?}\", name.0);\n        delegate.update_status(adapter.name(), LanguageServerBinaryStatus::Downloading);\n        let binary = adapter\n            .fetch_server_binary(latest_version, container_dir, delegate.as_ref())\n            .await;\n\n        delegate.update_status(name.clone(), LanguageServerBinaryStatus::None);\n        binary\n    }\n}\n\n#[derive(Clone, Debug, Default, PartialEq, Eq)]\npub struct CodeLabel {\n    /// The text to display.\n    pub text: String,\n    /// Syntax highlighting runs.\n    pub runs: Vec<(Range<usize>, HighlightId)>,\n    /// The portion of the text that should be used in fuzzy filtering.\n    pub filter_range: Range<usize>,\n}\n\n#[derive(Clone, Deserialize, JsonSchema)]\npub struct LanguageConfig {\n    /// Human-readable name of the language.\n    pub name: LanguageName,\n    /// The name of this language for a Markdown code fence block\n    pub code_fence_block_name: Option<Arc<str>>,\n    // The name of the grammar in a WASM bundle (experimental).\n    pub grammar: Option<Arc<str>>,\n    /// The criteria for matching this language to a given file.\n    #[serde(flatten)]\n    pub matcher: LanguageMatcher,\n    /// List of bracket types in a language.\n    #[serde(default)]\n    #[schemars(schema_with = \"bracket_pair_config_json_schema\")]\n    pub brackets: BracketPairConfig,\n    /// If set to true, auto indentation uses last non empty line to determine\n    /// the indentation level for a new line.\n    #[serde(default = \"auto_indent_using_last_non_empty_line_default\")]\n    pub auto_indent_using_last_non_empty_line: bool,\n    // Whether indentation of pasted content should be adjusted based on the context.\n    #[serde(default)]\n    pub auto_indent_on_paste: Option<bool>,\n    /// A regex that is used to determine whether the indentation level should be\n    /// increased in the following line.\n    #[serde(default, deserialize_with = \"deserialize_regex\")]\n    #[schemars(schema_with = \"regex_json_schema\")]\n    pub increase_indent_pattern: Option<Regex>,\n    /// A regex that is used to determine whether the indentation level should be\n    /// decreased in the following line.\n    #[serde(default, deserialize_with = \"deserialize_regex\")]\n    #[schemars(schema_with = \"regex_json_schema\")]\n    pub decrease_indent_pattern: Option<Regex>,\n    /// A list of characters that trigger the automatic insertion of a closing\n    /// bracket when they immediately precede the point where an opening\n    /// bracket is inserted.\n    #[serde(default)]\n    pub autoclose_before: String,\n    /// A placeholder used internally by Semantic Index.\n    #[serde(default)]\n    pub collapsed_placeholder: String,\n    /// A line comment string that is inserted in e.g. `toggle comments` action.\n    /// A language can have multiple flavours of line comments. All of the provided line comments are\n    /// used for comment continuations on the next line, but only the first one is used for Editor::ToggleComments.\n    #[serde(default)]\n    pub line_comments: Vec<Arc<str>>,\n    /// Starting and closing characters of a block comment.\n    #[serde(default)]\n    pub block_comment: Option<(Arc<str>, Arc<str>)>,\n    /// A list of language servers that are allowed to run on subranges of a given language.\n    #[serde(default)]\n    pub scope_opt_in_language_servers: Vec<LanguageServerName>,\n    #[serde(default)]\n    pub overrides: HashMap<String, LanguageConfigOverride>,\n    /// A list of characters that Zed should treat as word characters for the\n    /// purpose of features that operate on word boundaries, like 'move to next word end'\n    /// or a whole-word search in buffer search.\n    #[serde(default)]\n    pub word_characters: HashSet<char>,\n    /// Whether to indent lines using tab characters, as opposed to multiple\n    /// spaces.\n    #[serde(default)]\n    pub hard_tabs: Option<bool>,\n    /// How many columns a tab should occupy.\n    #[serde(default)]\n    pub tab_size: Option<NonZeroU32>,\n    /// How to soft-wrap long lines of text.\n    #[serde(default)]\n    pub soft_wrap: Option<SoftWrap>,\n    /// The name of a Prettier parser that will be used for this language when no file path is available.\n    /// If there's a parser name in the language settings, that will be used instead.\n    #[serde(default)]\n    pub prettier_parser_name: Option<String>,\n    /// If true, this language is only for syntax highlighting via an injection into other\n    /// languages, but should not appear to the user as a distinct language.\n    #[serde(default)]\n    pub hidden: bool,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, Default, JsonSchema)]\npub struct LanguageMatcher {\n    /// Given a list of `LanguageConfig`'s, the language of a file can be determined based on the path extension matching any of the `path_suffixes`.\n    #[serde(default)]\n    pub path_suffixes: Vec<String>,\n    /// A regex pattern that determines whether the language should be assigned to a file or not.\n    #[serde(\n        default,\n        serialize_with = \"serialize_regex\",\n        deserialize_with = \"deserialize_regex\"\n    )]\n    #[schemars(schema_with = \"regex_json_schema\")]\n    pub first_line_pattern: Option<Regex>,\n}\n\n/// Represents a language for the given range. Some languages (e.g. HTML)\n/// interleave several languages together, thus a single buffer might actually contain\n/// several nested scopes.\n#[derive(Clone, Debug)]\npub struct LanguageScope {\n    language: Arc<Language>,\n    override_id: Option<u32>,\n}\n\n#[derive(Clone, Deserialize, Default, Debug, JsonSchema)]\npub struct LanguageConfigOverride {\n    #[serde(default)]\n    pub line_comments: Override<Vec<Arc<str>>>,\n    #[serde(default)]\n    pub block_comment: Override<(Arc<str>, Arc<str>)>,\n    #[serde(skip)]\n    pub disabled_bracket_ixs: Vec<u16>,\n    #[serde(default)]\n    pub word_characters: Override<HashSet<char>>,\n    #[serde(default)]\n    pub opt_into_language_servers: Vec<LanguageServerName>,\n}\n\n#[derive(Clone, Deserialize, Debug, Serialize, JsonSchema)]\n#[serde(untagged)]\npub enum Override<T> {\n    Remove { remove: bool },\n    Set(T),\n}\n\nimpl<T> Default for Override<T> {\n    fn default() -> Self {\n        Override::Remove { remove: false }\n    }\n}\n\nimpl<T> Override<T> {\n    fn as_option<'a>(this: Option<&'a Self>, original: Option<&'a T>) -> Option<&'a T> {\n        match this {\n            Some(Self::Set(value)) => Some(value),\n            Some(Self::Remove { remove: true }) => None,\n            Some(Self::Remove { remove: false }) | None => original,\n        }\n    }\n}\n\nimpl Default for LanguageConfig {\n    fn default() -> Self {\n        Self {\n            name: LanguageName::new(\"\"),\n            code_fence_block_name: None,\n            grammar: None,\n            matcher: LanguageMatcher::default(),\n            brackets: Default::default(),\n            auto_indent_using_last_non_empty_line: auto_indent_using_last_non_empty_line_default(),\n            auto_indent_on_paste: None,\n            increase_indent_pattern: Default::default(),\n            decrease_indent_pattern: Default::default(),\n            autoclose_before: Default::default(),\n            line_comments: Default::default(),\n            block_comment: Default::default(),\n            scope_opt_in_language_servers: Default::default(),\n            overrides: Default::default(),\n            word_characters: Default::default(),\n            collapsed_placeholder: Default::default(),\n            hard_tabs: None,\n            tab_size: None,\n            soft_wrap: None,\n            prettier_parser_name: None,\n            hidden: false,\n        }\n    }\n}\n\nfn auto_indent_using_last_non_empty_line_default() -> bool {\n    true\n}\n\nfn deserialize_regex<'de, D: Deserializer<'de>>(d: D) -> Result<Option<Regex>, D::Error> {\n    let source = Option::<String>::deserialize(d)?;\n    if let Some(source) = source {\n        Ok(Some(regex::Regex::new(&source).map_err(de::Error::custom)?))\n    } else {\n        Ok(None)\n    }\n}\n\nfn regex_json_schema(_: &mut SchemaGenerator) -> Schema {\n    Schema::Object(SchemaObject {\n        instance_type: Some(InstanceType::String.into()),\n        ..Default::default()\n    })\n}\n\nfn serialize_regex<S>(regex: &Option<Regex>, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    match regex {\n        Some(regex) => serializer.serialize_str(regex.as_str()),\n        None => serializer.serialize_none(),\n    }\n}\n\n#[doc(hidden)]\n#[cfg(any(test, feature = \"test-support\"))]\npub struct FakeLspAdapter {\n    pub name: &'static str,\n    pub initialization_options: Option<Value>,\n    pub prettier_plugins: Vec<&'static str>,\n    pub disk_based_diagnostics_progress_token: Option<String>,\n    pub disk_based_diagnostics_sources: Vec<String>,\n    pub language_server_binary: LanguageServerBinary,\n\n    pub capabilities: lsp::ServerCapabilities,\n    pub initializer: Option<Box<dyn 'static + Send + Sync + Fn(&mut lsp::FakeLanguageServer)>>,\n    pub label_for_completion: Option<\n        Box<\n            dyn 'static\n                + Send\n                + Sync\n                + Fn(&lsp::CompletionItem, &Arc<Language>) -> Option<CodeLabel>,\n        >,\n    >,\n}\n\n/// Configuration of handling bracket pairs for a given language.\n///\n/// This struct includes settings for defining which pairs of characters are considered brackets and\n/// also specifies any language-specific scopes where these pairs should be ignored for bracket matching purposes.\n#[derive(Clone, Debug, Default, JsonSchema)]\npub struct BracketPairConfig {\n    /// A list of character pairs that should be treated as brackets in the context of a given language.\n    pub pairs: Vec<BracketPair>,\n    /// A list of tree-sitter scopes for which a given bracket should not be active.\n    /// N-th entry in `[Self::disabled_scopes_by_bracket_ix]` contains a list of disabled scopes for an n-th entry in `[Self::pairs]`\n    #[serde(skip)]\n    pub disabled_scopes_by_bracket_ix: Vec<Vec<String>>,\n}\n\nfn bracket_pair_config_json_schema(gen: &mut SchemaGenerator) -> Schema {\n    Option::<Vec<BracketPairContent>>::json_schema(gen)\n}\n\n#[derive(Deserialize, JsonSchema)]\npub struct BracketPairContent {\n    #[serde(flatten)]\n    pub bracket_pair: BracketPair,\n    #[serde(default)]\n    pub not_in: Vec<String>,\n}\n\nimpl<'de> Deserialize<'de> for BracketPairConfig {\n    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let result = Vec::<BracketPairContent>::deserialize(deserializer)?;\n        let mut brackets = Vec::with_capacity(result.len());\n        let mut disabled_scopes_by_bracket_ix = Vec::with_capacity(result.len());\n        for entry in result {\n            brackets.push(entry.bracket_pair);\n            disabled_scopes_by_bracket_ix.push(entry.not_in);\n        }\n\n        Ok(BracketPairConfig {\n            pairs: brackets,\n            disabled_scopes_by_bracket_ix,\n        })\n    }\n}\n\n/// Describes a single bracket pair and how an editor should react to e.g. inserting\n/// an opening bracket or to a newline character insertion in between `start` and `end` characters.\n#[derive(Clone, Debug, Default, Deserialize, PartialEq, JsonSchema)]\npub struct BracketPair {\n    /// Starting substring for a bracket.\n    pub start: String,\n    /// Ending substring for a bracket.\n    pub end: String,\n    /// True if `end` should be automatically inserted right after `start` characters.\n    pub close: bool,\n    /// True if selected text should be surrounded by `start` and `end` characters.\n    #[serde(default = \"default_true\")]\n    pub surround: bool,\n    /// True if an extra newline should be inserted while the cursor is in the middle\n    /// of that bracket pair.\n    pub newline: bool,\n}\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\npub(crate) struct LanguageId(usize);\n\nimpl LanguageId {\n    pub(crate) fn new() -> Self {\n        Self(NEXT_LANGUAGE_ID.fetch_add(1, SeqCst))\n    }\n}\n\npub struct Language {\n    pub(crate) id: LanguageId,\n    pub(crate) config: LanguageConfig,\n    pub(crate) grammar: Option<Arc<Grammar>>,\n    pub(crate) context_provider: Option<Arc<dyn ContextProvider>>,\n    pub(crate) toolchain: Option<Arc<dyn ToolchainLister>>,\n}\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\npub struct GrammarId(pub usize);\n\nimpl GrammarId {\n    pub(crate) fn new() -> Self {\n        Self(NEXT_GRAMMAR_ID.fetch_add(1, SeqCst))\n    }\n}\n\npub struct Grammar {\n    id: GrammarId,\n    pub ts_language: tree_sitter::Language,\n    pub(crate) error_query: Query,\n    pub(crate) highlights_query: Option<Query>,\n    pub(crate) brackets_config: Option<BracketConfig>,\n    pub(crate) redactions_config: Option<RedactionConfig>,\n    pub(crate) runnable_config: Option<RunnableConfig>,\n    pub(crate) indents_config: Option<IndentConfig>,\n    pub outline_config: Option<OutlineConfig>,\n    pub text_object_config: Option<TextObjectConfig>,\n    pub embedding_config: Option<EmbeddingConfig>,\n    pub(crate) injection_config: Option<InjectionConfig>,\n    pub(crate) override_config: Option<OverrideConfig>,\n    pub(crate) highlight_map: Mutex<HighlightMap>,\n}\n\nstruct IndentConfig {\n    query: Query,\n    indent_capture_ix: u32,\n    start_capture_ix: Option<u32>,\n    end_capture_ix: Option<u32>,\n    outdent_capture_ix: Option<u32>,\n}\n\npub struct OutlineConfig {\n    pub query: Query,\n    pub item_capture_ix: u32,\n    pub name_capture_ix: u32,\n    pub context_capture_ix: Option<u32>,\n    pub extra_context_capture_ix: Option<u32>,\n    pub open_capture_ix: Option<u32>,\n    pub close_capture_ix: Option<u32>,\n    pub annotation_capture_ix: Option<u32>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum TextObject {\n    InsideFunction,\n    AroundFunction,\n    InsideClass,\n    AroundClass,\n    InsideComment,\n    AroundComment,\n}\n\nimpl TextObject {\n    pub fn from_capture_name(name: &str) -> Option<TextObject> {\n        match name {\n            \"function.inside\" => Some(TextObject::InsideFunction),\n            \"function.around\" => Some(TextObject::AroundFunction),\n            \"class.inside\" => Some(TextObject::InsideClass),\n            \"class.around\" => Some(TextObject::AroundClass),\n            \"comment.inside\" => Some(TextObject::InsideComment),\n            \"comment.around\" => Some(TextObject::AroundComment),\n            _ => None,\n        }\n    }\n\n    pub fn around(&self) -> Option<Self> {\n        match self {\n            TextObject::InsideFunction => Some(TextObject::AroundFunction),\n            TextObject::InsideClass => Some(TextObject::AroundClass),\n            TextObject::InsideComment => Some(TextObject::AroundComment),\n            _ => None,\n        }\n    }\n}\n\npub struct TextObjectConfig {\n    pub query: Query,\n    pub text_objects_by_capture_ix: Vec<(u32, TextObject)>,\n}\n\n#[derive(Debug)]\npub struct EmbeddingConfig {\n    pub query: Query,\n    pub item_capture_ix: u32,\n    pub name_capture_ix: Option<u32>,\n    pub context_capture_ix: Option<u32>,\n    pub collapse_capture_ix: Option<u32>,\n    pub keep_capture_ix: Option<u32>,\n}\n\nstruct InjectionConfig {\n    query: Query,\n    content_capture_ix: u32,\n    language_capture_ix: Option<u32>,\n    patterns: Vec<InjectionPatternConfig>,\n}\n\nstruct RedactionConfig {\n    pub query: Query,\n    pub redaction_capture_ix: u32,\n}\n\n#[derive(Clone, Debug, PartialEq)]\nenum RunnableCapture {\n    Named(SharedString),\n    Run,\n}\n\nstruct RunnableConfig {\n    pub query: Query,\n    /// A mapping from capture indice to capture kind\n    pub extra_captures: Vec<RunnableCapture>,\n}\n\nstruct OverrideConfig {\n    query: Query,\n    values: HashMap<u32, OverrideEntry>,\n}\n\n#[derive(Debug)]\nstruct OverrideEntry {\n    name: String,\n    range_is_inclusive: bool,\n    value: LanguageConfigOverride,\n}\n\n#[derive(Default, Clone)]\nstruct InjectionPatternConfig {\n    language: Option<Box<str>>,\n    combined: bool,\n}\n\nstruct BracketConfig {\n    query: Query,\n    open_capture_ix: u32,\n    close_capture_ix: u32,\n}\n\nimpl Language {\n    pub fn new(config: LanguageConfig, ts_language: Option<tree_sitter::Language>) -> Self {\n        Self::new_with_id(LanguageId::new(), config, ts_language)\n    }\n\n    fn new_with_id(\n        id: LanguageId,\n        config: LanguageConfig,\n        ts_language: Option<tree_sitter::Language>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            grammar: ts_language.map(|ts_language| {\n                Arc::new(Grammar {\n                    id: GrammarId::new(),\n                    highlights_query: None,\n                    brackets_config: None,\n                    outline_config: None,\n                    text_object_config: None,\n                    embedding_config: None,\n                    indents_config: None,\n                    injection_config: None,\n                    override_config: None,\n                    redactions_config: None,\n                    runnable_config: None,\n                    error_query: Query::new(&ts_language, \"(ERROR) @error\").unwrap(),\n                    ts_language,\n                    highlight_map: Default::default(),\n                })\n            }),\n            context_provider: None,\n            toolchain: None,\n        }\n    }\n\n    pub fn with_context_provider(mut self, provider: Option<Arc<dyn ContextProvider>>) -> Self {\n        self.context_provider = provider;\n        self\n    }\n\n    pub fn with_toolchain_lister(mut self, provider: Option<Arc<dyn ToolchainLister>>) -> Self {\n        self.toolchain = provider;\n        self\n    }\n\n    pub fn with_queries(mut self, queries: LanguageQueries) -> Result<Self> {\n        if let Some(query) = queries.highlights {\n            self = self\n                .with_highlights_query(query.as_ref())\n                .context(\"Error loading highlights query\")?;\n        }\n        if let Some(query) = queries.brackets {\n            self = self\n                .with_brackets_query(query.as_ref())\n                .context(\"Error loading brackets query\")?;\n        }\n        if let Some(query) = queries.indents {\n            self = self\n                .with_indents_query(query.as_ref())\n                .context(\"Error loading indents query\")?;\n        }\n        if let Some(query) = queries.outline {\n            self = self\n                .with_outline_query(query.as_ref())\n                .context(\"Error loading outline query\")?;\n        }\n        if let Some(query) = queries.embedding {\n            self = self\n                .with_embedding_query(query.as_ref())\n                .context(\"Error loading embedding query\")?;\n        }\n        if let Some(query) = queries.injections {\n            self = self\n                .with_injection_query(query.as_ref())\n                .context(\"Error loading injection query\")?;\n        }\n        if let Some(query) = queries.overrides {\n            self = self\n                .with_override_query(query.as_ref())\n                .context(\"Error loading override query\")?;\n        }\n        if let Some(query) = queries.redactions {\n            self = self\n                .with_redaction_query(query.as_ref())\n                .context(\"Error loading redaction query\")?;\n        }\n        if let Some(query) = queries.runnables {\n            self = self\n                .with_runnable_query(query.as_ref())\n                .context(\"Error loading runnables query\")?;\n        }\n        if let Some(query) = queries.text_objects {\n            self = self\n                .with_text_object_query(query.as_ref())\n                .context(\"Error loading textobject query\")?;\n        }\n        Ok(self)\n    }\n\n    pub fn with_highlights_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        grammar.highlights_query = Some(Query::new(&grammar.ts_language, source)?);\n        Ok(self)\n    }\n\n    pub fn with_runnable_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut extra_captures = Vec::with_capacity(query.capture_names().len());\n\n        for name in query.capture_names().iter() {\n            let kind = if *name == \"run\" {\n                RunnableCapture::Run\n            } else {\n                RunnableCapture::Named(name.to_string().into())\n            };\n            extra_captures.push(kind);\n        }\n\n        grammar.runnable_config = Some(RunnableConfig {\n            extra_captures,\n            query,\n        });\n\n        Ok(self)\n    }\n\n    pub fn with_outline_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut item_capture_ix = None;\n        let mut name_capture_ix = None;\n        let mut context_capture_ix = None;\n        let mut extra_context_capture_ix = None;\n        let mut open_capture_ix = None;\n        let mut close_capture_ix = None;\n        let mut annotation_capture_ix = None;\n        get_capture_indices(\n            &query,\n            &mut [\n                (\"item\", &mut item_capture_ix),\n                (\"name\", &mut name_capture_ix),\n                (\"context\", &mut context_capture_ix),\n                (\"context.extra\", &mut extra_context_capture_ix),\n                (\"open\", &mut open_capture_ix),\n                (\"close\", &mut close_capture_ix),\n                (\"annotation\", &mut annotation_capture_ix),\n            ],\n        );\n        if let Some((item_capture_ix, name_capture_ix)) = item_capture_ix.zip(name_capture_ix) {\n            grammar.outline_config = Some(OutlineConfig {\n                query,\n                item_capture_ix,\n                name_capture_ix,\n                context_capture_ix,\n                extra_context_capture_ix,\n                open_capture_ix,\n                close_capture_ix,\n                annotation_capture_ix,\n            });\n        }\n        Ok(self)\n    }\n\n    pub fn with_text_object_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n\n        let mut text_objects_by_capture_ix = Vec::new();\n        for (ix, name) in query.capture_names().iter().enumerate() {\n            if let Some(text_object) = TextObject::from_capture_name(name) {\n                text_objects_by_capture_ix.push((ix as u32, text_object));\n            }\n        }\n\n        grammar.text_object_config = Some(TextObjectConfig {\n            query,\n            text_objects_by_capture_ix,\n        });\n        Ok(self)\n    }\n\n    pub fn with_embedding_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut item_capture_ix = None;\n        let mut name_capture_ix = None;\n        let mut context_capture_ix = None;\n        let mut collapse_capture_ix = None;\n        let mut keep_capture_ix = None;\n        get_capture_indices(\n            &query,\n            &mut [\n                (\"item\", &mut item_capture_ix),\n                (\"name\", &mut name_capture_ix),\n                (\"context\", &mut context_capture_ix),\n                (\"keep\", &mut keep_capture_ix),\n                (\"collapse\", &mut collapse_capture_ix),\n            ],\n        );\n        if let Some(item_capture_ix) = item_capture_ix {\n            grammar.embedding_config = Some(EmbeddingConfig {\n                query,\n                item_capture_ix,\n                name_capture_ix,\n                context_capture_ix,\n                collapse_capture_ix,\n                keep_capture_ix,\n            });\n        }\n        Ok(self)\n    }\n\n    pub fn with_brackets_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut open_capture_ix = None;\n        let mut close_capture_ix = None;\n        get_capture_indices(\n            &query,\n            &mut [\n                (\"open\", &mut open_capture_ix),\n                (\"close\", &mut close_capture_ix),\n            ],\n        );\n        if let Some((open_capture_ix, close_capture_ix)) = open_capture_ix.zip(close_capture_ix) {\n            grammar.brackets_config = Some(BracketConfig {\n                query,\n                open_capture_ix,\n                close_capture_ix,\n            });\n        }\n        Ok(self)\n    }\n\n    pub fn with_indents_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut indent_capture_ix = None;\n        let mut start_capture_ix = None;\n        let mut end_capture_ix = None;\n        let mut outdent_capture_ix = None;\n        get_capture_indices(\n            &query,\n            &mut [\n                (\"indent\", &mut indent_capture_ix),\n                (\"start\", &mut start_capture_ix),\n                (\"end\", &mut end_capture_ix),\n                (\"outdent\", &mut outdent_capture_ix),\n            ],\n        );\n        if let Some(indent_capture_ix) = indent_capture_ix {\n            grammar.indents_config = Some(IndentConfig {\n                query,\n                indent_capture_ix,\n                start_capture_ix,\n                end_capture_ix,\n                outdent_capture_ix,\n            });\n        }\n        Ok(self)\n    }\n\n    pub fn with_injection_query(mut self, source: &str) -> Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut language_capture_ix = None;\n        let mut injection_language_capture_ix = None;\n        let mut content_capture_ix = None;\n        let mut injection_content_capture_ix = None;\n        get_capture_indices(\n            &query,\n            &mut [\n                (\"language\", &mut language_capture_ix),\n                (\"injection.language\", &mut injection_language_capture_ix),\n                (\"content\", &mut content_capture_ix),\n                (\"injection.content\", &mut injection_content_capture_ix),\n            ],\n        );\n        language_capture_ix = match (language_capture_ix, injection_language_capture_ix) {\n            (None, Some(ix)) => Some(ix),\n            (Some(_), Some(_)) => {\n                return Err(anyhow!(\n                    \"both language and injection.language captures are present\"\n                ));\n            }\n            _ => language_capture_ix,\n        };\n        content_capture_ix = match (content_capture_ix, injection_content_capture_ix) {\n            (None, Some(ix)) => Some(ix),\n            (Some(_), Some(_)) => {\n                return Err(anyhow!(\n                    \"both content and injection.content captures are present\"\n                ));\n            }\n            _ => content_capture_ix,\n        };\n        let patterns = (0..query.pattern_count())\n            .map(|ix| {\n                let mut config = InjectionPatternConfig::default();\n                for setting in query.property_settings(ix) {\n                    match setting.key.as_ref() {\n                        \"language\" | \"injection.language\" => {\n                            config.language.clone_from(&setting.value);\n                        }\n                        \"combined\" | \"injection.combined\" => {\n                            config.combined = true;\n                        }\n                        _ => {}\n                    }\n                }\n                config\n            })\n            .collect();\n        if let Some(content_capture_ix) = content_capture_ix {\n            grammar.injection_config = Some(InjectionConfig {\n                query,\n                language_capture_ix,\n                content_capture_ix,\n                patterns,\n            });\n        }\n        Ok(self)\n    }\n\n    pub fn with_override_query(mut self, source: &str) -> anyhow::Result<Self> {\n        let query = {\n            let grammar = self\n                .grammar\n                .as_ref()\n                .ok_or_else(|| anyhow!(\"no grammar for language\"))?;\n            Query::new(&grammar.ts_language, source)?\n        };\n\n        let mut override_configs_by_id = HashMap::default();\n        for (ix, mut name) in query.capture_names().iter().copied().enumerate() {\n            let mut range_is_inclusive = false;\n            if name.starts_with('_') {\n                continue;\n            }\n            if let Some(prefix) = name.strip_suffix(\".inclusive\") {\n                name = prefix;\n                range_is_inclusive = true;\n            }\n\n            let value = self.config.overrides.get(name).cloned().unwrap_or_default();\n            for server_name in &value.opt_into_language_servers {\n                if !self\n                    .config\n                    .scope_opt_in_language_servers\n                    .contains(server_name)\n                {\n                    util::debug_panic!(\"Server {server_name:?} has been opted-in by scope {name:?} but has not been marked as an opt-in server\");\n                }\n            }\n\n            override_configs_by_id.insert(\n                ix as u32,\n                OverrideEntry {\n                    name: name.to_string(),\n                    range_is_inclusive,\n                    value,\n                },\n            );\n        }\n\n        let referenced_override_names = self.config.overrides.keys().chain(\n            self.config\n                .brackets\n                .disabled_scopes_by_bracket_ix\n                .iter()\n                .flatten(),\n        );\n\n        for referenced_name in referenced_override_names {\n            if !override_configs_by_id\n                .values()\n                .any(|entry| entry.name == *referenced_name)\n            {\n                Err(anyhow!(\n                    \"language {:?} has overrides in config not in query: {referenced_name:?}\",\n                    self.config.name\n                ))?;\n            }\n        }\n\n        for entry in override_configs_by_id.values_mut() {\n            entry.value.disabled_bracket_ixs = self\n                .config\n                .brackets\n                .disabled_scopes_by_bracket_ix\n                .iter()\n                .enumerate()\n                .filter_map(|(ix, disabled_scope_names)| {\n                    if disabled_scope_names.contains(&entry.name) {\n                        Some(ix as u16)\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n        }\n\n        self.config.brackets.disabled_scopes_by_bracket_ix.clear();\n\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n        grammar.override_config = Some(OverrideConfig {\n            query,\n            values: override_configs_by_id,\n        });\n        Ok(self)\n    }\n\n    pub fn with_redaction_query(mut self, source: &str) -> anyhow::Result<Self> {\n        let grammar = self\n            .grammar_mut()\n            .ok_or_else(|| anyhow!(\"cannot mutate grammar\"))?;\n\n        let query = Query::new(&grammar.ts_language, source)?;\n        let mut redaction_capture_ix = None;\n        get_capture_indices(&query, &mut [(\"redact\", &mut redaction_capture_ix)]);\n\n        if let Some(redaction_capture_ix) = redaction_capture_ix {\n            grammar.redactions_config = Some(RedactionConfig {\n                query,\n                redaction_capture_ix,\n            });\n        }\n\n        Ok(self)\n    }\n\n    fn grammar_mut(&mut self) -> Option<&mut Grammar> {\n        Arc::get_mut(self.grammar.as_mut()?)\n    }\n\n    pub fn name(&self) -> LanguageName {\n        self.config.name.clone()\n    }\n\n    pub fn code_fence_block_name(&self) -> Arc<str> {\n        self.config\n            .code_fence_block_name\n            .clone()\n            .unwrap_or_else(|| self.config.name.as_ref().to_lowercase().into())\n    }\n\n    pub fn context_provider(&self) -> Option<Arc<dyn ContextProvider>> {\n        self.context_provider.clone()\n    }\n\n    pub fn toolchain_lister(&self) -> Option<Arc<dyn ToolchainLister>> {\n        self.toolchain.clone()\n    }\n\n    pub fn highlight_text<'a>(\n        self: &'a Arc<Self>,\n        text: &'a Rope,\n        range: Range<usize>,\n    ) -> Vec<(Range<usize>, HighlightId)> {\n        let mut result = Vec::new();\n        if let Some(grammar) = &self.grammar {\n            let tree = grammar.parse_text(text, None);\n            let captures =\n                SyntaxSnapshot::single_tree_captures(range.clone(), text, &tree, self, |grammar| {\n                    grammar.highlights_query.as_ref()\n                });\n            let highlight_maps = vec![grammar.highlight_map()];\n            let mut offset = 0;\n            for chunk in\n                BufferChunks::new(text, range, Some((captures, highlight_maps)), false, None)\n            {\n                let end_offset = offset + chunk.text.len();\n                if let Some(highlight_id) = chunk.syntax_highlight_id {\n                    if !highlight_id.is_default() {\n                        result.push((offset..end_offset, highlight_id));\n                    }\n                }\n                offset = end_offset;\n            }\n        }\n        result\n    }\n\n    pub fn path_suffixes(&self) -> &[String] {\n        &self.config.matcher.path_suffixes\n    }\n\n    pub fn should_autoclose_before(&self, c: char) -> bool {\n        c.is_whitespace() || self.config.autoclose_before.contains(c)\n    }\n\n    pub fn set_theme(&self, theme: &SyntaxTheme) {\n        if let Some(grammar) = self.grammar.as_ref() {\n            if let Some(highlights_query) = &grammar.highlights_query {\n                *grammar.highlight_map.lock() =\n                    HighlightMap::new(highlights_query.capture_names(), theme);\n            }\n        }\n    }\n\n    pub fn grammar(&self) -> Option<&Arc<Grammar>> {\n        self.grammar.as_ref()\n    }\n\n    pub fn default_scope(self: &Arc<Self>) -> LanguageScope {\n        LanguageScope {\n            language: self.clone(),\n            override_id: None,\n        }\n    }\n\n    pub fn lsp_id(&self) -> String {\n        self.config.name.lsp_id()\n    }\n\n    pub fn prettier_parser_name(&self) -> Option<&str> {\n        self.config.prettier_parser_name.as_deref()\n    }\n\n    pub fn config(&self) -> &LanguageConfig {\n        &self.config\n    }\n}\n\nimpl LanguageScope {\n    pub fn path_suffixes(&self) -> &[String] {\n        &self.language.path_suffixes()\n    }\n\n    pub fn language_name(&self) -> LanguageName {\n        self.language.config.name.clone()\n    }\n\n    pub fn collapsed_placeholder(&self) -> &str {\n        self.language.config.collapsed_placeholder.as_ref()\n    }\n\n    /// Returns line prefix that is inserted in e.g. line continuations or\n    /// in `toggle comments` action.\n    pub fn line_comment_prefixes(&self) -> &[Arc<str>] {\n        Override::as_option(\n            self.config_override().map(|o| &o.line_comments),\n            Some(&self.language.config.line_comments),\n        )\n        .map_or([].as_slice(), |e| e.as_slice())\n    }\n\n    pub fn block_comment_delimiters(&self) -> Option<(&Arc<str>, &Arc<str>)> {\n        Override::as_option(\n            self.config_override().map(|o| &o.block_comment),\n            self.language.config.block_comment.as_ref(),\n        )\n        .map(|e| (&e.0, &e.1))\n    }\n\n    /// Returns a list of language-specific word characters.\n    ///\n    /// By default, Zed treats alphanumeric characters (and '_') as word characters for\n    /// the purpose of actions like 'move to next word end` or whole-word search.\n    /// It additionally accounts for language's additional word characters.\n    pub fn word_characters(&self) -> Option<&HashSet<char>> {\n        Override::as_option(\n            self.config_override().map(|o| &o.word_characters),\n            Some(&self.language.config.word_characters),\n        )\n    }\n\n    /// Returns a list of bracket pairs for a given language with an additional\n    /// piece of information about whether the particular bracket pair is currently active for a given language.\n    pub fn brackets(&self) -> impl Iterator<Item = (&BracketPair, bool)> {\n        let mut disabled_ids = self\n            .config_override()\n            .map_or(&[] as _, |o| o.disabled_bracket_ixs.as_slice());\n        self.language\n            .config\n            .brackets\n            .pairs\n            .iter()\n            .enumerate()\n            .map(move |(ix, bracket)| {\n                let mut is_enabled = true;\n                if let Some(next_disabled_ix) = disabled_ids.first() {\n                    if ix == *next_disabled_ix as usize {\n                        disabled_ids = &disabled_ids[1..];\n                        is_enabled = false;\n                    }\n                }\n                (bracket, is_enabled)\n            })\n    }\n\n    pub fn should_autoclose_before(&self, c: char) -> bool {\n        c.is_whitespace() || self.language.config.autoclose_before.contains(c)\n    }\n\n    pub fn language_allowed(&self, name: &LanguageServerName) -> bool {\n        let config = &self.language.config;\n        let opt_in_servers = &config.scope_opt_in_language_servers;\n        if opt_in_servers.iter().any(|o| *o == *name) {\n            if let Some(over) = self.config_override() {\n                over.opt_into_language_servers.iter().any(|o| *o == *name)\n            } else {\n                false\n            }\n        } else {\n            true\n        }\n    }\n\n    pub fn override_name(&self) -> Option<&str> {\n        let id = self.override_id?;\n        let grammar = self.language.grammar.as_ref()?;\n        let override_config = grammar.override_config.as_ref()?;\n        override_config.values.get(&id).map(|e| e.name.as_str())\n    }\n\n    fn config_override(&self) -> Option<&LanguageConfigOverride> {\n        let id = self.override_id?;\n        let grammar = self.language.grammar.as_ref()?;\n        let override_config = grammar.override_config.as_ref()?;\n        override_config.values.get(&id).map(|e| &e.value)\n    }\n}\n\nimpl Hash for Language {\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        self.id.hash(state)\n    }\n}\n\nimpl PartialEq for Language {\n    fn eq(&self, other: &Self) -> bool {\n        self.id.eq(&other.id)\n    }\n}\n\nimpl Eq for Language {}\n\nimpl Debug for Language {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Language\")\n            .field(\"name\", &self.config.name)\n            .finish()\n    }\n}\n\nimpl Grammar {\n    pub fn id(&self) -> GrammarId {\n        self.id\n    }\n\n    fn parse_text(&self, text: &Rope, old_tree: Option<Tree>) -> Tree {\n        with_parser(|parser| {\n            parser\n                .set_language(&self.ts_language)\n                .expect(\"incompatible grammar\");\n            let mut chunks = text.chunks_in_range(0..text.len());\n            parser\n                .parse_with(\n                    &mut move |offset, _| {\n                        chunks.seek(offset);\n                        chunks.next().unwrap_or(\"\").as_bytes()\n                    },\n                    old_tree.as_ref(),\n                )\n                .unwrap()\n        })\n    }\n\n    pub fn highlight_map(&self) -> HighlightMap {\n        self.highlight_map.lock().clone()\n    }\n\n    pub fn highlight_id_for_name(&self, name: &str) -> Option<HighlightId> {\n        let capture_id = self\n            .highlights_query\n            .as_ref()?\n            .capture_index_for_name(name)?;\n        Some(self.highlight_map.lock().get(capture_id))\n    }\n}\n\nimpl CodeLabel {\n    pub fn fallback_for_completion(\n        item: &lsp::CompletionItem,\n        language: Option<&Language>,\n    ) -> Self {\n        let highlight_id = item.kind.and_then(|kind| {\n            let grammar = language?.grammar()?;\n            use lsp::CompletionItemKind as Kind;\n            match kind {\n                Kind::CLASS => grammar.highlight_id_for_name(\"type\"),\n                Kind::CONSTANT => grammar.highlight_id_for_name(\"constant\"),\n                Kind::CONSTRUCTOR => grammar.highlight_id_for_name(\"constructor\"),\n                Kind::ENUM => grammar\n                    .highlight_id_for_name(\"enum\")\n                    .or_else(|| grammar.highlight_id_for_name(\"type\")),\n                Kind::FIELD => grammar.highlight_id_for_name(\"property\"),\n                Kind::FUNCTION => grammar.highlight_id_for_name(\"function\"),\n                Kind::INTERFACE => grammar.highlight_id_for_name(\"type\"),\n                Kind::METHOD => grammar\n                    .highlight_id_for_name(\"function.method\")\n                    .or_else(|| grammar.highlight_id_for_name(\"function\")),\n                Kind::OPERATOR => grammar.highlight_id_for_name(\"operator\"),\n                Kind::PROPERTY => grammar.highlight_id_for_name(\"property\"),\n                Kind::STRUCT => grammar.highlight_id_for_name(\"type\"),\n                Kind::VARIABLE => grammar.highlight_id_for_name(\"variable\"),\n                Kind::KEYWORD => grammar.highlight_id_for_name(\"keyword\"),\n                _ => None,\n            }\n        });\n\n        let label = &item.label;\n        let label_length = label.len();\n        let runs = highlight_id\n            .map(|highlight_id| vec![(0..label_length, highlight_id)])\n            .unwrap_or_default();\n        let text = if let Some(detail) = &item.detail {\n            format!(\"{label} {detail}\")\n        } else if let Some(description) = item\n            .label_details\n            .as_ref()\n            .and_then(|label_details| label_details.description.as_ref())\n        {\n            format!(\"{label} {description}\")\n        } else {\n            label.clone()\n        };\n        Self {\n            text,\n            runs,\n            filter_range: 0..label_length,\n        }\n    }\n\n    pub fn plain(text: String, filter_text: Option<&str>) -> Self {\n        let mut result = Self {\n            runs: Vec::new(),\n            filter_range: 0..text.len(),\n            text,\n        };\n        if let Some(filter_text) = filter_text {\n            if let Some(ix) = result.text.find(filter_text) {\n                result.filter_range = ix..ix + filter_text.len();\n            }\n        }\n        result\n    }\n\n    pub fn push_str(&mut self, text: &str, highlight: Option<HighlightId>) {\n        let start_ix = self.text.len();\n        self.text.push_str(text);\n        let end_ix = self.text.len();\n        if let Some(highlight) = highlight {\n            self.runs.push((start_ix..end_ix, highlight));\n        }\n    }\n\n    pub fn text(&self) -> &str {\n        self.text.as_str()\n    }\n\n    pub fn filter_text(&self) -> &str {\n        &self.text[self.filter_range.clone()]\n    }\n}\n\nimpl From<String> for CodeLabel {\n    fn from(value: String) -> Self {\n        Self::plain(value, None)\n    }\n}\n\nimpl From<&str> for CodeLabel {\n    fn from(value: &str) -> Self {\n        Self::plain(value.to_string(), None)\n    }\n}\n\nimpl Ord for LanguageMatcher {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.path_suffixes.cmp(&other.path_suffixes).then_with(|| {\n            self.first_line_pattern\n                .as_ref()\n                .map(Regex::as_str)\n                .cmp(&other.first_line_pattern.as_ref().map(Regex::as_str))\n        })\n    }\n}\n\nimpl PartialOrd for LanguageMatcher {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Eq for LanguageMatcher {}\n\nimpl PartialEq for LanguageMatcher {\n    fn eq(&self, other: &Self) -> bool {\n        self.path_suffixes == other.path_suffixes\n            && self.first_line_pattern.as_ref().map(Regex::as_str)\n                == other.first_line_pattern.as_ref().map(Regex::as_str)\n    }\n}\n\n#[cfg(any(test, feature = \"test-support\"))]\nimpl Default for FakeLspAdapter {\n    fn default() -> Self {\n        Self {\n            name: \"the-fake-language-server\",\n            capabilities: lsp::LanguageServer::full_capabilities(),\n            initializer: None,\n            disk_based_diagnostics_progress_token: None,\n            initialization_options: None,\n            disk_based_diagnostics_sources: Vec::new(),\n            prettier_plugins: Vec::new(),\n            language_server_binary: LanguageServerBinary {\n                path: \"/the/fake/lsp/path\".into(),\n                arguments: vec![],\n                env: Default::default(),\n            },\n            label_for_completion: None,\n        }\n    }\n}\n\n#[cfg(any(test, feature = \"test-support\"))]\n#[async_trait(?Send)]\nimpl LspAdapter for FakeLspAdapter {\n    fn name(&self) -> LanguageServerName {\n        LanguageServerName(self.name.into())\n    }\n\n    async fn check_if_user_installed(\n        &self,\n        _: &dyn LspAdapterDelegate,\n        _: Arc<dyn LanguageToolchainStore>,\n        _: &AsyncApp,\n    ) -> Option<LanguageServerBinary> {\n        Some(self.language_server_binary.clone())\n    }\n\n    fn get_language_server_command<'a>(\n        self: Arc<Self>,\n        _: Arc<dyn LspAdapterDelegate>,\n        _: Arc<dyn LanguageToolchainStore>,\n        _: LanguageServerBinaryOptions,\n        _: futures::lock::MutexGuard<'a, Option<LanguageServerBinary>>,\n        _: &'a mut AsyncApp,\n    ) -> Pin<Box<dyn 'a + Future<Output = Result<LanguageServerBinary>>>> {\n        async move { Ok(self.language_server_binary.clone()) }.boxed_local()\n    }\n\n    async fn fetch_latest_server_version(\n        &self,\n        _: &dyn LspAdapterDelegate,\n    ) -> Result<Box<dyn 'static + Send + Any>> {\n        unreachable!();\n    }\n\n    async fn fetch_server_binary(\n        &self,\n        _: Box<dyn 'static + Send + Any>,\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Result<LanguageServerBinary> {\n        unreachable!();\n    }\n\n    async fn cached_server_binary(\n        &self,\n        _: PathBuf,\n        _: &dyn LspAdapterDelegate,\n    ) -> Option<LanguageServerBinary> {\n        unreachable!();\n    }\n\n    fn process_diagnostics(&self, _: &mut lsp::PublishDiagnosticsParams) {}\n\n    fn disk_based_diagnostic_sources(&self) -> Vec<String> {\n        self.disk_based_diagnostics_sources.clone()\n    }\n\n    fn disk_based_diagnostics_progress_token(&self) -> Option<String> {\n        self.disk_based_diagnostics_progress_token.clone()\n    }\n\n    async fn initialization_options(\n        self: Arc<Self>,\n        _: &dyn Fs,\n        _: &Arc<dyn LspAdapterDelegate>,\n    ) -> Result<Option<Value>> {\n        Ok(self.initialization_options.clone())\n    }\n\n    async fn label_for_completion(\n        &self,\n        item: &lsp::CompletionItem,\n        language: &Arc<Language>,\n    ) -> Option<CodeLabel> {\n        let label_for_completion = self.label_for_completion.as_ref()?;\n        label_for_completion(item, language)\n    }\n}\n\nfn get_capture_indices(query: &Query, captures: &mut [(&str, &mut Option<u32>)]) {\n    for (ix, name) in query.capture_names().iter().enumerate() {\n        for (capture_name, index) in captures.iter_mut() {\n            if capture_name == name {\n                **index = Some(ix as u32);\n                break;\n            }\n        }\n    }\n}\n\npub fn point_to_lsp(point: PointUtf16) -> lsp::Position {\n    lsp::Position::new(point.row, point.column)\n}\n\npub fn point_from_lsp(point: lsp::Position) -> Unclipped<PointUtf16> {\n    Unclipped(PointUtf16::new(point.line, point.character))\n}\n\npub fn range_to_lsp(range: Range<PointUtf16>) -> Result<lsp::Range> {\n    if range.start > range.end {\n        Err(anyhow!(\n            \"Inverted range provided to an LSP request: {:?}-{:?}\",\n            range.start,\n            range.end\n        ))\n    } else {\n        Ok(lsp::Range {\n            start: point_to_lsp(range.start),\n            end: point_to_lsp(range.end),\n        })\n    }\n}\n\npub fn range_from_lsp(range: lsp::Range) -> Range<Unclipped<PointUtf16>> {\n    let mut start = point_from_lsp(range.start);\n    let mut end = point_from_lsp(range.end);\n    if start > end {\n        log::warn!(\"range_from_lsp called with inverted range {start:?}-{end:?}\");\n        mem::swap(&mut start, &mut end);\n    }\n    start..end\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use gpui::TestAppContext;\n\n    #[gpui::test(iterations = 10)]\n    async fn test_language_loading(cx: &mut TestAppContext) {\n        let languages = LanguageRegistry::test(cx.executor());\n        let languages = Arc::new(languages);\n        languages.register_native_grammars([\n            (\"json\", tree_sitter_json::LANGUAGE),\n            (\"rust\", tree_sitter_rust::LANGUAGE),\n        ]);\n        languages.register_test_language(LanguageConfig {\n            name: \"JSON\".into(),\n            grammar: Some(\"json\".into()),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![\"json\".into()],\n                ..Default::default()\n            },\n            ..Default::default()\n        });\n        languages.register_test_language(LanguageConfig {\n            name: \"Rust\".into(),\n            grammar: Some(\"rust\".into()),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![\"rs\".into()],\n                ..Default::default()\n            },\n            ..Default::default()\n        });\n        assert_eq!(\n            languages.language_names(),\n            &[\n                \"JSON\".to_string(),\n                \"Plain Text\".to_string(),\n                \"Rust\".to_string(),\n            ]\n        );\n\n        let rust1 = languages.language_for_name(\"Rust\");\n        let rust2 = languages.language_for_name(\"Rust\");\n\n        // Ensure language is still listed even if it's being loaded.\n        assert_eq!(\n            languages.language_names(),\n            &[\n                \"JSON\".to_string(),\n                \"Plain Text\".to_string(),\n                \"Rust\".to_string(),\n            ]\n        );\n\n        let (rust1, rust2) = futures::join!(rust1, rust2);\n        assert!(Arc::ptr_eq(&rust1.unwrap(), &rust2.unwrap()));\n\n        // Ensure language is still listed even after loading it.\n        assert_eq!(\n            languages.language_names(),\n            &[\n                \"JSON\".to_string(),\n                \"Plain Text\".to_string(),\n                \"Rust\".to_string(),\n            ]\n        );\n\n        // Loading an unknown language returns an error.\n        assert!(languages.language_for_name(\"Unknown\").await.is_err());\n    }\n}\n```\n\n\n`tree_sitter_json` doesn't seem to be exported from the language module\nLooking at the code, you're right. While `tree_sitter_json` is used internally, it's not exported from the `language` module. Here's how you can modify your code to use JSON language support:\n\n1. First, register the JSON language with the `LanguageRegistry`:\n\n```rust\nuse editor::Editor;\nuse language::{LanguageConfig, Language, LanguageMatcher};\n\n// Register the JSON language configuration\nlet config = LanguageConfig {\n    name: \"JSON\".into(),\n    grammar: Some(\"json\".into()),\n    matcher: LanguageMatcher {\n        path_suffixes: vec![\"json\".into()],\n        first_line_pattern: None,\n    },\n    ..LanguageConfig::default()\n};\n\n// Create a basic Language instance\nlet language = Arc::new(Language::new(config, None));\n```\n\nIf you need full JSON syntax support, you'll need to:\n\n1. Add the tree-sitter-json dependency to your project\n2. Register it with the `LanguageRegistry`\n\nHere's the complete solution:\n\n```rust\nuse editor::Editor;\nuse language::{LanguageConfig, Language, LanguageRegistry};\n\npub struct BodyEditor {\n    pub editor: Entity<Editor>,\n}\n\nimpl BodyEditor {\n    pub fn new(window: &mut Window, cx: &mut App) -> Self {\n        // First set up the language registry\n        let language_registry = LanguageRegistry::test(cx.background_executor());\n        \n        // Register JSON grammar\n        language_registry.register_native_grammars([\n            (\"json\", tree_sitter_json::language())\n        ]);\n        \n        // Register JSON language config\n        language_registry.register_test_language(LanguageConfig {\n            name: \"JSON\".into(),\n            grammar: Some(\"json\".into()),\n            matcher: LanguageMatcher {\n                path_suffixes: vec![\"json\".into()],\n                first_line_pattern: None,\n            },\n            ..Default::default()\n        });\n\n        let editor = cx.new(|cx| {\n            let buffer = cx.new(|cx| {\n                let buffer = Buffer::local(\"Hello?\", cx);\n                let language = language_registry.language_for_name(\"JSON\");\n                buffer.with_language(language, cx)\n            });\n            let mut editor = Editor::new(EditorMode::Full, buffer, None, true, window, cx);\n\n            editor.set_placeholder_text(\"Just some placeholder\", cx);\n            editor.set_show_cursor_when_unfocused(true, cx);\n            editor.set_cursor_shape(CursorShape::Block, cx);\n\n            editor\n        });\n\n        Self { editor }\n    }\n}\n```\n\nThis will properly set up JSON language support with syntax highlighting and other JSON-specific features. Make sure you have the `tree-sitter-json` dependency in your `Cargo.toml`:\n\n```toml\n[dependencies]\ntree-sitter-json = \"0.20\"\n```\n/","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":194}}},{"id":{"replica_id":0,"value":29},"start":2003,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":195}}},{"id":{"replica_id":0,"value":30},"start":3358,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":196}}},{"id":{"replica_id":0,"value":129},"start":72891,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":197}}},{"id":{"replica_id":0,"value":130},"start":75567,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":198}}}],"summary":"Adding TypeScript Language to Editor","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":1934},"icon":"File","label":"zed/crates/zed/src/body_editor.rs","metadata":{"path":"zed/crates/zed/src/body_editor.rs"}},{"range":{"start":3358,"end":72817},"icon":"File","label":"zed/crates/language/src/language.rs","metadata":{"path":"zed/crates/language/src/language.rs"}}]}