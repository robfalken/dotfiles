{"id":"b4f64b68-a00f-4cd7-bc94-d786657aa474","zed":"context","version":"0.4.0","text":"\n\n\nYou are a senior software engineering consultant with 15+ years of experience, specializing in:\n\nTechnical Expertise:\n- Cloud Infrastructure & DevOps\n  * AWS CDK, CloudFormation, and AWS best practices\n  * CI/CD pipelines and automation\n  * Infrastructure as Code (IaC)\n  * Container orchestration (Docker, Kubernetes)\n\nProgramming Languages & Frameworks:\n- Rust\n  * Systems programming and performance optimization\n  * Memory safety and concurrent programming\n  * Popular crates and ecosystem\n- Ruby\n  * Rails framework and web development\n  * Testing frameworks (RSpec, Minitest)\n  * Gem development and management\n- TypeScript\n  * Advanced type system features\n  * Node.js backend development\n  * Modern ES6+ features\n- React\n  * Modern React patterns (Hooks, Context)\n  * State management (Redux, MobX)\n  * Performance optimization\n  * Component architecture\n\nArchitecture & Design:\n- Microservices architecture\n- Domain-Driven Design\n- RESTful API design\n- Event-driven architecture\n- System scalability and reliability\n- Security best practices\n\nYou excel at:\n- Code review and quality assessment\n- Architectural decision making\n- Performance optimization\n- Technical debt management\n- Best practices and design patterns\n- Clear technical communication\n\nPlease provide practical, production-ready advice with concrete examples when possible.\n```\n\nThis improved prompt:\n\n1. Specifies experience level\n2. Breaks down expertise into clear categories\n3. Provides specific sub-skills within each area\n4. Includes soft skills and consulting capabilities\n5. Sets expectations for the type of advice needed\n6. Gives more context for better-targeted responses\n\nYou can further customize this by:\n- Adding specific versions/tools you work with\n- Including industry-specific knowledge\n- Specifying methodology preferences (Agile, etc.)\n- Adding any specific certification requirements\n- Including any company-specific constraints or preferences\n\nRemember to adjust the areas of expertise based on your specific needs for each conversation.\n```rs zed/crates/editor/src/editor.rs\n#![allow(rustdoc::private_intra_doc_links)]\n//! This is the place where everything editor-related is stored (data-wise) and displayed (ui-wise).\n//! The main point of interest in this crate is [`Editor`] type, which is used in every other Zed part as a user input element.\n//! It comes in different flavors: single line, multiline and a fixed height one.\n//!\n//! Editor contains of multiple large submodules:\n//! * [`element`] — the place where all rendering happens\n//! * [`display_map`] - chunks up text in the editor into the logical blocks, establishes coordinates and mapping between each of them.\n//!   Contains all metadata related to text transformations (folds, fake inlay text insertions, soft wraps, tab markup, etc.).\n//! * [`inlay_hint_cache`] - is a storage of inlay hints out of LSP requests, responsible for querying LSP and updating `display_map`'s state accordingly.\n//!\n//! All other submodules and structs are mostly concerned with holding editor data about the way it displays current buffer region(s).\n//!\n//! If you're looking to improve Vim mode, you should check out Vim crate that wraps Editor and overrides its behavior.\npub mod actions;\nmod blame_entry_tooltip;\nmod blink_manager;\nmod clangd_ext;\nmod code_context_menus;\npub mod display_map;\nmod editor_settings;\nmod editor_settings_controls;\nmod element;\nmod git;\nmod highlight_matching_bracket;\nmod hover_links;\nmod hover_popover;\nmod indent_guides;\nmod inlay_hint_cache;\npub mod items;\nmod linked_editing_ranges;\nmod lsp_ext;\nmod mouse_context_menu;\npub mod movement;\nmod persistence;\nmod proposed_changes_editor;\nmod rust_analyzer_ext;\npub mod scroll;\nmod selections_collection;\npub mod tasks;\n\n#[cfg(test)]\nmod editor_tests;\n#[cfg(test)]\nmod inline_completion_tests;\nmod signature_help;\n#[cfg(any(test, feature = \"test-support\"))]\npub mod test;\n\npub(crate) use actions::*;\npub use actions::{AcceptEditPrediction, OpenExcerpts, OpenExcerptsSplit};\nuse aho_corasick::AhoCorasick;\nuse anyhow::{anyhow, Context as _, Result};\nuse blink_manager::BlinkManager;\nuse client::{Collaborator, ParticipantIndex};\nuse clock::ReplicaId;\nuse collections::{BTreeMap, HashMap, HashSet, VecDeque};\nuse convert_case::{Case, Casing};\nuse display_map::*;\npub use display_map::{DisplayPoint, FoldPlaceholder};\npub use editor_settings::{\n    CurrentLineHighlight, EditorSettings, ScrollBeyondLastLine, SearchSettings, ShowScrollbar,\n};\npub use editor_settings_controls::*;\nuse element::{AcceptEditPredictionBinding, LineWithInvisibles, PositionMap};\npub use element::{\n    CursorLayout, EditorElement, HighlightedRange, HighlightedRangeLine, PointForPosition,\n};\nuse futures::{future, FutureExt};\nuse fuzzy::StringMatchCandidate;\n\nuse code_context_menus::{\n    AvailableCodeAction, CodeActionContents, CodeActionsItem, CodeActionsMenu, CodeContextMenu,\n    CompletionsMenu, ContextMenuOrigin,\n};\nuse git::blame::GitBlame;\nuse gpui::{\n    div, impl_actions, point, prelude::*, pulsating_between, px, relative, size, Action, Animation,\n    AnimationExt, AnyElement, App, AsyncWindowContext, AvailableSpace, Background, Bounds,\n    ClipboardEntry, ClipboardItem, Context, DispatchPhase, ElementId, Entity, EntityInputHandler,\n    EventEmitter, FocusHandle, FocusOutEvent, Focusable, FontId, FontWeight, Global,\n    HighlightStyle, Hsla, InteractiveText, KeyContext, Modifiers, MouseButton, MouseDownEvent,\n    PaintQuad, ParentElement, Pixels, Render, SharedString, Size, Styled, StyledText, Subscription,\n    Task, TextStyle, TextStyleRefinement, UTF16Selection, UnderlineStyle, UniformListScrollHandle,\n    WeakEntity, WeakFocusHandle, Window,\n};\nuse highlight_matching_bracket::refresh_matching_bracket_highlights;\nuse hover_popover::{hide_hover, HoverState};\nuse indent_guides::ActiveIndentGuidesState;\nuse inlay_hint_cache::{InlayHintCache, InlaySplice, InvalidationStrategy};\npub use inline_completion::Direction;\nuse inline_completion::{EditPredictionProvider, InlineCompletionProviderHandle};\npub use items::MAX_TAB_TITLE_LEN;\nuse itertools::Itertools;\nuse language::{\n    language_settings::{self, all_language_settings, language_settings, InlayHintSettings},\n    markdown, point_from_lsp, AutoindentMode, BracketPair, Buffer, Capability, CharKind, CodeLabel,\n    CompletionDocumentation, CursorShape, Diagnostic, EditPredictionsMode, EditPreview,\n    HighlightedText, IndentKind, IndentSize, Language, OffsetRangeExt, Point, Selection,\n    SelectionGoal, TextObject, TransactionId, TreeSitterOptions,\n};\nuse language::{point_to_lsp, BufferRow, CharClassifier, Runnable, RunnableRange};\nuse linked_editing_ranges::refresh_linked_ranges;\nuse mouse_context_menu::MouseContextMenu;\npub use proposed_changes_editor::{\n    ProposedChangeLocation, ProposedChangesEditor, ProposedChangesEditorToolbar,\n};\nuse similar::{ChangeTag, TextDiff};\nuse std::iter::Peekable;\nuse task::{ResolvedTask, TaskTemplate, TaskVariables};\n\nuse hover_links::{find_file, HoverLink, HoveredLinkState, InlayHighlight};\npub use lsp::CompletionContext;\nuse lsp::{\n    CompletionItemKind, CompletionTriggerKind, DiagnosticSeverity, InsertTextFormat,\n    LanguageServerId, LanguageServerName,\n};\n\nuse language::BufferSnapshot;\nuse movement::TextLayoutDetails;\npub use multi_buffer::{\n    Anchor, AnchorRangeExt, ExcerptId, ExcerptRange, MultiBuffer, MultiBufferSnapshot, RowInfo,\n    ToOffset, ToPoint,\n};\nuse multi_buffer::{\n    ExcerptInfo, ExpandExcerptDirection, MultiBufferDiffHunk, MultiBufferPoint, MultiBufferRow,\n    ToOffsetUtf16,\n};\nuse project::{\n    lsp_store::{FormatTrigger, LspFormatTarget, OpenLspBufferHandle},\n    project_settings::{GitGutterSetting, ProjectSettings},\n    CodeAction, Completion, CompletionIntent, DocumentHighlight, InlayHint, Location, LocationLink,\n    LspStore, PrepareRenameResponse, Project, ProjectItem, ProjectTransaction, TaskSourceKind,\n};\nuse rand::prelude::*;\nuse rpc::{proto::*, ErrorExt};\nuse scroll::{Autoscroll, OngoingScroll, ScrollAnchor, ScrollManager, ScrollbarAutoHide};\nuse selections_collection::{\n    resolve_selections, MutableSelectionsCollection, SelectionsCollection,\n};\nuse serde::{Deserialize, Serialize};\nuse settings::{update_settings_file, Settings, SettingsLocation, SettingsStore};\nuse smallvec::SmallVec;\nuse snippet::Snippet;\nuse std::{\n    any::TypeId,\n    borrow::Cow,\n    cell::RefCell,\n    cmp::{self, Ordering, Reverse},\n    mem,\n    num::NonZeroU32,\n    ops::{ControlFlow, Deref, DerefMut, Not as _, Range, RangeInclusive},\n    path::{Path, PathBuf},\n    rc::Rc,\n    sync::Arc,\n    time::{Duration, Instant},\n};\npub use sum_tree::Bias;\nuse sum_tree::TreeMap;\nuse text::{BufferId, OffsetUtf16, Rope};\nuse theme::{ActiveTheme, PlayerColor, StatusColors, SyntaxTheme, ThemeColors, ThemeSettings};\nuse ui::{\n    h_flex, prelude::*, ButtonSize, ButtonStyle, Disclosure, IconButton, IconName, IconSize,\n    Tooltip,\n};\nuse util::{defer, maybe, post_inc, RangeExt, ResultExt, TakeUntilExt, TryFutureExt};\nuse workspace::item::{ItemHandle, PreviewTabsSettings};\nuse workspace::notifications::{DetachAndPromptErr, NotificationId, NotifyTaskExt};\nuse workspace::{\n    searchable::SearchEvent, ItemNavHistory, SplitDirection, ViewId, Workspace, WorkspaceId,\n};\nuse workspace::{Item as WorkspaceItem, OpenInTerminal, OpenTerminal, TabBarSettings, Toast};\n\nuse crate::hover_links::{find_url, find_url_from_range};\nuse crate::signature_help::{SignatureHelpHiddenBy, SignatureHelpState};\n\npub const FILE_HEADER_HEIGHT: u32 = 2;\npub const MULTI_BUFFER_EXCERPT_HEADER_HEIGHT: u32 = 1;\npub const MULTI_BUFFER_EXCERPT_FOOTER_HEIGHT: u32 = 1;\npub const DEFAULT_MULTIBUFFER_CONTEXT: u32 = 2;\nconst CURSOR_BLINK_INTERVAL: Duration = Duration::from_millis(500);\nconst MAX_LINE_LEN: usize = 1024;\nconst MIN_NAVIGATION_HISTORY_ROW_DELTA: i64 = 10;\nconst MAX_SELECTION_HISTORY_LEN: usize = 1024;\npub(crate) const CURSORS_VISIBLE_FOR: Duration = Duration::from_millis(2000);\n#[doc(hidden)]\npub const CODE_ACTIONS_DEBOUNCE_TIMEOUT: Duration = Duration::from_millis(250);\n\npub(crate) const FORMAT_TIMEOUT: Duration = Duration::from_secs(2);\npub(crate) const SCROLL_CENTER_TOP_BOTTOM_DEBOUNCE_TIMEOUT: Duration = Duration::from_secs(1);\n\npub(crate) const EDIT_PREDICTION_KEY_CONTEXT: &str = \"edit_prediction\";\npub(crate) const EDIT_PREDICTION_REQUIRES_MODIFIER_KEY_CONTEXT: &str =\n    \"edit_prediction_requires_modifier\";\n\npub fn render_parsed_markdown(\n    element_id: impl Into<ElementId>,\n    parsed: &language::ParsedMarkdown,\n    editor_style: &EditorStyle,\n    workspace: Option<WeakEntity<Workspace>>,\n    cx: &mut App,\n) -> InteractiveText {\n    let code_span_background_color = cx\n        .theme()\n        .colors()\n        .editor_document_highlight_read_background;\n\n    let highlights = gpui::combine_highlights(\n        parsed.highlights.iter().filter_map(|(range, highlight)| {\n            let highlight = highlight.to_highlight_style(&editor_style.syntax)?;\n            Some((range.clone(), highlight))\n        }),\n        parsed\n            .regions\n            .iter()\n            .zip(&parsed.region_ranges)\n            .filter_map(|(region, range)| {\n                if region.code {\n                    Some((\n                        range.clone(),\n                        HighlightStyle {\n                            background_color: Some(code_span_background_color),\n                            ..Default::default()\n                        },\n                    ))\n                } else {\n                    None\n                }\n            }),\n    );\n\n    let mut links = Vec::new();\n    let mut link_ranges = Vec::new();\n    for (range, region) in parsed.region_ranges.iter().zip(&parsed.regions) {\n        if let Some(link) = region.link.clone() {\n            links.push(link);\n            link_ranges.push(range.clone());\n        }\n    }\n\n    InteractiveText::new(\n        element_id,\n        StyledText::new(parsed.text.clone()).with_highlights(&editor_style.text, highlights),\n    )\n    .on_click(\n        link_ranges,\n        move |clicked_range_ix, window, cx| match &links[clicked_range_ix] {\n            markdown::Link::Web { url } => cx.open_url(url),\n            markdown::Link::Path { path } => {\n                if let Some(workspace) = &workspace {\n                    _ = workspace.update(cx, |workspace, cx| {\n                        workspace\n                            .open_abs_path(path.clone(), false, window, cx)\n                            .detach();\n                    });\n                }\n            }\n        },\n    )\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum InlayId {\n    InlineCompletion(usize),\n    Hint(usize),\n}\n\nimpl InlayId {\n    fn id(&self) -> usize {\n        match self {\n            Self::InlineCompletion(id) => *id,\n            Self::Hint(id) => *id,\n        }\n    }\n}\n\nenum DocumentHighlightRead {}\nenum DocumentHighlightWrite {}\nenum InputComposition {}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Navigated {\n    Yes,\n    No,\n}\n\nimpl Navigated {\n    pub fn from_bool(yes: bool) -> Navigated {\n        if yes {\n            Navigated::Yes\n        } else {\n            Navigated::No\n        }\n    }\n}\n\npub fn init_settings(cx: &mut App) {\n    EditorSettings::register(cx);\n}\n\npub fn init(cx: &mut App) {\n    init_settings(cx);\n\n    workspace::register_project_item::<Editor>(cx);\n    workspace::FollowableViewRegistry::register::<Editor>(cx);\n    workspace::register_serializable_item::<Editor>(cx);\n\n    cx.observe_new(\n        |workspace: &mut Workspace, _: Option<&mut Window>, _cx: &mut Context<Workspace>| {\n            workspace.register_action(Editor::new_file);\n            workspace.register_action(Editor::new_file_vertical);\n            workspace.register_action(Editor::new_file_horizontal);\n            workspace.register_action(Editor::cancel_language_server_work);\n        },\n    )\n    .detach();\n\n    cx.on_action(move |_: &workspace::NewFile, cx| {\n        let app_state = workspace::AppState::global(cx);\n        if let Some(app_state) = app_state.upgrade() {\n            workspace::open_new(\n                Default::default(),\n                app_state,\n                cx,\n                |workspace, window, cx| {\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n            .detach();\n        }\n    });\n    cx.on_action(move |_: &workspace::NewWindow, cx| {\n        let app_state = workspace::AppState::global(cx);\n        if let Some(app_state) = app_state.upgrade() {\n            workspace::open_new(\n                Default::default(),\n                app_state,\n                cx,\n                |workspace, window, cx| {\n                    cx.activate(true);\n                    Editor::new_file(workspace, &Default::default(), window, cx)\n                },\n            )\n            .detach();\n        }\n    });\n}\n\npub struct SearchWithinRange;\n\ntrait InvalidationRegion {\n    fn ranges(&self) -> &[Range<Anchor>];\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SelectPhase {\n    Begin {\n        position: DisplayPoint,\n        add: bool,\n        click_count: usize,\n    },\n    BeginColumnar {\n        position: DisplayPoint,\n        reset: bool,\n        goal_column: u32,\n    },\n    Extend {\n        position: DisplayPoint,\n        click_count: usize,\n    },\n    Update {\n        position: DisplayPoint,\n        goal_column: u32,\n        scroll_delta: gpui::Point<f32>,\n    },\n    End,\n}\n\n#[derive(Clone, Debug)]\npub enum SelectMode {\n    Character,\n    Word(Range<Anchor>),\n    Line(Range<Anchor>),\n    All,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub enum EditorMode {\n    SingleLine { auto_width: bool },\n    AutoHeight { max_lines: usize },\n    Full,\n}\n\n#[derive(Copy, Clone, Debug)]\npub enum SoftWrap {\n    /// Prefer not to wrap at all.\n    ///\n    /// Note: this is currently internal, as actually limited by [`crate::MAX_LINE_LEN`] until it wraps.\n    /// The mode is used inside git diff hunks, where it's seems currently more useful to not wrap as much as possible.\n    GitDiff,\n    /// Prefer a single line generally, unless an overly long line is encountered.\n    None,\n    /// Soft wrap lines that exceed the editor width.\n    EditorWidth,\n    /// Soft wrap lines at the preferred line length.\n    Column(u32),\n    /// Soft wrap line at the preferred line length or the editor width (whichever is smaller).\n    Bounded(u32),\n}\n\n#[derive(Clone)]\npub struct EditorStyle {\n    pub background: Hsla,\n    pub local_player: PlayerColor,\n    pub text: TextStyle,\n    pub scrollbar_width: Pixels,\n    pub syntax: Arc<SyntaxTheme>,\n    pub status: StatusColors,\n    pub inlay_hints_style: HighlightStyle,\n    pub inline_completion_styles: InlineCompletionStyles,\n    pub unnecessary_code_fade: f32,\n}\n\nimpl Default for EditorStyle {\n    fn default() -> Self {\n        Self {\n            background: Hsla::default(),\n            local_player: PlayerColor::default(),\n            text: TextStyle::default(),\n            scrollbar_width: Pixels::default(),\n            syntax: Default::default(),\n            // HACK: Status colors don't have a real default.\n            // We should look into removing the status colors from the editor\n            // style and retrieve them directly from the theme.\n            status: StatusColors::dark(),\n            inlay_hints_style: HighlightStyle::default(),\n            inline_completion_styles: InlineCompletionStyles {\n                insertion: HighlightStyle::default(),\n                whitespace: HighlightStyle::default(),\n            },\n            unnecessary_code_fade: Default::default(),\n        }\n    }\n}\n\npub fn make_inlay_hints_style(cx: &mut App) -> HighlightStyle {\n    let show_background = language_settings::language_settings(None, None, cx)\n        .inlay_hints\n        .show_background;\n\n    HighlightStyle {\n        color: Some(cx.theme().status().hint),\n        background_color: show_background.then(|| cx.theme().status().hint_background),\n        ..HighlightStyle::default()\n    }\n}\n\npub fn make_suggestion_styles(cx: &mut App) -> InlineCompletionStyles {\n    InlineCompletionStyles {\n        insertion: HighlightStyle {\n            color: Some(cx.theme().status().predictive),\n            ..HighlightStyle::default()\n        },\n        whitespace: HighlightStyle {\n            background_color: Some(cx.theme().status().created_background),\n            ..HighlightStyle::default()\n        },\n    }\n}\n\ntype CompletionId = usize;\n\npub(crate) enum EditDisplayMode {\n    TabAccept,\n    DiffPopover,\n    Inline,\n}\n\nenum InlineCompletion {\n    Edit {\n        edits: Vec<(Range<Anchor>, String)>,\n        edit_preview: Option<EditPreview>,\n        display_mode: EditDisplayMode,\n        snapshot: BufferSnapshot,\n    },\n    Move {\n        target: Anchor,\n        snapshot: BufferSnapshot,\n    },\n}\n\nstruct InlineCompletionState {\n    inlay_ids: Vec<InlayId>,\n    completion: InlineCompletion,\n    completion_id: Option<SharedString>,\n    invalidation_range: Range<Anchor>,\n}\n\nenum EditPredictionSettings {\n    Disabled,\n    Enabled {\n        show_in_menu: bool,\n        preview_requires_modifier: bool,\n    },\n}\n\nimpl EditPredictionSettings {\n    pub fn is_enabled(&self) -> bool {\n        match self {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled { .. } => true,\n        }\n    }\n}\n\nenum InlineCompletionHighlight {}\n\npub enum MenuInlineCompletionsPolicy {\n    Never,\n    ByProvider,\n}\n\npub enum EditPredictionPreview {\n    /// Modifier is not pressed\n    Inactive,\n    /// Modifier pressed\n    Active {\n        previous_scroll_position: Option<ScrollAnchor>,\n    },\n}\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Debug, Default)]\nstruct EditorActionId(usize);\n\nimpl EditorActionId {\n    pub fn post_inc(&mut self) -> Self {\n        let answer = self.0;\n\n        *self = Self(answer + 1);\n\n        Self(answer)\n    }\n}\n\n// type GetFieldEditorTheme = dyn Fn(&theme::Theme) -> theme::FieldEditor;\n// type OverrideTextStyle = dyn Fn(&EditorStyle) -> Option<HighlightStyle>;\n\ntype BackgroundHighlight = (fn(&ThemeColors) -> Hsla, Arc<[Range<Anchor>]>);\ntype GutterHighlight = (fn(&App) -> Hsla, Arc<[Range<Anchor>]>);\n\n#[derive(Default)]\nstruct ScrollbarMarkerState {\n    scrollbar_size: Size<Pixels>,\n    dirty: bool,\n    markers: Arc<[PaintQuad]>,\n    pending_refresh: Option<Task<Result<()>>>,\n}\n\nimpl ScrollbarMarkerState {\n    fn should_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n        self.pending_refresh.is_none() && (self.scrollbar_size != scrollbar_size || self.dirty)\n    }\n}\n\n#[derive(Clone, Debug)]\nstruct RunnableTasks {\n    templates: Vec<(TaskSourceKind, TaskTemplate)>,\n    offset: MultiBufferOffset,\n    // We need the column at which the task context evaluation should take place (when we're spawning it via gutter).\n    column: u32,\n    // Values of all named captures, including those starting with '_'\n    extra_variables: HashMap<String, String>,\n    // Full range of the tagged region. We use it to determine which `extra_variables` to grab for context resolution in e.g. a modal.\n    context_range: Range<BufferOffset>,\n}\n\nimpl RunnableTasks {\n    fn resolve<'a>(\n        &'a self,\n        cx: &'a task::TaskContext,\n    ) -> impl Iterator<Item = (TaskSourceKind, ResolvedTask)> + 'a {\n        self.templates.iter().filter_map(|(kind, template)| {\n            template\n                .resolve_task(&kind.to_id_base(), cx)\n                .map(|task| (kind.clone(), task))\n        })\n    }\n}\n\n#[derive(Clone)]\nstruct ResolvedTasks {\n    templates: SmallVec<[(TaskSourceKind, ResolvedTask); 1]>,\n    position: Anchor,\n}\n#[derive(Copy, Clone, Debug)]\nstruct MultiBufferOffset(usize);\n#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\nstruct BufferOffset(usize);\n\n// Addons allow storing per-editor state in other crates (e.g. Vim)\npub trait Addon: 'static {\n    fn extend_key_context(&self, _: &mut KeyContext, _: &App) {}\n\n    fn render_buffer_header_controls(\n        &self,\n        _: &ExcerptInfo,\n        _: &Window,\n        _: &App,\n    ) -> Option<AnyElement> {\n        None\n    }\n\n    fn to_any(&self) -> &dyn std::any::Any;\n}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum IsVimMode {\n    Yes,\n    No,\n}\n\n/// Zed's primary implementation of text input, allowing users to edit a [`MultiBuffer`].\n///\n/// See the [module level documentation](self) for more information.\npub struct Editor {\n    focus_handle: FocusHandle,\n    last_focused_descendant: Option<WeakFocusHandle>,\n    /// The text buffer being edited\n    buffer: Entity<MultiBuffer>,\n    /// Map of how text in the buffer should be displayed.\n    /// Handles soft wraps, folds, fake inlay text insertions, etc.\n    pub display_map: Entity<DisplayMap>,\n    pub selections: SelectionsCollection,\n    pub scroll_manager: ScrollManager,\n    /// When inline assist editors are linked, they all render cursors because\n    /// typing enters text into each of them, even the ones that aren't focused.\n    pub(crate) show_cursor_when_unfocused: bool,\n    columnar_selection_tail: Option<Anchor>,\n    add_selections_state: Option<AddSelectionsState>,\n    select_next_state: Option<SelectNextState>,\n    select_prev_state: Option<SelectNextState>,\n    selection_history: SelectionHistory,\n    autoclose_regions: Vec<AutocloseRegion>,\n    snippet_stack: InvalidationStack<SnippetState>,\n    select_larger_syntax_node_stack: Vec<Box<[Selection<usize>]>>,\n    ime_transaction: Option<TransactionId>,\n    active_diagnostics: Option<ActiveDiagnosticGroup>,\n    soft_wrap_mode_override: Option<language_settings::SoftWrap>,\n\n    // TODO: make this a access method\n    pub project: Option<Entity<Project>>,\n    semantics_provider: Option<Rc<dyn SemanticsProvider>>,\n    completion_provider: Option<Box<dyn CompletionProvider>>,\n    collaboration_hub: Option<Box<dyn CollaborationHub>>,\n    blink_manager: Entity<BlinkManager>,\n    show_cursor_names: bool,\n    hovered_cursors: HashMap<HoveredCursor, Task<()>>,\n    pub show_local_selections: bool,\n    mode: EditorMode,\n    show_breadcrumbs: bool,\n    show_gutter: bool,\n    show_scrollbars: bool,\n    show_line_numbers: Option<bool>,\n    use_relative_line_numbers: Option<bool>,\n    show_git_diff_gutter: Option<bool>,\n    show_code_actions: Option<bool>,\n    show_runnables: Option<bool>,\n    show_wrap_guides: Option<bool>,\n    show_indent_guides: Option<bool>,\n    placeholder_text: Option<Arc<str>>,\n    highlight_order: usize,\n    highlighted_rows: HashMap<TypeId, Vec<RowHighlight>>,\n    background_highlights: TreeMap<TypeId, BackgroundHighlight>,\n    gutter_highlights: TreeMap<TypeId, GutterHighlight>,\n    scrollbar_marker_state: ScrollbarMarkerState,\n    active_indent_guides_state: ActiveIndentGuidesState,\n    nav_history: Option<ItemNavHistory>,\n    context_menu: RefCell<Option<CodeContextMenu>>,\n    mouse_context_menu: Option<MouseContextMenu>,\n    completion_tasks: Vec<(CompletionId, Task<Option<()>>)>,\n    signature_help_state: SignatureHelpState,\n    auto_signature_help: Option<bool>,\n    find_all_references_task_sources: Vec<Anchor>,\n    next_completion_id: CompletionId,\n    available_code_actions: Option<(Location, Rc<[AvailableCodeAction]>)>,\n    code_actions_task: Option<Task<Result<()>>>,\n    document_highlights_task: Option<Task<()>>,\n    linked_editing_range_task: Option<Task<Option<()>>>,\n    linked_edit_ranges: linked_editing_ranges::LinkedEditingRanges,\n    pending_rename: Option<RenameState>,\n    searchable: bool,\n    cursor_shape: CursorShape,\n    current_line_highlight: Option<CurrentLineHighlight>,\n    collapse_matches: bool,\n    autoindent_mode: Option<AutoindentMode>,\n    workspace: Option<(WeakEntity<Workspace>, Option<WorkspaceId>)>,\n    input_enabled: bool,\n    use_modal_editing: bool,\n    read_only: bool,\n    leader_peer_id: Option<PeerId>,\n    remote_id: Option<ViewId>,\n    hover_state: HoverState,\n    pending_mouse_down: Option<Rc<RefCell<Option<MouseDownEvent>>>>,\n    gutter_hovered: bool,\n    hovered_link_state: Option<HoveredLinkState>,\n    edit_prediction_provider: Option<RegisteredInlineCompletionProvider>,\n    code_action_providers: Vec<Rc<dyn CodeActionProvider>>,\n    active_inline_completion: Option<InlineCompletionState>,\n    /// Used to prevent flickering as the user types while the menu is open\n    stale_inline_completion_in_menu: Option<InlineCompletionState>,\n    edit_prediction_settings: EditPredictionSettings,\n    edit_prediction_cursor_on_leading_whitespace: bool,\n    inline_completions_hidden_for_vim_mode: bool,\n    show_inline_completions_override: Option<bool>,\n    menu_inline_completions_policy: MenuInlineCompletionsPolicy,\n    edit_prediction_preview: EditPredictionPreview,\n    inlay_hint_cache: InlayHintCache,\n    next_inlay_id: usize,\n    _subscriptions: Vec<Subscription>,\n    pixel_position_of_newest_cursor: Option<gpui::Point<Pixels>>,\n    gutter_dimensions: GutterDimensions,\n    style: Option<EditorStyle>,\n    text_style_refinement: Option<TextStyleRefinement>,\n    next_editor_action_id: EditorActionId,\n    editor_actions:\n        Rc<RefCell<BTreeMap<EditorActionId, Box<dyn Fn(&mut Window, &mut Context<Self>)>>>>,\n    use_autoclose: bool,\n    use_auto_surround: bool,\n    auto_replace_emoji_shortcode: bool,\n    show_git_blame_gutter: bool,\n    show_git_blame_inline: bool,\n    show_git_blame_inline_delay_task: Option<Task<()>>,\n    distinguish_unstaged_diff_hunks: bool,\n    git_blame_inline_enabled: bool,\n    serialize_dirty_buffers: bool,\n    show_selection_menu: Option<bool>,\n    blame: Option<Entity<GitBlame>>,\n    blame_subscription: Option<Subscription>,\n    custom_context_menu: Option<\n        Box<\n            dyn 'static\n                + Fn(\n                    &mut Self,\n                    DisplayPoint,\n                    &mut Window,\n                    &mut Context<Self>,\n                ) -> Option<Entity<ui::ContextMenu>>,\n        >,\n    >,\n    last_bounds: Option<Bounds<Pixels>>,\n    last_position_map: Option<Rc<PositionMap>>,\n    expect_bounds_change: Option<Bounds<Pixels>>,\n    tasks: BTreeMap<(BufferId, BufferRow), RunnableTasks>,\n    tasks_update_task: Option<Task<()>>,\n    in_project_search: bool,\n    previous_search_ranges: Option<Arc<[Range<Anchor>]>>,\n    breadcrumb_header: Option<String>,\n    focused_block: Option<FocusedBlock>,\n    next_scroll_position: NextScrollCursorCenterTopBottom,\n    addons: HashMap<TypeId, Box<dyn Addon>>,\n    registered_buffers: HashMap<BufferId, OpenLspBufferHandle>,\n    selection_mark_mode: bool,\n    toggle_fold_multiple_buffers: Task<()>,\n    _scroll_cursor_center_top_bottom_task: Task<()>,\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]\nenum NextScrollCursorCenterTopBottom {\n    #[default]\n    Center,\n    Top,\n    Bottom,\n}\n\nimpl NextScrollCursorCenterTopBottom {\n    fn next(&self) -> Self {\n        match self {\n            Self::Center => Self::Top,\n            Self::Top => Self::Bottom,\n            Self::Bottom => Self::Center,\n        }\n    }\n}\n\n#[derive(Clone)]\npub struct EditorSnapshot {\n    pub mode: EditorMode,\n    show_gutter: bool,\n    show_line_numbers: Option<bool>,\n    show_git_diff_gutter: Option<bool>,\n    show_code_actions: Option<bool>,\n    show_runnables: Option<bool>,\n    git_blame_gutter_max_author_length: Option<usize>,\n    pub display_snapshot: DisplaySnapshot,\n    pub placeholder_text: Option<Arc<str>>,\n    is_focused: bool,\n    scroll_anchor: ScrollAnchor,\n    ongoing_scroll: OngoingScroll,\n    current_line_highlight: CurrentLineHighlight,\n    gutter_hovered: bool,\n}\n\nconst GIT_BLAME_MAX_AUTHOR_CHARS_DISPLAYED: usize = 20;\n\n#[derive(Default, Debug, Clone, Copy)]\npub struct GutterDimensions {\n    pub left_padding: Pixels,\n    pub right_padding: Pixels,\n    pub width: Pixels,\n    pub margin: Pixels,\n    pub git_blame_entries_width: Option<Pixels>,\n}\n\nimpl GutterDimensions {\n    /// The full width of the space taken up by the gutter.\n    pub fn full_width(&self) -> Pixels {\n        self.margin + self.width\n    }\n\n    /// The width of the space reserved for the fold indicators,\n    /// use alongside 'justify_end' and `gutter_width` to\n    /// right align content with the line numbers\n    pub fn fold_area_width(&self) -> Pixels {\n        self.margin + self.right_padding\n    }\n}\n\n#[derive(Debug)]\npub struct RemoteSelection {\n    pub replica_id: ReplicaId,\n    pub selection: Selection<Anchor>,\n    pub cursor_shape: CursorShape,\n    pub peer_id: PeerId,\n    pub line_mode: bool,\n    pub participant_index: Option<ParticipantIndex>,\n    pub user_name: Option<SharedString>,\n}\n\n#[derive(Clone, Debug)]\nstruct SelectionHistoryEntry {\n    selections: Arc<[Selection<Anchor>]>,\n    select_next_state: Option<SelectNextState>,\n    select_prev_state: Option<SelectNextState>,\n    add_selections_state: Option<AddSelectionsState>,\n}\n\nenum SelectionHistoryMode {\n    Normal,\n    Undoing,\n    Redoing,\n}\n\n#[derive(Clone, PartialEq, Eq, Hash)]\nstruct HoveredCursor {\n    replica_id: u16,\n    selection_id: usize,\n}\n\nimpl Default for SelectionHistoryMode {\n    fn default() -> Self {\n        Self::Normal\n    }\n}\n\n#[derive(Default)]\nstruct SelectionHistory {\n    #[allow(clippy::type_complexity)]\n    selections_by_transaction:\n        HashMap<TransactionId, (Arc<[Selection<Anchor>]>, Option<Arc<[Selection<Anchor>]>>)>,\n    mode: SelectionHistoryMode,\n    undo_stack: VecDeque<SelectionHistoryEntry>,\n    redo_stack: VecDeque<SelectionHistoryEntry>,\n}\n\nimpl SelectionHistory {\n    fn insert_transaction(\n        &mut self,\n        transaction_id: TransactionId,\n        selections: Arc<[Selection<Anchor>]>,\n    ) {\n        self.selections_by_transaction\n            .insert(transaction_id, (selections, None));\n    }\n\n    #[allow(clippy::type_complexity)]\n    fn transaction(\n        &self,\n        transaction_id: TransactionId,\n    ) -> Option<&(Arc<[Selection<Anchor>]>, Option<Arc<[Selection<Anchor>]>>)> {\n        self.selections_by_transaction.get(&transaction_id)\n    }\n\n    #[allow(clippy::type_complexity)]\n    fn transaction_mut(\n        &mut self,\n        transaction_id: TransactionId,\n    ) -> Option<&mut (Arc<[Selection<Anchor>]>, Option<Arc<[Selection<Anchor>]>>)> {\n        self.selections_by_transaction.get_mut(&transaction_id)\n    }\n\n    fn push(&mut self, entry: SelectionHistoryEntry) {\n        if !entry.selections.is_empty() {\n            match self.mode {\n                SelectionHistoryMode::Normal => {\n                    self.push_undo(entry);\n                    self.redo_stack.clear();\n                }\n                SelectionHistoryMode::Undoing => self.push_redo(entry),\n                SelectionHistoryMode::Redoing => self.push_undo(entry),\n            }\n        }\n    }\n\n    fn push_undo(&mut self, entry: SelectionHistoryEntry) {\n        if self\n            .undo_stack\n            .back()\n            .map_or(true, |e| e.selections != entry.selections)\n        {\n            self.undo_stack.push_back(entry);\n            if self.undo_stack.len() > MAX_SELECTION_HISTORY_LEN {\n                self.undo_stack.pop_front();\n            }\n        }\n    }\n\n    fn push_redo(&mut self, entry: SelectionHistoryEntry) {\n        if self\n            .redo_stack\n            .back()\n            .map_or(true, |e| e.selections != entry.selections)\n        {\n            self.redo_stack.push_back(entry);\n            if self.redo_stack.len() > MAX_SELECTION_HISTORY_LEN {\n                self.redo_stack.pop_front();\n            }\n        }\n    }\n}\n\nstruct RowHighlight {\n    index: usize,\n    range: Range<Anchor>,\n    color: Hsla,\n    should_autoscroll: bool,\n}\n\n#[derive(Clone, Debug)]\nstruct AddSelectionsState {\n    above: bool,\n    stack: Vec<usize>,\n}\n\n#[derive(Clone)]\nstruct SelectNextState {\n    query: AhoCorasick,\n    wordwise: bool,\n    done: bool,\n}\n\nimpl std::fmt::Debug for SelectNextState {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(std::any::type_name::<Self>())\n            .field(\"wordwise\", &self.wordwise)\n            .field(\"done\", &self.done)\n            .finish()\n    }\n}\n\n#[derive(Debug)]\nstruct AutocloseRegion {\n    selection_id: usize,\n    range: Range<Anchor>,\n    pair: BracketPair,\n}\n\n#[derive(Debug)]\nstruct SnippetState {\n    ranges: Vec<Vec<Range<Anchor>>>,\n    active_index: usize,\n    choices: Vec<Option<Vec<String>>>,\n}\n\n#[doc(hidden)]\npub struct RenameState {\n    pub range: Range<Anchor>,\n    pub old_name: Arc<str>,\n    pub editor: Entity<Editor>,\n    block_id: CustomBlockId,\n}\n\nstruct InvalidationStack<T>(Vec<T>);\n\nstruct RegisteredInlineCompletionProvider {\n    provider: Arc<dyn InlineCompletionProviderHandle>,\n    _subscription: Subscription,\n}\n\n#[derive(Debug)]\nstruct ActiveDiagnosticGroup {\n    primary_range: Range<Anchor>,\n    primary_message: String,\n    group_id: usize,\n    blocks: HashMap<CustomBlockId, Diagnostic>,\n    is_valid: bool,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug)]\npub struct ClipboardSelection {\n    pub len: usize,\n    pub is_entire_line: bool,\n    pub first_line_indent: u32,\n}\n\n#[derive(Debug)]\npub(crate) struct NavigationData {\n    cursor_anchor: Anchor,\n    cursor_position: Point,\n    scroll_anchor: ScrollAnchor,\n    scroll_top_row: u32,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum GotoDefinitionKind {\n    Symbol,\n    Declaration,\n    Type,\n    Implementation,\n}\n\n#[derive(Debug, Clone)]\nenum InlayHintRefreshReason {\n    Toggle(bool),\n    SettingsChange(InlayHintSettings),\n    NewLinesShown,\n    BufferEdited(HashSet<Arc<Language>>),\n    RefreshRequested,\n    ExcerptsRemoved(Vec<ExcerptId>),\n}\n\nimpl InlayHintRefreshReason {\n    fn description(&self) -> &'static str {\n        match self {\n            Self::Toggle(_) => \"toggle\",\n            Self::SettingsChange(_) => \"settings change\",\n            Self::NewLinesShown => \"new lines shown\",\n            Self::BufferEdited(_) => \"buffer edited\",\n            Self::RefreshRequested => \"refresh requested\",\n            Self::ExcerptsRemoved(_) => \"excerpts removed\",\n        }\n    }\n}\n\npub enum FormatTarget {\n    Buffers,\n    Ranges(Vec<Range<MultiBufferPoint>>),\n}\n\npub(crate) struct FocusedBlock {\n    id: BlockId,\n    focus_handle: WeakFocusHandle,\n}\n\n#[derive(Clone)]\nenum JumpData {\n    MultiBufferRow {\n        row: MultiBufferRow,\n        line_offset_from_top: u32,\n    },\n    MultiBufferPoint {\n        excerpt_id: ExcerptId,\n        position: Point,\n        anchor: text::Anchor,\n        line_offset_from_top: u32,\n    },\n}\n\npub enum MultibufferSelectionMode {\n    First,\n    All,\n}\n\nimpl Editor {\n    pub fn single_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n        let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n        let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n        Self::new(\n            EditorMode::SingleLine { auto_width: false },\n            buffer,\n            None,\n            false,\n            window,\n            cx,\n        )\n    }\n\n    pub fn multi_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n        let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n        let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n        Self::new(EditorMode::Full, buffer, None, false, window, cx)\n    }\n\n    pub fn auto_width(window: &mut Window, cx: &mut Context<Self>) -> Self {\n        let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n        let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n        Self::new(\n            EditorMode::SingleLine { auto_width: true },\n            buffer,\n            None,\n            false,\n            window,\n            cx,\n        )\n    }\n\n    pub fn auto_height(max_lines: usize, window: &mut Window, cx: &mut Context<Self>) -> Self {\n        let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n        let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n        Self::new(\n            EditorMode::AutoHeight { max_lines },\n            buffer,\n            None,\n            false,\n            window,\n            cx,\n        )\n    }\n\n    pub fn for_buffer(\n        buffer: Entity<Buffer>,\n        project: Option<Entity<Project>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n        Self::new(EditorMode::Full, buffer, project, false, window, cx)\n    }\n\n    pub fn for_multibuffer(\n        buffer: Entity<MultiBuffer>,\n        project: Option<Entity<Project>>,\n        show_excerpt_controls: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        Self::new(\n            EditorMode::Full,\n            buffer,\n            project,\n            show_excerpt_controls,\n            window,\n            cx,\n        )\n    }\n\n    pub fn clone(&self, window: &mut Window, cx: &mut Context<Self>) -> Self {\n        let show_excerpt_controls = self.display_map.read(cx).show_excerpt_controls();\n        let mut clone = Self::new(\n            self.mode,\n            self.buffer.clone(),\n            self.project.clone(),\n            show_excerpt_controls,\n            window,\n            cx,\n        );\n        self.display_map.update(cx, |display_map, cx| {\n            let snapshot = display_map.snapshot(cx);\n            clone.display_map.update(cx, |display_map, cx| {\n                display_map.set_state(&snapshot, cx);\n            });\n        });\n        clone.selections.clone_state(&self.selections);\n        clone.scroll_manager.clone_state(&self.scroll_manager);\n        clone.searchable = self.searchable;\n        clone\n    }\n\n    pub fn new(\n        mode: EditorMode,\n        buffer: Entity<MultiBuffer>,\n        project: Option<Entity<Project>>,\n        show_excerpt_controls: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Self {\n        let style = window.text_style();\n        let font_size = style.font_size.to_pixels(window.rem_size());\n        let editor = cx.entity().downgrade();\n        let fold_placeholder = FoldPlaceholder {\n            constrain_width: true,\n            render: Arc::new(move |fold_id, fold_range, _, cx| {\n                let editor = editor.clone();\n                div()\n                    .id(fold_id)\n                    .bg(cx.theme().colors().ghost_element_background)\n                    .hover(|style| style.bg(cx.theme().colors().ghost_element_hover))\n                    .active(|style| style.bg(cx.theme().colors().ghost_element_active))\n                    .rounded_sm()\n                    .size_full()\n                    .cursor_pointer()\n                    .child(\"⋯\")\n                    .on_mouse_down(MouseButton::Left, |_, _, cx| cx.stop_propagation())\n                    .on_click(move |_, _window, cx| {\n                        editor\n                            .update(cx, |editor, cx| {\n                                editor.unfold_ranges(\n                                    &[fold_range.start..fold_range.end],\n                                    true,\n                                    false,\n                                    cx,\n                                );\n                                cx.stop_propagation();\n                            })\n                            .ok();\n                    })\n                    .into_any()\n            }),\n            merge_adjacent: true,\n            ..Default::default()\n        };\n        let display_map = cx.new(|cx| {\n            DisplayMap::new(\n                buffer.clone(),\n                style.font(),\n                font_size,\n                None,\n                show_excerpt_controls,\n                FILE_HEADER_HEIGHT,\n                MULTI_BUFFER_EXCERPT_HEADER_HEIGHT,\n                MULTI_BUFFER_EXCERPT_FOOTER_HEIGHT,\n                fold_placeholder,\n                cx,\n            )\n        });\n\n        let selections = SelectionsCollection::new(display_map.clone(), buffer.clone());\n\n        let blink_manager = cx.new(|cx| BlinkManager::new(CURSOR_BLINK_INTERVAL, cx));\n\n        let soft_wrap_mode_override = matches!(mode, EditorMode::SingleLine { .. })\n            .then(|| language_settings::SoftWrap::None);\n\n        let mut project_subscriptions = Vec::new();\n        if mode == EditorMode::Full {\n            if let Some(project) = project.as_ref() {\n                if buffer.read(cx).is_singleton() {\n                    project_subscriptions.push(cx.observe_in(project, window, |_, _, _, cx| {\n                        cx.emit(EditorEvent::TitleChanged);\n                    }));\n                }\n                project_subscriptions.push(cx.subscribe_in(\n                    project,\n                    window,\n                    |editor, _, event, window, cx| {\n                        if let project::Event::RefreshInlayHints = event {\n                            editor\n                                .refresh_inlay_hints(InlayHintRefreshReason::RefreshRequested, cx);\n                        } else if let project::Event::SnippetEdit(id, snippet_edits) = event {\n                            if let Some(buffer) = editor.buffer.read(cx).buffer(*id) {\n                                let focus_handle = editor.focus_handle(cx);\n                                if focus_handle.is_focused(window) {\n                                    let snapshot = buffer.read(cx).snapshot();\n                                    for (range, snippet) in snippet_edits {\n                                        let editor_range =\n                                            language::range_from_lsp(*range).to_offset(&snapshot);\n                                        editor\n                                            .insert_snippet(\n                                                &[editor_range],\n                                                snippet.clone(),\n                                                window,\n                                                cx,\n                                            )\n                                            .ok();\n                                    }\n                                }\n                            }\n                        }\n                    },\n                ));\n                if let Some(task_inventory) = project\n                    .read(cx)\n                    .task_store()\n                    .read(cx)\n                    .task_inventory()\n                    .cloned()\n                {\n                    project_subscriptions.push(cx.observe_in(\n                        &task_inventory,\n                        window,\n                        |editor, _, window, cx| {\n                            editor.tasks_update_task = Some(editor.refresh_runnables(window, cx));\n                        },\n                    ));\n                }\n            }\n        }\n\n        let buffer_snapshot = buffer.read(cx).snapshot(cx);\n\n        let inlay_hint_settings =\n            inlay_hint_settings(selections.newest_anchor().head(), &buffer_snapshot, cx);\n        let focus_handle = cx.focus_handle();\n        cx.on_focus(&focus_handle, window, Self::handle_focus)\n            .detach();\n        cx.on_focus_in(&focus_handle, window, Self::handle_focus_in)\n            .detach();\n        cx.on_focus_out(&focus_handle, window, Self::handle_focus_out)\n            .detach();\n        cx.on_blur(&focus_handle, window, Self::handle_blur)\n            .detach();\n\n        let show_indent_guides = if matches!(mode, EditorMode::SingleLine { .. }) {\n            Some(false)\n        } else {\n            None\n        };\n\n        let mut code_action_providers = Vec::new();\n        if let Some(project) = project.clone() {\n            get_uncommitted_diff_for_buffer(\n                &project,\n                buffer.read(cx).all_buffers(),\n                buffer.clone(),\n                cx,\n            );\n            code_action_providers.push(Rc::new(project) as Rc<_>);\n        }\n\n        let mut this = Self {\n            focus_handle,\n            show_cursor_when_unfocused: false,\n            last_focused_descendant: None,\n            buffer: buffer.clone(),\n            display_map: display_map.clone(),\n            selections,\n            scroll_manager: ScrollManager::new(cx),\n            columnar_selection_tail: None,\n            add_selections_state: None,\n            select_next_state: None,\n            select_prev_state: None,\n            selection_history: Default::default(),\n            autoclose_regions: Default::default(),\n            snippet_stack: Default::default(),\n            select_larger_syntax_node_stack: Vec::new(),\n            ime_transaction: Default::default(),\n            active_diagnostics: None,\n            soft_wrap_mode_override,\n            completion_provider: project.clone().map(|project| Box::new(project) as _),\n            semantics_provider: project.clone().map(|project| Rc::new(project) as _),\n            collaboration_hub: project.clone().map(|project| Box::new(project) as _),\n            project,\n            blink_manager: blink_manager.clone(),\n            show_local_selections: true,\n            show_scrollbars: true,\n            mode,\n            show_breadcrumbs: EditorSettings::get_global(cx).toolbar.breadcrumbs,\n            show_gutter: mode == EditorMode::Full,\n            show_line_numbers: None,\n            use_relative_line_numbers: None,\n            show_git_diff_gutter: None,\n            show_code_actions: None,\n            show_runnables: None,\n            show_wrap_guides: None,\n            show_indent_guides,\n            placeholder_text: None,\n            highlight_order: 0,\n            highlighted_rows: HashMap::default(),\n            background_highlights: Default::default(),\n            gutter_highlights: TreeMap::default(),\n            scrollbar_marker_state: ScrollbarMarkerState::default(),\n            active_indent_guides_state: ActiveIndentGuidesState::default(),\n            nav_history: None,\n            context_menu: RefCell::new(None),\n            mouse_context_menu: None,\n            completion_tasks: Default::default(),\n            signature_help_state: SignatureHelpState::default(),\n            auto_signature_help: None,\n            find_all_references_task_sources: Vec::new(),\n            next_completion_id: 0,\n            next_inlay_id: 0,\n            code_action_providers,\n            available_code_actions: Default::default(),\n            code_actions_task: Default::default(),\n            document_highlights_task: Default::default(),\n            linked_editing_range_task: Default::default(),\n            pending_rename: Default::default(),\n            searchable: true,\n            cursor_shape: EditorSettings::get_global(cx)\n                .cursor_shape\n                .unwrap_or_default(),\n            current_line_highlight: None,\n            autoindent_mode: Some(AutoindentMode::EachLine),\n            collapse_matches: false,\n            workspace: None,\n            input_enabled: true,\n            use_modal_editing: mode == EditorMode::Full,\n            read_only: false,\n            use_autoclose: true,\n            use_auto_surround: true,\n            auto_replace_emoji_shortcode: false,\n            leader_peer_id: None,\n            remote_id: None,\n            hover_state: Default::default(),\n            pending_mouse_down: None,\n            hovered_link_state: Default::default(),\n            edit_prediction_provider: None,\n            active_inline_completion: None,\n            stale_inline_completion_in_menu: None,\n            edit_prediction_preview: EditPredictionPreview::Inactive,\n            inlay_hint_cache: InlayHintCache::new(inlay_hint_settings),\n\n            gutter_hovered: false,\n            pixel_position_of_newest_cursor: None,\n            last_bounds: None,\n            last_position_map: None,\n            expect_bounds_change: None,\n            gutter_dimensions: GutterDimensions::default(),\n            style: None,\n            show_cursor_names: false,\n            hovered_cursors: Default::default(),\n            next_editor_action_id: EditorActionId::default(),\n            editor_actions: Rc::default(),\n            inline_completions_hidden_for_vim_mode: false,\n            show_inline_completions_override: None,\n            menu_inline_completions_policy: MenuInlineCompletionsPolicy::ByProvider,\n            edit_prediction_settings: EditPredictionSettings::Disabled,\n            edit_prediction_cursor_on_leading_whitespace: false,\n            custom_context_menu: None,\n            show_git_blame_gutter: false,\n            show_git_blame_inline: false,\n            distinguish_unstaged_diff_hunks: false,\n            show_selection_menu: None,\n            show_git_blame_inline_delay_task: None,\n            git_blame_inline_enabled: ProjectSettings::get_global(cx).git.inline_blame_enabled(),\n            serialize_dirty_buffers: ProjectSettings::get_global(cx)\n                .session\n                .restore_unsaved_buffers,\n            blame: None,\n            blame_subscription: None,\n            tasks: Default::default(),\n            _subscriptions: vec![\n                cx.observe(&buffer, Self::on_buffer_changed),\n                cx.subscribe_in(&buffer, window, Self::on_buffer_event),\n                cx.observe_in(&display_map, window, Self::on_display_map_changed),\n                cx.observe(&blink_manager, |_, _, cx| cx.notify()),\n                cx.observe_global_in::<SettingsStore>(window, Self::settings_changed),\n                cx.observe_window_activation(window, |editor, window, cx| {\n                    let active = window.is_window_active();\n                    editor.blink_manager.update(cx, |blink_manager, cx| {\n                        if active {\n                            blink_manager.enable(cx);\n                        } else {\n                            blink_manager.disable(cx);\n                        }\n                    });\n                }),\n            ],\n            tasks_update_task: None,\n            linked_edit_ranges: Default::default(),\n            in_project_search: false,\n            previous_search_ranges: None,\n            breadcrumb_header: None,\n            focused_block: None,\n            next_scroll_position: NextScrollCursorCenterTopBottom::default(),\n            addons: HashMap::default(),\n            registered_buffers: HashMap::default(),\n            _scroll_cursor_center_top_bottom_task: Task::ready(()),\n            selection_mark_mode: false,\n            toggle_fold_multiple_buffers: Task::ready(()),\n            text_style_refinement: None,\n        };\n        this.tasks_update_task = Some(this.refresh_runnables(window, cx));\n        this._subscriptions.extend(project_subscriptions);\n\n        this.end_selection(window, cx);\n        this.scroll_manager.show_scrollbar(window, cx);\n\n        if mode == EditorMode::Full {\n            let should_auto_hide_scrollbars = cx.should_auto_hide_scrollbars();\n            cx.set_global(ScrollbarAutoHide(should_auto_hide_scrollbars));\n\n            if this.git_blame_inline_enabled {\n                this.git_blame_inline_enabled = true;\n                this.start_git_blame_inline(false, window, cx);\n            }\n\n            if let Some(buffer) = buffer.read(cx).as_singleton() {\n                if let Some(project) = this.project.as_ref() {\n                    let lsp_store = project.read(cx).lsp_store();\n                    let handle = lsp_store.update(cx, |lsp_store, cx| {\n                        lsp_store.register_buffer_with_language_servers(&buffer, cx)\n                    });\n                    this.registered_buffers\n                        .insert(buffer.read(cx).remote_id(), handle);\n                }\n            }\n        }\n\n        this.report_editor_event(\"Editor Opened\", None, cx);\n        this\n    }\n\n    pub fn mouse_menu_is_focused(&self, window: &Window, cx: &App) -> bool {\n        self.mouse_context_menu\n            .as_ref()\n            .is_some_and(|menu| menu.context_menu.focus_handle(cx).is_focused(window))\n    }\n\n    fn key_context(&self, window: &Window, cx: &App) -> KeyContext {\n        self.key_context_internal(self.has_active_inline_completion(), window, cx)\n    }\n\n    fn key_context_internal(\n        &self,\n        has_active_edit_prediction: bool,\n        window: &Window,\n        cx: &App,\n    ) -> KeyContext {\n        let mut key_context = KeyContext::new_with_defaults();\n        key_context.add(\"Editor\");\n        let mode = match self.mode {\n            EditorMode::SingleLine { .. } => \"single_line\",\n            EditorMode::AutoHeight { .. } => \"auto_height\",\n            EditorMode::Full => \"full\",\n        };\n\n        if EditorSettings::jupyter_enabled(cx) {\n            key_context.add(\"jupyter\");\n        }\n\n        key_context.set(\"mode\", mode);\n        if self.pending_rename.is_some() {\n            key_context.add(\"renaming\");\n        }\n\n        let mut showing_completions = false;\n\n        match self.context_menu.borrow().as_ref() {\n            Some(CodeContextMenu::Completions(_)) => {\n                key_context.add(\"menu\");\n                key_context.add(\"showing_completions\");\n                showing_completions = true;\n            }\n            Some(CodeContextMenu::CodeActions(_)) => {\n                key_context.add(\"menu\");\n                key_context.add(\"showing_code_actions\")\n            }\n            None => {}\n        }\n\n        // Disable vim contexts when a sub-editor (e.g. rename/inline assistant) is focused.\n        if !self.focus_handle(cx).contains_focused(window, cx)\n            || (self.is_focused(window) || self.mouse_menu_is_focused(window, cx))\n        {\n            for addon in self.addons.values() {\n                addon.extend_key_context(&mut key_context, cx)\n            }\n        }\n\n        if let Some(extension) = self\n            .buffer\n            .read(cx)\n            .as_singleton()\n            .and_then(|buffer| buffer.read(cx).file()?.path().extension()?.to_str())\n        {\n            key_context.set(\"extension\", extension.to_string());\n        }\n\n        if has_active_edit_prediction {\n            key_context.add(\"copilot_suggestion\");\n            key_context.add(EDIT_PREDICTION_KEY_CONTEXT);\n            if showing_completions\n                || self.edit_prediction_requires_modifier()\n                // Require modifier key when the cursor is on leading whitespace, to allow `tab`\n                // bindings to insert tab characters.\n                || self.edit_prediction_cursor_on_leading_whitespace\n            {\n                key_context.add(EDIT_PREDICTION_REQUIRES_MODIFIER_KEY_CONTEXT);\n            }\n        }\n\n        if self.selection_mark_mode {\n            key_context.add(\"selection_mode\");\n        }\n\n        key_context\n    }\n\n    pub fn accept_edit_prediction_keybind(\n        &self,\n        window: &Window,\n        cx: &App,\n    ) -> AcceptEditPredictionBinding {\n        let key_context = self.key_context_internal(true, window, cx);\n        AcceptEditPredictionBinding(\n            window\n                .bindings_for_action_in_context(&AcceptEditPrediction, key_context)\n                .into_iter()\n                .rev()\n                .next(),\n        )\n    }\n\n    pub fn new_file(\n        workspace: &mut Workspace,\n        _: &workspace::NewFile,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        Self::new_in_workspace(workspace, window, cx).detach_and_prompt_err(\n            \"Failed to create buffer\",\n            window,\n            cx,\n            |e, _, _| match e.error_code() {\n                ErrorCode::RemoteUpgradeRequired => Some(format!(\n                \"The remote instance of Zed does not support this yet. It must be upgraded to {}\",\n                e.error_tag(\"required\").unwrap_or(\"the latest version\")\n            )),\n                _ => None,\n            },\n        );\n    }\n\n    pub fn new_in_workspace(\n        workspace: &mut Workspace,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) -> Task<Result<Entity<Editor>>> {\n        let project = workspace.project().clone();\n        let create = project.update(cx, |project, cx| project.create_buffer(cx));\n\n        cx.spawn_in(window, |workspace, mut cx| async move {\n            let buffer = create.await?;\n            workspace.update_in(&mut cx, |workspace, window, cx| {\n                let editor =\n                    cx.new(|cx| Editor::for_buffer(buffer, Some(project.clone()), window, cx));\n                workspace.add_item_to_active_pane(Box::new(editor.clone()), None, true, window, cx);\n                editor\n            })\n        })\n    }\n\n    fn new_file_vertical(\n        workspace: &mut Workspace,\n        _: &workspace::NewFileSplitVertical,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        Self::new_file_in_direction(workspace, SplitDirection::vertical(cx), window, cx)\n    }\n\n    fn new_file_horizontal(\n        workspace: &mut Workspace,\n        _: &workspace::NewFileSplitHorizontal,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        Self::new_file_in_direction(workspace, SplitDirection::horizontal(cx), window, cx)\n    }\n\n    fn new_file_in_direction(\n        workspace: &mut Workspace,\n        direction: SplitDirection,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        let project = workspace.project().clone();\n        let create = project.update(cx, |project, cx| project.create_buffer(cx));\n\n        cx.spawn_in(window, |workspace, mut cx| async move {\n            let buffer = create.await?;\n            workspace.update_in(&mut cx, move |workspace, window, cx| {\n                workspace.split_item(\n                    direction,\n                    Box::new(\n                        cx.new(|cx| Editor::for_buffer(buffer, Some(project.clone()), window, cx)),\n                    ),\n                    window,\n                    cx,\n                )\n            })?;\n            anyhow::Ok(())\n        })\n        .detach_and_prompt_err(\"Failed to create buffer\", window, cx, |e, _, _| {\n            match e.error_code() {\n                ErrorCode::RemoteUpgradeRequired => Some(format!(\n                \"The remote instance of Zed does not support this yet. It must be upgraded to {}\",\n                e.error_tag(\"required\").unwrap_or(\"the latest version\")\n            )),\n                _ => None,\n            }\n        });\n    }\n\n    pub fn leader_peer_id(&self) -> Option<PeerId> {\n        self.leader_peer_id\n    }\n\n    pub fn buffer(&self) -> &Entity<MultiBuffer> {\n        &self.buffer\n    }\n\n    pub fn workspace(&self) -> Option<Entity<Workspace>> {\n        self.workspace.as_ref()?.0.upgrade()\n    }\n\n    pub fn title<'a>(&self, cx: &'a App) -> Cow<'a, str> {\n        self.buffer().read(cx).title(cx)\n    }\n\n    pub fn snapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n        let git_blame_gutter_max_author_length = self\n            .render_git_blame_gutter(cx)\n            .then(|| {\n                if let Some(blame) = self.blame.as_ref() {\n                    let max_author_length =\n                        blame.update(cx, |blame, cx| blame.max_author_length(cx));\n                    Some(max_author_length)\n                } else {\n                    None\n                }\n            })\n            .flatten();\n\n        EditorSnapshot {\n            mode: self.mode,\n            show_gutter: self.show_gutter,\n            show_line_numbers: self.show_line_numbers,\n            show_git_diff_gutter: self.show_git_diff_gutter,\n            show_code_actions: self.show_code_actions,\n            show_runnables: self.show_runnables,\n            git_blame_gutter_max_author_length,\n            display_snapshot: self.display_map.update(cx, |map, cx| map.snapshot(cx)),\n            scroll_anchor: self.scroll_manager.anchor(),\n            ongoing_scroll: self.scroll_manager.ongoing_scroll(),\n            placeholder_text: self.placeholder_text.clone(),\n            is_focused: self.focus_handle.is_focused(window),\n            current_line_highlight: self\n                .current_line_highlight\n                .unwrap_or_else(|| EditorSettings::get_global(cx).current_line_highlight),\n            gutter_hovered: self.gutter_hovered,\n        }\n    }\n\n    pub fn language_at<T: ToOffset>(&self, point: T, cx: &App) -> Option<Arc<Language>> {\n        self.buffer.read(cx).language_at(point, cx)\n    }\n\n    pub fn file_at<T: ToOffset>(&self, point: T, cx: &App) -> Option<Arc<dyn language::File>> {\n        self.buffer.read(cx).read(cx).file_at(point).cloned()\n    }\n\n    pub fn active_excerpt(\n        &self,\n        cx: &App,\n    ) -> Option<(ExcerptId, Entity<Buffer>, Range<text::Anchor>)> {\n        self.buffer\n            .read(cx)\n            .excerpt_containing(self.selections.newest_anchor().head(), cx)\n    }\n\n    pub fn mode(&self) -> EditorMode {\n        self.mode\n    }\n\n    pub fn collaboration_hub(&self) -> Option<&dyn CollaborationHub> {\n        self.collaboration_hub.as_deref()\n    }\n\n    pub fn set_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n        self.collaboration_hub = Some(hub);\n    }\n\n    pub fn set_in_project_search(&mut self, in_project_search: bool) {\n        self.in_project_search = in_project_search;\n    }\n\n    pub fn set_custom_context_menu(\n        &mut self,\n        f: impl 'static\n            + Fn(\n                &mut Self,\n                DisplayPoint,\n                &mut Window,\n                &mut Context<Self>,\n            ) -> Option<Entity<ui::ContextMenu>>,\n    ) {\n        self.custom_context_menu = Some(Box::new(f))\n    }\n\n    pub fn set_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n        self.completion_provider = provider;\n    }\n\n    pub fn semantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n        self.semantics_provider.clone()\n    }\n\n    pub fn set_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n        self.semantics_provider = provider;\n    }\n\n    pub fn set_edit_prediction_provider<T>(\n        &mut self,\n        provider: Option<Entity<T>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) where\n        T: EditPredictionProvider,\n    {\n        self.edit_prediction_provider =\n            provider.map(|provider| RegisteredInlineCompletionProvider {\n                _subscription: cx.observe_in(&provider, window, |this, _, window, cx| {\n                    if this.focus_handle.is_focused(window) {\n                        this.update_visible_inline_completion(window, cx);\n                    }\n                }),\n                provider: Arc::new(provider),\n            });\n        self.refresh_inline_completion(false, false, window, cx);\n    }\n\n    pub fn placeholder_text(&self) -> Option<&str> {\n        self.placeholder_text.as_deref()\n    }\n\n    pub fn set_placeholder_text(\n        &mut self,\n        placeholder_text: impl Into<Arc<str>>,\n        cx: &mut Context<Self>,\n    ) {\n        let placeholder_text = Some(placeholder_text.into());\n        if self.placeholder_text != placeholder_text {\n            self.placeholder_text = placeholder_text;\n            cx.notify();\n        }\n    }\n\n    pub fn set_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n        self.cursor_shape = cursor_shape;\n\n        // Disrupt blink for immediate user feedback that the cursor shape has changed\n        self.blink_manager.update(cx, BlinkManager::show_cursor);\n\n        cx.notify();\n    }\n\n    pub fn set_current_line_highlight(\n        &mut self,\n        current_line_highlight: Option<CurrentLineHighlight>,\n    ) {\n        self.current_line_highlight = current_line_highlight;\n    }\n\n    pub fn set_collapse_matches(&mut self, collapse_matches: bool) {\n        self.collapse_matches = collapse_matches;\n    }\n\n    fn register_buffers_with_language_servers(&mut self, cx: &mut Context<Self>) {\n        let buffers = self.buffer.read(cx).all_buffers();\n        let Some(lsp_store) = self.lsp_store(cx) else {\n            return;\n        };\n        lsp_store.update(cx, |lsp_store, cx| {\n            for buffer in buffers {\n                self.registered_buffers\n                    .entry(buffer.read(cx).remote_id())\n                    .or_insert_with(|| {\n                        lsp_store.register_buffer_with_language_servers(&buffer, cx)\n                    });\n            }\n        })\n    }\n\n    pub fn range_for_match<T: std::marker::Copy>(&self, range: &Range<T>) -> Range<T> {\n        if self.collapse_matches {\n            return range.start..range.start;\n        }\n        range.clone()\n    }\n\n    pub fn set_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n        if self.display_map.read(cx).clip_at_line_ends != clip {\n            self.display_map\n                .update(cx, |map, _| map.clip_at_line_ends = clip);\n        }\n    }\n\n    pub fn set_input_enabled(&mut self, input_enabled: bool) {\n        self.input_enabled = input_enabled;\n    }\n\n    pub fn set_inline_completions_hidden_for_vim_mode(\n        &mut self,\n        hidden: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if hidden != self.inline_completions_hidden_for_vim_mode {\n            self.inline_completions_hidden_for_vim_mode = hidden;\n            if hidden {\n                self.update_visible_inline_completion(window, cx);\n            } else {\n                self.refresh_inline_completion(true, false, window, cx);\n            }\n        }\n    }\n\n    pub fn set_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n        self.menu_inline_completions_policy = value;\n    }\n\n    pub fn set_autoindent(&mut self, autoindent: bool) {\n        if autoindent {\n            self.autoindent_mode = Some(AutoindentMode::EachLine);\n        } else {\n            self.autoindent_mode = None;\n        }\n    }\n\n    pub fn read_only(&self, cx: &App) -> bool {\n        self.read_only || self.buffer.read(cx).read_only()\n    }\n\n    pub fn set_read_only(&mut self, read_only: bool) {\n        self.read_only = read_only;\n    }\n\n    pub fn set_use_autoclose(&mut self, autoclose: bool) {\n        self.use_autoclose = autoclose;\n    }\n\n    pub fn set_use_auto_surround(&mut self, auto_surround: bool) {\n        self.use_auto_surround = auto_surround;\n    }\n\n    pub fn set_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n        self.auto_replace_emoji_shortcode = auto_replace;\n    }\n\n    pub fn toggle_inline_completions(\n        &mut self,\n        _: &ToggleEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.show_inline_completions_override.is_some() {\n            self.set_show_edit_predictions(None, window, cx);\n        } else {\n            let show_edit_predictions = !self.edit_predictions_enabled();\n            self.set_show_edit_predictions(Some(show_edit_predictions), window, cx);\n        }\n    }\n\n    pub fn set_show_edit_predictions(\n        &mut self,\n        show_edit_predictions: Option<bool>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_inline_completions_override = show_edit_predictions;\n        self.refresh_inline_completion(false, true, window, cx);\n    }\n\n    fn inline_completions_disabled_in_scope(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: language::Anchor,\n        cx: &App,\n    ) -> bool {\n        let snapshot = buffer.read(cx).snapshot();\n        let settings = snapshot.settings_at(buffer_position, cx);\n\n        let Some(scope) = snapshot.language_scope_at(buffer_position) else {\n            return false;\n        };\n\n        scope.override_name().map_or(false, |scope_name| {\n            settings\n                .edit_predictions_disabled_in\n                .iter()\n                .any(|s| s == scope_name)\n        })\n    }\n\n    pub fn set_use_modal_editing(&mut self, to: bool) {\n        self.use_modal_editing = to;\n    }\n\n    pub fn use_modal_editing(&self) -> bool {\n        self.use_modal_editing\n    }\n\n    fn selections_did_change(\n        &mut self,\n        local: bool,\n        old_cursor_position: &Anchor,\n        show_completions: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        window.invalidate_character_coordinates();\n\n        // Copy selections to primary selection buffer\n        #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n        if local {\n            let selections = self.selections.all::<usize>(cx);\n            let buffer_handle = self.buffer.read(cx).read(cx);\n\n            let mut text = String::new();\n            for (index, selection) in selections.iter().enumerate() {\n                let text_for_selection = buffer_handle\n                    .text_for_range(selection.start..selection.end)\n                    .collect::<String>();\n\n                text.push_str(&text_for_selection);\n                if index != selections.len() - 1 {\n                    text.push('\\n');\n                }\n            }\n\n            if !text.is_empty() {\n                cx.write_to_primary(ClipboardItem::new_string(text));\n            }\n        }\n\n        if self.focus_handle.is_focused(window) && self.leader_peer_id.is_none() {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.set_active_selections(\n                    &self.selections.disjoint_anchors(),\n                    self.selections.line_mode,\n                    self.cursor_shape,\n                    cx,\n                )\n            });\n        }\n        let display_map = self\n            .display_map\n            .update(cx, |display_map, cx| display_map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        self.add_selections_state = None;\n        self.select_next_state = None;\n        self.select_prev_state = None;\n        self.select_larger_syntax_node_stack.clear();\n        self.invalidate_autoclose_regions(&self.selections.disjoint_anchors(), buffer);\n        self.snippet_stack\n            .invalidate(&self.selections.disjoint_anchors(), buffer);\n        self.take_rename(false, window, cx);\n\n        let new_cursor_position = self.selections.newest_anchor().head();\n\n        self.push_to_nav_history(\n            *old_cursor_position,\n            Some(new_cursor_position.to_point(buffer)),\n            cx,\n        );\n\n        if local {\n            let new_cursor_position = self.selections.newest_anchor().head();\n            let mut context_menu = self.context_menu.borrow_mut();\n            let completion_menu = match context_menu.as_ref() {\n                Some(CodeContextMenu::Completions(menu)) => Some(menu),\n                _ => {\n                    *context_menu = None;\n                    None\n                }\n            };\n            if let Some(buffer_id) = new_cursor_position.buffer_id {\n                if !self.registered_buffers.contains_key(&buffer_id) {\n                    if let Some(lsp_store) = self.lsp_store(cx) {\n                        lsp_store.update(cx, |lsp_store, cx| {\n                            let Some(buffer) = self.buffer.read(cx).buffer(buffer_id) else {\n                                return;\n                            };\n                            self.registered_buffers.insert(\n                                buffer_id,\n                                lsp_store.register_buffer_with_language_servers(&buffer, cx),\n                            );\n                        })\n                    }\n                }\n            }\n\n            if let Some(completion_menu) = completion_menu {\n                let cursor_position = new_cursor_position.to_offset(buffer);\n                let (word_range, kind) =\n                    buffer.surrounding_word(completion_menu.initial_position, true);\n                if kind == Some(CharKind::Word)\n                    && word_range.to_inclusive().contains(&cursor_position)\n                {\n                    let mut completion_menu = completion_menu.clone();\n                    drop(context_menu);\n\n                    let query = Self::completion_query(buffer, cursor_position);\n                    cx.spawn(move |this, mut cx| async move {\n                        completion_menu\n                            .filter(query.as_deref(), cx.background_executor().clone())\n                            .await;\n\n                        this.update(&mut cx, |this, cx| {\n                            let mut context_menu = this.context_menu.borrow_mut();\n                            let Some(CodeContextMenu::Completions(menu)) = context_menu.as_ref()\n                            else {\n                                return;\n                            };\n\n                            if menu.id > completion_menu.id {\n                                return;\n                            }\n\n                            *context_menu = Some(CodeContextMenu::Completions(completion_menu));\n                            drop(context_menu);\n                            cx.notify();\n                        })\n                    })\n                    .detach();\n\n                    if show_completions {\n                        self.show_completions(&ShowCompletions { trigger: None }, window, cx);\n                    }\n                } else {\n                    drop(context_menu);\n                    self.hide_context_menu(window, cx);\n                }\n            } else {\n                drop(context_menu);\n            }\n\n            hide_hover(self, cx);\n\n            if old_cursor_position.to_display_point(&display_map).row()\n                != new_cursor_position.to_display_point(&display_map).row()\n            {\n                self.available_code_actions.take();\n            }\n            self.refresh_code_actions(window, cx);\n            self.refresh_document_highlights(cx);\n            refresh_matching_bracket_highlights(self, window, cx);\n            self.update_visible_inline_completion(window, cx);\n            linked_editing_ranges::refresh_linked_ranges(self, window, cx);\n            if self.git_blame_inline_enabled {\n                self.start_inline_blame_timer(window, cx);\n            }\n        }\n\n        self.blink_manager.update(cx, BlinkManager::pause_blinking);\n        cx.emit(EditorEvent::SelectionsChanged { local });\n\n        if self.selections.disjoint_anchors().len() == 1 {\n            cx.emit(SearchEvent::ActiveMatchChanged)\n        }\n        cx.notify();\n    }\n\n    pub fn change_selections<R>(\n        &mut self,\n        autoscroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        change: impl FnOnce(&mut MutableSelectionsCollection<'_>) -> R,\n    ) -> R {\n        self.change_selections_inner(autoscroll, true, window, cx, change)\n    }\n\n    pub fn change_selections_inner<R>(\n        &mut self,\n        autoscroll: Option<Autoscroll>,\n        request_completions: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        change: impl FnOnce(&mut MutableSelectionsCollection<'_>) -> R,\n    ) -> R {\n        let old_cursor_position = self.selections.newest_anchor().head();\n        self.push_to_selection_history();\n\n        let (changed, result) = self.selections.change_with(cx, change);\n\n        if changed {\n            if let Some(autoscroll) = autoscroll {\n                self.request_autoscroll(autoscroll, cx);\n            }\n            self.selections_did_change(true, &old_cursor_position, request_completions, window, cx);\n\n            if self.should_open_signature_help_automatically(\n                &old_cursor_position,\n                self.signature_help_state.backspace_pressed(),\n                cx,\n            ) {\n                self.show_signature_help(&ShowSignatureHelp, window, cx);\n            }\n            self.signature_help_state.set_backspace_pressed(false);\n        }\n\n        result\n    }\n\n    pub fn edit<I, S, T>(&mut self, edits: I, cx: &mut Context<Self>)\n    where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer\n            .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n    }\n\n    pub fn edit_with_autoindent<I, S, T>(&mut self, edits: I, cx: &mut Context<Self>)\n    where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(edits, self.autoindent_mode.clone(), cx)\n        });\n    }\n\n    pub fn edit_with_block_indent<I, S, T>(\n        &mut self,\n        edits: I,\n        original_indent_columns: Vec<u32>,\n        cx: &mut Context<Self>,\n    ) where\n        I: IntoIterator<Item = (Range<S>, T)>,\n        S: ToOffset,\n        T: Into<Arc<str>>,\n    {\n        if self.read_only(cx) {\n            return;\n        }\n\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.edit(\n                edits,\n                Some(AutoindentMode::Block {\n                    original_indent_columns,\n                }),\n                cx,\n            )\n        });\n    }\n\n    fn select(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n        self.hide_context_menu(window, cx);\n\n        match phase {\n            SelectPhase::Begin {\n                position,\n                add,\n                click_count,\n            } => self.begin_selection(position, add, click_count, window, cx),\n            SelectPhase::BeginColumnar {\n                position,\n                goal_column,\n                reset,\n            } => self.begin_columnar_selection(position, goal_column, reset, window, cx),\n            SelectPhase::Extend {\n                position,\n                click_count,\n            } => self.extend_selection(position, click_count, window, cx),\n            SelectPhase::Update {\n                position,\n                goal_column,\n                scroll_delta,\n            } => self.update_selection(position, goal_column, scroll_delta, window, cx),\n            SelectPhase::End => self.end_selection(window, cx),\n        }\n    }\n\n    fn extend_selection(\n        &mut self,\n        position: DisplayPoint,\n        click_count: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let tail = self.selections.newest::<usize>(cx).tail();\n        self.begin_selection(position, false, click_count, window, cx);\n\n        let position = position.to_offset(&display_map, Bias::Left);\n        let tail_anchor = display_map.buffer_snapshot.anchor_before(tail);\n\n        let mut pending_selection = self\n            .selections\n            .pending_anchor()\n            .expect(\"extend_selection not called with pending selection\");\n        if position >= tail {\n            pending_selection.start = tail_anchor;\n        } else {\n            pending_selection.end = tail_anchor;\n            pending_selection.reversed = true;\n        }\n\n        let mut pending_mode = self.selections.pending_mode().unwrap();\n        match &mut pending_mode {\n            SelectMode::Word(range) | SelectMode::Line(range) => *range = tail_anchor..tail_anchor,\n            _ => {}\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.set_pending(pending_selection, pending_mode)\n        });\n    }\n\n    fn begin_selection(\n        &mut self,\n        position: DisplayPoint,\n        add: bool,\n        click_count: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.focus_handle.is_focused(window) {\n            self.last_focused_descendant = None;\n            window.focus(&self.focus_handle);\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let newest_selection = self.selections.newest_anchor().clone();\n        let position = display_map.clip_point(position, Bias::Left);\n\n        let start;\n        let end;\n        let mode;\n        let mut auto_scroll;\n        match click_count {\n            1 => {\n                start = buffer.anchor_before(position.to_point(&display_map));\n                end = start;\n                mode = SelectMode::Character;\n                auto_scroll = true;\n            }\n            2 => {\n                let range = movement::surrounding_word(&display_map, position);\n                start = buffer.anchor_before(range.start.to_point(&display_map));\n                end = buffer.anchor_before(range.end.to_point(&display_map));\n                mode = SelectMode::Word(start..end);\n                auto_scroll = true;\n            }\n            3 => {\n                let position = display_map\n                    .clip_point(position, Bias::Left)\n                    .to_point(&display_map);\n                let line_start = display_map.prev_line_boundary(position).0;\n                let next_line_start = buffer.clip_point(\n                    display_map.next_line_boundary(position).0 + Point::new(1, 0),\n                    Bias::Left,\n                );\n                start = buffer.anchor_before(line_start);\n                end = buffer.anchor_before(next_line_start);\n                mode = SelectMode::Line(start..end);\n                auto_scroll = true;\n            }\n            _ => {\n                start = buffer.anchor_before(0);\n                end = buffer.anchor_before(buffer.len());\n                mode = SelectMode::All;\n                auto_scroll = false;\n            }\n        }\n        auto_scroll &= EditorSettings::get_global(cx).autoscroll_on_clicks;\n\n        let point_to_delete: Option<usize> = {\n            let selected_points: Vec<Selection<Point>> =\n                self.selections.disjoint_in_range(start..end, cx);\n\n            if !add || click_count > 1 {\n                None\n            } else if !selected_points.is_empty() {\n                Some(selected_points[0].id)\n            } else {\n                let clicked_point_already_selected =\n                    self.selections.disjoint.iter().find(|selection| {\n                        selection.start.to_point(buffer) == start.to_point(buffer)\n                            || selection.end.to_point(buffer) == end.to_point(buffer)\n                    });\n\n                clicked_point_already_selected.map(|selection| selection.id)\n            }\n        };\n\n        let selections_count = self.selections.count();\n\n        self.change_selections(auto_scroll.then(Autoscroll::newest), window, cx, |s| {\n            if let Some(point_to_delete) = point_to_delete {\n                s.delete(point_to_delete);\n\n                if selections_count == 1 {\n                    s.set_pending_anchor_range(start..end, mode);\n                }\n            } else {\n                if !add {\n                    s.clear_disjoint();\n                } else if click_count > 1 {\n                    s.delete(newest_selection.id)\n                }\n\n                s.set_pending_anchor_range(start..end, mode);\n            }\n        });\n    }\n\n    fn begin_columnar_selection(\n        &mut self,\n        position: DisplayPoint,\n        goal_column: u32,\n        reset: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.focus_handle.is_focused(window) {\n            self.last_focused_descendant = None;\n            window.focus(&self.focus_handle);\n        }\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if reset {\n            let pointer_position = display_map\n                .buffer_snapshot\n                .anchor_before(position.to_point(&display_map));\n\n            self.change_selections(Some(Autoscroll::newest()), window, cx, |s| {\n                s.clear_disjoint();\n                s.set_pending_anchor_range(\n                    pointer_position..pointer_position,\n                    SelectMode::Character,\n                );\n            });\n        }\n\n        let tail = self.selections.newest::<Point>(cx).tail();\n        self.columnar_selection_tail = Some(display_map.buffer_snapshot.anchor_before(tail));\n\n        if !reset {\n            self.select_columns(\n                tail.to_display_point(&display_map),\n                position,\n                goal_column,\n                &display_map,\n                window,\n                cx,\n            );\n        }\n    }\n\n    fn update_selection(\n        &mut self,\n        position: DisplayPoint,\n        goal_column: u32,\n        scroll_delta: gpui::Point<f32>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if let Some(tail) = self.columnar_selection_tail.as_ref() {\n            let tail = tail.to_display_point(&display_map);\n            self.select_columns(tail, position, goal_column, &display_map, window, cx);\n        } else if let Some(mut pending) = self.selections.pending_anchor() {\n            let buffer = self.buffer.read(cx).snapshot(cx);\n            let head;\n            let tail;\n            let mode = self.selections.pending_mode().unwrap();\n            match &mode {\n                SelectMode::Character => {\n                    head = position.to_point(&display_map);\n                    tail = pending.tail().to_point(&buffer);\n                }\n                SelectMode::Word(original_range) => {\n                    let original_display_range = original_range.start.to_display_point(&display_map)\n                        ..original_range.end.to_display_point(&display_map);\n                    let original_buffer_range = original_display_range.start.to_point(&display_map)\n                        ..original_display_range.end.to_point(&display_map);\n                    if movement::is_inside_word(&display_map, position)\n                        || original_display_range.contains(&position)\n                    {\n                        let word_range = movement::surrounding_word(&display_map, position);\n                        if word_range.start < original_display_range.start {\n                            head = word_range.start.to_point(&display_map);\n                        } else {\n                            head = word_range.end.to_point(&display_map);\n                        }\n                    } else {\n                        head = position.to_point(&display_map);\n                    }\n\n                    if head <= original_buffer_range.start {\n                        tail = original_buffer_range.end;\n                    } else {\n                        tail = original_buffer_range.start;\n                    }\n                }\n                SelectMode::Line(original_range) => {\n                    let original_range = original_range.to_point(&display_map.buffer_snapshot);\n\n                    let position = display_map\n                        .clip_point(position, Bias::Left)\n                        .to_point(&display_map);\n                    let line_start = display_map.prev_line_boundary(position).0;\n                    let next_line_start = buffer.clip_point(\n                        display_map.next_line_boundary(position).0 + Point::new(1, 0),\n                        Bias::Left,\n                    );\n\n                    if line_start < original_range.start {\n                        head = line_start\n                    } else {\n                        head = next_line_start\n                    }\n\n                    if head <= original_range.start {\n                        tail = original_range.end;\n                    } else {\n                        tail = original_range.start;\n                    }\n                }\n                SelectMode::All => {\n                    return;\n                }\n            };\n\n            if head < tail {\n                pending.start = buffer.anchor_before(head);\n                pending.end = buffer.anchor_before(tail);\n                pending.reversed = true;\n            } else {\n                pending.start = buffer.anchor_before(tail);\n                pending.end = buffer.anchor_before(head);\n                pending.reversed = false;\n            }\n\n            self.change_selections(None, window, cx, |s| {\n                s.set_pending(pending, mode);\n            });\n        } else {\n            log::error!(\"update_selection dispatched with no pending selection\");\n            return;\n        }\n\n        self.apply_scroll_delta(scroll_delta, window, cx);\n        cx.notify();\n    }\n\n    fn end_selection(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.columnar_selection_tail.take();\n        if self.selections.pending_anchor().is_some() {\n            let selections = self.selections.all::<usize>(cx);\n            self.change_selections(None, window, cx, |s| {\n                s.select(selections);\n                s.clear_pending();\n            });\n        }\n    }\n\n    fn select_columns(\n        &mut self,\n        tail: DisplayPoint,\n        head: DisplayPoint,\n        goal_column: u32,\n        display_map: &DisplaySnapshot,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let start_row = cmp::min(tail.row(), head.row());\n        let end_row = cmp::max(tail.row(), head.row());\n        let start_column = cmp::min(tail.column(), goal_column);\n        let end_column = cmp::max(tail.column(), goal_column);\n        let reversed = start_column < tail.column();\n\n        let selection_ranges = (start_row.0..=end_row.0)\n            .map(DisplayRow)\n            .filter_map(|row| {\n                if start_column <= display_map.line_len(row) && !display_map.is_block_line(row) {\n                    let start = display_map\n                        .clip_point(DisplayPoint::new(row, start_column), Bias::Left)\n                        .to_point(display_map);\n                    let end = display_map\n                        .clip_point(DisplayPoint::new(row, end_column), Bias::Right)\n                        .to_point(display_map);\n                    if reversed {\n                        Some(end..start)\n                    } else {\n                        Some(start..end)\n                    }\n                } else {\n                    None\n                }\n            })\n            .collect::<Vec<_>>();\n\n        self.change_selections(None, window, cx, |s| {\n            s.select_ranges(selection_ranges);\n        });\n        cx.notify();\n    }\n\n    pub fn has_pending_nonempty_selection(&self) -> bool {\n        let pending_nonempty_selection = match self.selections.pending_anchor() {\n            Some(Selection { start, end, .. }) => start != end,\n            None => false,\n        };\n\n        pending_nonempty_selection\n            || (self.columnar_selection_tail.is_some() && self.selections.disjoint.len() > 1)\n    }\n\n    pub fn has_pending_selection(&self) -> bool {\n        self.selections.pending_anchor().is_some() || self.columnar_selection_tail.is_some()\n    }\n\n    pub fn cancel(&mut self, _: &Cancel, window: &mut Window, cx: &mut Context<Self>) {\n        self.selection_mark_mode = false;\n\n        if self.clear_expanded_diff_hunks(cx) {\n            cx.notify();\n            return;\n        }\n        if self.dismiss_menus_and_popups(true, window, cx) {\n            return;\n        }\n\n        if self.mode == EditorMode::Full\n            && self.change_selections(Some(Autoscroll::fit()), window, cx, |s| s.try_cancel())\n        {\n            return;\n        }\n\n        cx.propagate();\n    }\n\n    pub fn dismiss_menus_and_popups(\n        &mut self,\n        is_user_requested: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if self.take_rename(false, window, cx).is_some() {\n            return true;\n        }\n\n        if hide_hover(self, cx) {\n            return true;\n        }\n\n        if self.hide_signature_help(cx, SignatureHelpHiddenBy::Escape) {\n            return true;\n        }\n\n        if self.hide_context_menu(window, cx).is_some() {\n            return true;\n        }\n\n        if self.mouse_context_menu.take().is_some() {\n            return true;\n        }\n\n        if is_user_requested && self.discard_inline_completion(true, cx) {\n            return true;\n        }\n\n        if self.snippet_stack.pop().is_some() {\n            return true;\n        }\n\n        if self.mode == EditorMode::Full && self.active_diagnostics.is_some() {\n            self.dismiss_diagnostics(cx);\n            return true;\n        }\n\n        false\n    }\n\n    fn linked_editing_ranges_for(\n        &self,\n        selection: Range<text::Anchor>,\n        cx: &App,\n    ) -> Option<HashMap<Entity<Buffer>, Vec<Range<text::Anchor>>>> {\n        if self.linked_edit_ranges.is_empty() {\n            return None;\n        }\n        let ((base_range, linked_ranges), buffer_snapshot, buffer) =\n            selection.end.buffer_id.and_then(|end_buffer_id| {\n                if selection.start.buffer_id != Some(end_buffer_id) {\n                    return None;\n                }\n                let buffer = self.buffer.read(cx).buffer(end_buffer_id)?;\n                let snapshot = buffer.read(cx).snapshot();\n                self.linked_edit_ranges\n                    .get(end_buffer_id, selection.start..selection.end, &snapshot)\n                    .map(|ranges| (ranges, snapshot, buffer))\n            })?;\n        use text::ToOffset as TO;\n        // find offset from the start of current range to current cursor position\n        let start_byte_offset = TO::to_offset(&base_range.start, &buffer_snapshot);\n\n        let start_offset = TO::to_offset(&selection.start, &buffer_snapshot);\n        let start_difference = start_offset - start_byte_offset;\n        let end_offset = TO::to_offset(&selection.end, &buffer_snapshot);\n        let end_difference = end_offset - start_byte_offset;\n        // Current range has associated linked ranges.\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n        for range in linked_ranges.iter() {\n            let start_offset = TO::to_offset(&range.start, &buffer_snapshot);\n            let end_offset = start_offset + end_difference;\n            let start_offset = start_offset + start_difference;\n            if start_offset > buffer_snapshot.len() || end_offset > buffer_snapshot.len() {\n                continue;\n            }\n            if self.selections.disjoint_anchor_ranges().any(|s| {\n                if s.start.buffer_id != selection.start.buffer_id\n                    || s.end.buffer_id != selection.end.buffer_id\n                {\n                    return false;\n                }\n                TO::to_offset(&s.start.text_anchor, &buffer_snapshot) <= end_offset\n                    && TO::to_offset(&s.end.text_anchor, &buffer_snapshot) >= start_offset\n            }) {\n                continue;\n            }\n            let start = buffer_snapshot.anchor_after(start_offset);\n            let end = buffer_snapshot.anchor_after(end_offset);\n            linked_edits\n                .entry(buffer.clone())\n                .or_default()\n                .push(start..end);\n        }\n        Some(linked_edits)\n    }\n\n    pub fn handle_input(&mut self, text: &str, window: &mut Window, cx: &mut Context<Self>) {\n        let text: Arc<str> = text.into();\n\n        if self.read_only(cx) {\n            return;\n        }\n\n        let selections = self.selections.all_adjusted(cx);\n        let mut bracket_inserted = false;\n        let mut edits = Vec::new();\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n        let mut new_selections = Vec::with_capacity(selections.len());\n        let mut new_autoclose_regions = Vec::new();\n        let snapshot = self.buffer.read(cx).read(cx);\n\n        for (selection, autoclose_region) in\n            self.selections_with_autoclose_regions(selections, &snapshot)\n        {\n            if let Some(scope) = snapshot.language_scope_at(selection.head()) {\n                // Determine if the inserted text matches the opening or closing\n                // bracket of any of this language's bracket pairs.\n                let mut bracket_pair = None;\n                let mut is_bracket_pair_start = false;\n                let mut is_bracket_pair_end = false;\n                if !text.is_empty() {\n                    // `text` can be empty when a user is using IME (e.g. Chinese Wubi Simplified)\n                    //  and they are removing the character that triggered IME popup.\n                    for (pair, enabled) in scope.brackets() {\n                        if !pair.close && !pair.surround {\n                            continue;\n                        }\n\n                        if enabled && pair.start.ends_with(text.as_ref()) {\n                            let prefix_len = pair.start.len() - text.len();\n                            let preceding_text_matches_prefix = prefix_len == 0\n                                || (selection.start.column >= (prefix_len as u32)\n                                    && snapshot.contains_str_at(\n                                        Point::new(\n                                            selection.start.row,\n                                            selection.start.column - (prefix_len as u32),\n                                        ),\n                                        &pair.start[..prefix_len],\n                                    ));\n                            if preceding_text_matches_prefix {\n                                bracket_pair = Some(pair.clone());\n                                is_bracket_pair_start = true;\n                                break;\n                            }\n                        }\n                        if pair.end.as_str() == text.as_ref() {\n                            bracket_pair = Some(pair.clone());\n                            is_bracket_pair_end = true;\n                            break;\n                        }\n                    }\n                }\n\n                if let Some(bracket_pair) = bracket_pair {\n                    let snapshot_settings = snapshot.settings_at(selection.start, cx);\n                    let autoclose = self.use_autoclose && snapshot_settings.use_autoclose;\n                    let auto_surround =\n                        self.use_auto_surround && snapshot_settings.use_auto_surround;\n                    if selection.is_empty() {\n                        if is_bracket_pair_start {\n                            // If the inserted text is a suffix of an opening bracket and the\n                            // selection is preceded by the rest of the opening bracket, then\n                            // insert the closing bracket.\n                            let following_text_allows_autoclose = snapshot\n                                .chars_at(selection.start)\n                                .next()\n                                .map_or(true, |c| scope.should_autoclose_before(c));\n\n                            let is_closing_quote = if bracket_pair.end == bracket_pair.start\n                                && bracket_pair.start.len() == 1\n                            {\n                                let target = bracket_pair.start.chars().next().unwrap();\n                                let current_line_count = snapshot\n                                    .reversed_chars_at(selection.start)\n                                    .take_while(|&c| c != '\\n')\n                                    .filter(|&c| c == target)\n                                    .count();\n                                current_line_count % 2 == 1\n                            } else {\n                                false\n                            };\n\n                            if autoclose\n                                && bracket_pair.close\n                                && following_text_allows_autoclose\n                                && !is_closing_quote\n                            {\n                                let anchor = snapshot.anchor_before(selection.end);\n                                new_selections.push((selection.map(|_| anchor), text.len()));\n                                new_autoclose_regions.push((\n                                    anchor,\n                                    text.len(),\n                                    selection.id,\n                                    bracket_pair.clone(),\n                                ));\n                                edits.push((\n                                    selection.range(),\n                                    format!(\"{}{}\", text, bracket_pair.end).into(),\n                                ));\n                                bracket_inserted = true;\n                                continue;\n                            }\n                        }\n\n                        if let Some(region) = autoclose_region {\n                            // If the selection is followed by an auto-inserted closing bracket,\n                            // then don't insert that closing bracket again; just move the selection\n                            // past the closing bracket.\n                            let should_skip = selection.end == region.range.end.to_point(&snapshot)\n                                && text.as_ref() == region.pair.end.as_str();\n                            if should_skip {\n                                let anchor = snapshot.anchor_after(selection.end);\n                                new_selections\n                                    .push((selection.map(|_| anchor), region.pair.end.len()));\n                                continue;\n                            }\n                        }\n\n                        let always_treat_brackets_as_autoclosed = snapshot\n                            .settings_at(selection.start, cx)\n                            .always_treat_brackets_as_autoclosed;\n                        if always_treat_brackets_as_autoclosed\n                            && is_bracket_pair_end\n                            && snapshot.contains_str_at(selection.end, text.as_ref())\n                        {\n                            // Otherwise, when `always_treat_brackets_as_autoclosed` is set to `true\n                            // and the inserted text is a closing bracket and the selection is followed\n                            // by the closing bracket then move the selection past the closing bracket.\n                            let anchor = snapshot.anchor_after(selection.end);\n                            new_selections.push((selection.map(|_| anchor), text.len()));\n                            continue;\n                        }\n                    }\n                    // If an opening bracket is 1 character long and is typed while\n                    // text is selected, then surround that text with the bracket pair.\n                    else if auto_surround\n                        && bracket_pair.surround\n                        && is_bracket_pair_start\n                        && bracket_pair.start.chars().count() == 1\n                    {\n                        edits.push((selection.start..selection.start, text.clone()));\n                        edits.push((\n                            selection.end..selection.end,\n                            bracket_pair.end.as_str().into(),\n                        ));\n                        bracket_inserted = true;\n                        new_selections.push((\n                            Selection {\n                                id: selection.id,\n                                start: snapshot.anchor_after(selection.start),\n                                end: snapshot.anchor_before(selection.end),\n                                reversed: selection.reversed,\n                                goal: selection.goal,\n                            },\n                            0,\n                        ));\n                        continue;\n                    }\n                }\n            }\n\n            if self.auto_replace_emoji_shortcode\n                && selection.is_empty()\n                && text.as_ref().ends_with(':')\n            {\n                if let Some(possible_emoji_short_code) =\n                    Self::find_possible_emoji_shortcode_at_position(&snapshot, selection.start)\n                {\n                    if !possible_emoji_short_code.is_empty() {\n                        if let Some(emoji) = emojis::get_by_shortcode(&possible_emoji_short_code) {\n                            let emoji_shortcode_start = Point::new(\n                                selection.start.row,\n                                selection.start.column - possible_emoji_short_code.len() as u32 - 1,\n                            );\n\n                            // Remove shortcode from buffer\n                            edits.push((\n                                emoji_shortcode_start..selection.start,\n                                \"\".to_string().into(),\n                            ));\n                            new_selections.push((\n                                Selection {\n                                    id: selection.id,\n                                    start: snapshot.anchor_after(emoji_shortcode_start),\n                                    end: snapshot.anchor_before(selection.start),\n                                    reversed: selection.reversed,\n                                    goal: selection.goal,\n                                },\n                                0,\n                            ));\n\n                            // Insert emoji\n                            let selection_start_anchor = snapshot.anchor_after(selection.start);\n                            new_selections.push((selection.map(|_| selection_start_anchor), 0));\n                            edits.push((selection.start..selection.end, emoji.to_string().into()));\n\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            // If not handling any auto-close operation, then just replace the selected\n            // text with the given input and move the selection to the end of the\n            // newly inserted text.\n            let anchor = snapshot.anchor_after(selection.end);\n            if !self.linked_edit_ranges.is_empty() {\n                let start_anchor = snapshot.anchor_before(selection.start);\n\n                let is_word_char = text.chars().next().map_or(true, |char| {\n                    let classifier = snapshot.char_classifier_at(start_anchor.to_offset(&snapshot));\n                    classifier.is_word(char)\n                });\n\n                if is_word_char {\n                    if let Some(ranges) = self\n                        .linked_editing_ranges_for(start_anchor.text_anchor..anchor.text_anchor, cx)\n                    {\n                        for (buffer, edits) in ranges {\n                            linked_edits\n                                .entry(buffer.clone())\n                                .or_default()\n                                .extend(edits.into_iter().map(|range| (range, text.clone())));\n                        }\n                    }\n                }\n            }\n\n            new_selections.push((selection.map(|_| anchor), 0));\n            edits.push((selection.start..selection.end, text.clone()));\n        }\n\n        drop(snapshot);\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, this.autoindent_mode.clone(), cx);\n            });\n            for (buffer, edits) in linked_edits {\n                buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.snapshot();\n                    let edits = edits\n                        .into_iter()\n                        .map(|(range, text)| {\n                            use text::ToPoint as TP;\n                            let end_point = TP::to_point(&range.end, &snapshot);\n                            let start_point = TP::to_point(&range.start, &snapshot);\n                            (start_point..end_point, text)\n                        })\n                        .sorted_by_key(|(range, _)| range.start)\n                        .collect::<Vec<_>>();\n                    buffer.edit(edits, None, cx);\n                })\n            }\n            let new_anchor_selections = new_selections.iter().map(|e| &e.0);\n            let new_selection_deltas = new_selections.iter().map(|e| e.1);\n            let map = this.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let new_selections = resolve_selections::<usize, _>(new_anchor_selections, &map)\n                .zip(new_selection_deltas)\n                .map(|(selection, delta)| Selection {\n                    id: selection.id,\n                    start: selection.start + delta,\n                    end: selection.end + delta,\n                    reversed: selection.reversed,\n                    goal: SelectionGoal::None,\n                })\n                .collect::<Vec<_>>();\n\n            let mut i = 0;\n            for (position, delta, selection_id, pair) in new_autoclose_regions {\n                let position = position.to_offset(&map.buffer_snapshot) + delta;\n                let start = map.buffer_snapshot.anchor_before(position);\n                let end = map.buffer_snapshot.anchor_after(position);\n                while let Some(existing_state) = this.autoclose_regions.get(i) {\n                    match existing_state.range.start.cmp(&start, &map.buffer_snapshot) {\n                        Ordering::Less => i += 1,\n                        Ordering::Greater => break,\n                        Ordering::Equal => {\n                            match end.cmp(&existing_state.range.end, &map.buffer_snapshot) {\n                                Ordering::Less => i += 1,\n                                Ordering::Equal => break,\n                                Ordering::Greater => break,\n                            }\n                        }\n                    }\n                }\n                this.autoclose_regions.insert(\n                    i,\n                    AutocloseRegion {\n                        selection_id,\n                        range: start..end,\n                        pair,\n                    },\n                );\n            }\n\n            let had_active_inline_completion = this.has_active_inline_completion();\n            this.change_selections_inner(Some(Autoscroll::fit()), false, window, cx, |s| {\n                s.select(new_selections)\n            });\n\n            if !bracket_inserted {\n                if let Some(on_type_format_task) =\n                    this.trigger_on_type_formatting(text.to_string(), window, cx)\n                {\n                    on_type_format_task.detach_and_log_err(cx);\n                }\n            }\n\n            let editor_settings = EditorSettings::get_global(cx);\n            if bracket_inserted\n                && (editor_settings.auto_signature_help\n                    || editor_settings.show_signature_help_after_edits)\n            {\n                this.show_signature_help(&ShowSignatureHelp, window, cx);\n            }\n\n            let trigger_in_words =\n                this.show_edit_predictions_in_menu() || !had_active_inline_completion;\n            this.trigger_completion_on_input(&text, trigger_in_words, window, cx);\n            linked_editing_ranges::refresh_linked_ranges(this, window, cx);\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    fn find_possible_emoji_shortcode_at_position(\n        snapshot: &MultiBufferSnapshot,\n        position: Point,\n    ) -> Option<String> {\n        let mut chars = Vec::new();\n        let mut found_colon = false;\n        for char in snapshot.reversed_chars_at(position).take(100) {\n            // Found a possible emoji shortcode in the middle of the buffer\n            if found_colon {\n                if char.is_whitespace() {\n                    chars.reverse();\n                    return Some(chars.iter().collect());\n                }\n                // If the previous character is not a whitespace, we are in the middle of a word\n                // and we only want to complete the shortcode if the word is made up of other emojis\n                let mut containing_word = String::new();\n                for ch in snapshot\n                    .reversed_chars_at(position)\n                    .skip(chars.len() + 1)\n                    .take(100)\n                {\n                    if ch.is_whitespace() {\n                        break;\n                    }\n                    containing_word.push(ch);\n                }\n                let containing_word = containing_word.chars().rev().collect::<String>();\n                if util::word_consists_of_emojis(containing_word.as_str()) {\n                    chars.reverse();\n                    return Some(chars.iter().collect());\n                }\n            }\n\n            if char.is_whitespace() || !char.is_ascii() {\n                return None;\n            }\n            if char == ':' {\n                found_colon = true;\n            } else {\n                chars.push(char);\n            }\n        }\n        // Found a possible emoji shortcode at the beginning of the buffer\n        chars.reverse();\n        Some(chars.iter().collect())\n    }\n\n    pub fn newline(&mut self, _: &Newline, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            let (edits, selection_fixup_info): (Vec<_>, Vec<_>) = {\n                let selections = this.selections.all::<usize>(cx);\n                let multi_buffer = this.buffer.read(cx);\n                let buffer = multi_buffer.snapshot(cx);\n                selections\n                    .iter()\n                    .map(|selection| {\n                        let start_point = selection.start.to_point(&buffer);\n                        let mut indent =\n                            buffer.indent_size_for_line(MultiBufferRow(start_point.row));\n                        indent.len = cmp::min(indent.len, start_point.column);\n                        let start = selection.start;\n                        let end = selection.end;\n                        let selection_is_empty = start == end;\n                        let language_scope = buffer.language_scope_at(start);\n                        let (comment_delimiter, insert_extra_newline) = if let Some(language) =\n                            &language_scope\n                        {\n                            let leading_whitespace_len = buffer\n                                .reversed_chars_at(start)\n                                .take_while(|c| c.is_whitespace() && *c != '\\n')\n                                .map(|c| c.len_utf8())\n                                .sum::<usize>();\n\n                            let trailing_whitespace_len = buffer\n                                .chars_at(end)\n                                .take_while(|c| c.is_whitespace() && *c != '\\n')\n                                .map(|c| c.len_utf8())\n                                .sum::<usize>();\n\n                            let insert_extra_newline =\n                                language.brackets().any(|(pair, enabled)| {\n                                    let pair_start = pair.start.trim_end();\n                                    let pair_end = pair.end.trim_start();\n\n                                    enabled\n                                        && pair.newline\n                                        && buffer.contains_str_at(\n                                            end + trailing_whitespace_len,\n                                            pair_end,\n                                        )\n                                        && buffer.contains_str_at(\n                                            (start - leading_whitespace_len)\n                                                .saturating_sub(pair_start.len()),\n                                            pair_start,\n                                        )\n                                });\n\n                            // Comment extension on newline is allowed only for cursor selections\n                            let comment_delimiter = maybe!({\n                                if !selection_is_empty {\n                                    return None;\n                                }\n\n                                if !multi_buffer.settings_at(0, cx).extend_comment_on_newline {\n                                    return None;\n                                }\n\n                                let delimiters = language.line_comment_prefixes();\n                                let max_len_of_delimiter =\n                                    delimiters.iter().map(|delimiter| delimiter.len()).max()?;\n                                let (snapshot, range) =\n                                    buffer.buffer_line_for_row(MultiBufferRow(start_point.row))?;\n\n                                let mut index_of_first_non_whitespace = 0;\n                                let comment_candidate = snapshot\n                                    .chars_for_range(range)\n                                    .skip_while(|c| {\n                                        let should_skip = c.is_whitespace();\n                                        if should_skip {\n                                            index_of_first_non_whitespace += 1;\n                                        }\n                                        should_skip\n                                    })\n                                    .take(max_len_of_delimiter)\n                                    .collect::<String>();\n                                let comment_prefix = delimiters.iter().find(|comment_prefix| {\n                                    comment_candidate.starts_with(comment_prefix.as_ref())\n                                })?;\n                                let cursor_is_placed_after_comment_marker =\n                                    index_of_first_non_whitespace + comment_prefix.len()\n                                        <= start_point.column as usize;\n                                if cursor_is_placed_after_comment_marker {\n                                    Some(comment_prefix.clone())\n                                } else {\n                                    None\n                                }\n                            });\n                            (comment_delimiter, insert_extra_newline)\n                        } else {\n                            (None, false)\n                        };\n\n                        let capacity_for_delimiter = comment_delimiter\n                            .as_deref()\n                            .map(str::len)\n                            .unwrap_or_default();\n                        let mut new_text =\n                            String::with_capacity(1 + capacity_for_delimiter + indent.len as usize);\n                        new_text.push('\\n');\n                        new_text.extend(indent.chars());\n                        if let Some(delimiter) = &comment_delimiter {\n                            new_text.push_str(delimiter);\n                        }\n                        if insert_extra_newline {\n                            new_text = new_text.repeat(2);\n                        }\n\n                        let anchor = buffer.anchor_after(end);\n                        let new_selection = selection.map(|_| anchor);\n                        (\n                            (start..end, new_text),\n                            (insert_extra_newline, new_selection),\n                        )\n                    })\n                    .unzip()\n            };\n\n            this.edit_with_autoindent(edits, cx);\n            let buffer = this.buffer.read(cx).snapshot(cx);\n            let new_selections = selection_fixup_info\n                .into_iter()\n                .map(|(extra_newline_inserted, new_selection)| {\n                    let mut cursor = new_selection.end.to_point(&buffer);\n                    if extra_newline_inserted {\n                        cursor.row -= 1;\n                        cursor.column = buffer.line_len(MultiBufferRow(cursor.row));\n                    }\n                    new_selection.map(|_| cursor)\n                })\n                .collect();\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections)\n            });\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    pub fn newline_above(&mut self, _: &NewlineAbove, window: &mut Window, cx: &mut Context<Self>) {\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut rows = Vec::new();\n\n        for (rows_inserted, selection) in self.selections.all_adjusted(cx).into_iter().enumerate() {\n            let cursor = selection.head();\n            let row = cursor.row;\n\n            let start_of_line = snapshot.clip_point(Point::new(row, 0), Bias::Left);\n\n            let newline = \"\\n\".to_string();\n            edits.push((start_of_line..start_of_line, newline));\n\n            rows.push(row + rows_inserted as u32);\n        }\n\n        self.transact(window, cx, |editor, window, cx| {\n            editor.edit(edits, cx);\n\n            editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let mut index = 0;\n                s.move_cursors_with(|map, _, _| {\n                    let row = rows[index];\n                    index += 1;\n\n                    let point = Point::new(row, 0);\n                    let boundary = map.next_line_boundary(point).1;\n                    let clipped = map.clip_point(boundary, Bias::Left);\n\n                    (clipped, SelectionGoal::None)\n                });\n            });\n\n            let mut indent_edits = Vec::new();\n            let multibuffer_snapshot = editor.buffer.read(cx).snapshot(cx);\n            for row in rows {\n                let indents = multibuffer_snapshot.suggested_indents(row..row + 1, cx);\n                for (row, indent) in indents {\n                    if indent.len == 0 {\n                        continue;\n                    }\n\n                    let text = match indent.kind {\n                        IndentKind::Space => \" \".repeat(indent.len as usize),\n                        IndentKind::Tab => \"\\t\".repeat(indent.len as usize),\n                    };\n                    let point = Point::new(row.0, 0);\n                    indent_edits.push((point..point, text));\n                }\n            }\n            editor.edit(indent_edits, cx);\n        });\n    }\n\n    pub fn newline_below(&mut self, _: &NewlineBelow, window: &mut Window, cx: &mut Context<Self>) {\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut rows = Vec::new();\n        let mut rows_inserted = 0;\n\n        for selection in self.selections.all_adjusted(cx) {\n            let cursor = selection.head();\n            let row = cursor.row;\n\n            let point = Point::new(row + 1, 0);\n            let start_of_line = snapshot.clip_point(point, Bias::Left);\n\n            let newline = \"\\n\".to_string();\n            edits.push((start_of_line..start_of_line, newline));\n\n            rows_inserted += 1;\n            rows.push(row + rows_inserted);\n        }\n\n        self.transact(window, cx, |editor, window, cx| {\n            editor.edit(edits, cx);\n\n            editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let mut index = 0;\n                s.move_cursors_with(|map, _, _| {\n                    let row = rows[index];\n                    index += 1;\n\n                    let point = Point::new(row, 0);\n                    let boundary = map.next_line_boundary(point).1;\n                    let clipped = map.clip_point(boundary, Bias::Left);\n\n                    (clipped, SelectionGoal::None)\n                });\n            });\n\n            let mut indent_edits = Vec::new();\n            let multibuffer_snapshot = editor.buffer.read(cx).snapshot(cx);\n            for row in rows {\n                let indents = multibuffer_snapshot.suggested_indents(row..row + 1, cx);\n                for (row, indent) in indents {\n                    if indent.len == 0 {\n                        continue;\n                    }\n\n                    let text = match indent.kind {\n                        IndentKind::Space => \" \".repeat(indent.len as usize),\n                        IndentKind::Tab => \"\\t\".repeat(indent.len as usize),\n                    };\n                    let point = Point::new(row.0, 0);\n                    indent_edits.push((point..point, text));\n                }\n            }\n            editor.edit(indent_edits, cx);\n        });\n    }\n\n    pub fn insert(&mut self, text: &str, window: &mut Window, cx: &mut Context<Self>) {\n        let autoindent = text.is_empty().not().then(|| AutoindentMode::Block {\n            original_indent_columns: Vec::new(),\n        });\n        self.insert_with_autoindent_mode(text, autoindent, window, cx);\n    }\n\n    fn insert_with_autoindent_mode(\n        &mut self,\n        text: &str,\n        autoindent_mode: Option<AutoindentMode>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        let text: Arc<str> = text.into();\n        self.transact(window, cx, |this, window, cx| {\n            let old_selections = this.selections.all_adjusted(cx);\n            let selection_anchors = this.buffer.update(cx, |buffer, cx| {\n                let anchors = {\n                    let snapshot = buffer.read(cx);\n                    old_selections\n                        .iter()\n                        .map(|s| {\n                            let anchor = snapshot.anchor_after(s.head());\n                            s.map(|_| anchor)\n                        })\n                        .collect::<Vec<_>>()\n                };\n                buffer.edit(\n                    old_selections\n                        .iter()\n                        .map(|s| (s.start..s.end, text.clone())),\n                    autoindent_mode,\n                    cx,\n                );\n                anchors\n            });\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select_anchors(selection_anchors);\n            });\n\n            cx.notify();\n        });\n    }\n\n    fn trigger_completion_on_input(\n        &mut self,\n        text: &str,\n        trigger_in_words: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.is_completion_trigger(text, trigger_in_words, cx) {\n            self.show_completions(\n                &ShowCompletions {\n                    trigger: Some(text.to_owned()).filter(|x| !x.is_empty()),\n                },\n                window,\n                cx,\n            );\n        } else {\n            self.hide_context_menu(window, cx);\n        }\n    }\n\n    fn is_completion_trigger(\n        &self,\n        text: &str,\n        trigger_in_words: bool,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        let position = self.selections.newest_anchor().head();\n        let multibuffer = self.buffer.read(cx);\n        let Some(buffer) = position\n            .buffer_id\n            .and_then(|buffer_id| multibuffer.buffer(buffer_id).clone())\n        else {\n            return false;\n        };\n\n        if let Some(completion_provider) = &self.completion_provider {\n            completion_provider.is_completion_trigger(\n                &buffer,\n                position.text_anchor,\n                text,\n                trigger_in_words,\n                cx,\n            )\n        } else {\n            false\n        }\n    }\n\n    /// If any empty selections is touching the start of its innermost containing autoclose\n    /// region, expand it to select the brackets.\n    fn select_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let selections = self.selections.all::<usize>(cx);\n        let buffer = self.buffer.read(cx).read(cx);\n        let new_selections = self\n            .selections_with_autoclose_regions(selections, &buffer)\n            .map(|(mut selection, region)| {\n                if !selection.is_empty() {\n                    return selection;\n                }\n\n                if let Some(region) = region {\n                    let mut range = region.range.to_offset(&buffer);\n                    if selection.start == range.start && range.start >= region.pair.start.len() {\n                        range.start -= region.pair.start.len();\n                        if buffer.contains_str_at(range.start, &region.pair.start)\n                            && buffer.contains_str_at(range.end, &region.pair.end)\n                        {\n                            range.end += region.pair.end.len();\n                            selection.start = range.start;\n                            selection.end = range.end;\n\n                            return selection;\n                        }\n                    }\n                }\n\n                let always_treat_brackets_as_autoclosed = buffer\n                    .settings_at(selection.start, cx)\n                    .always_treat_brackets_as_autoclosed;\n\n                if !always_treat_brackets_as_autoclosed {\n                    return selection;\n                }\n\n                if let Some(scope) = buffer.language_scope_at(selection.start) {\n                    for (pair, enabled) in scope.brackets() {\n                        if !enabled || !pair.close {\n                            continue;\n                        }\n\n                        if buffer.contains_str_at(selection.start, &pair.end) {\n                            let pair_start_len = pair.start.len();\n                            if buffer.contains_str_at(\n                                selection.start.saturating_sub(pair_start_len),\n                                &pair.start,\n                            ) {\n                                selection.start -= pair_start_len;\n                                selection.end += pair.end.len();\n\n                                return selection;\n                            }\n                        }\n                    }\n                }\n\n                selection\n            })\n            .collect();\n\n        drop(buffer);\n        self.change_selections(None, window, cx, |selections| {\n            selections.select(new_selections)\n        });\n    }\n\n    /// Iterate the given selections, and for each one, find the smallest surrounding\n    /// autoclose region. This uses the ordering of the selections and the autoclose\n    /// regions to avoid repeated comparisons.\n    fn selections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n        &'a self,\n        selections: impl IntoIterator<Item = Selection<D>>,\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl Iterator<Item = (Selection<D>, Option<&'a AutocloseRegion>)> {\n        let mut i = 0;\n        let mut regions = self.autoclose_regions.as_slice();\n        selections.into_iter().map(move |selection| {\n            let range = selection.start.to_offset(buffer)..selection.end.to_offset(buffer);\n\n            let mut enclosing = None;\n            while let Some(pair_state) = regions.get(i) {\n                if pair_state.range.end.to_offset(buffer) < range.start {\n                    regions = &regions[i + 1..];\n                    i = 0;\n                } else if pair_state.range.start.to_offset(buffer) > range.end {\n                    break;\n                } else {\n                    if pair_state.selection_id == selection.id {\n                        enclosing = Some(pair_state);\n                    }\n                    i += 1;\n                }\n            }\n\n            (selection, enclosing)\n        })\n    }\n\n    /// Remove any autoclose regions that no longer contain their selection.\n    fn invalidate_autoclose_regions(\n        &mut self,\n        mut selections: &[Selection<Anchor>],\n        buffer: &MultiBufferSnapshot,\n    ) {\n        self.autoclose_regions.retain(|state| {\n            let mut i = 0;\n            while let Some(selection) = selections.get(i) {\n                if selection.end.cmp(&state.range.start, buffer).is_lt() {\n                    selections = &selections[1..];\n                    continue;\n                }\n                if selection.start.cmp(&state.range.end, buffer).is_gt() {\n                    break;\n                }\n                if selection.id == state.selection_id {\n                    return true;\n                } else {\n                    i += 1;\n                }\n            }\n            false\n        });\n    }\n\n    fn completion_query(buffer: &MultiBufferSnapshot, position: impl ToOffset) -> Option<String> {\n        let offset = position.to_offset(buffer);\n        let (word_range, kind) = buffer.surrounding_word(offset, true);\n        if offset > word_range.start && kind == Some(CharKind::Word) {\n            Some(\n                buffer\n                    .text_for_range(word_range.start..offset)\n                    .collect::<String>(),\n            )\n        } else {\n            None\n        }\n    }\n\n    pub fn toggle_inlay_hints(\n        &mut self,\n        _: &ToggleInlayHints,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.refresh_inlay_hints(\n            InlayHintRefreshReason::Toggle(!self.inlay_hint_cache.enabled),\n            cx,\n        );\n    }\n\n    pub fn inlay_hints_enabled(&self) -> bool {\n        self.inlay_hint_cache.enabled\n    }\n\n    fn refresh_inlay_hints(&mut self, reason: InlayHintRefreshReason, cx: &mut Context<Self>) {\n        if self.semantics_provider.is_none() || self.mode != EditorMode::Full {\n            return;\n        }\n\n        let reason_description = reason.description();\n        let ignore_debounce = matches!(\n            reason,\n            InlayHintRefreshReason::SettingsChange(_)\n                | InlayHintRefreshReason::Toggle(_)\n                | InlayHintRefreshReason::ExcerptsRemoved(_)\n        );\n        let (invalidate_cache, required_languages) = match reason {\n            InlayHintRefreshReason::Toggle(enabled) => {\n                self.inlay_hint_cache.enabled = enabled;\n                if enabled {\n                    (InvalidationStrategy::RefreshRequested, None)\n                } else {\n                    self.inlay_hint_cache.clear();\n                    self.splice_inlays(\n                        &self\n                            .visible_inlay_hints(cx)\n                            .iter()\n                            .map(|inlay| inlay.id)\n                            .collect::<Vec<InlayId>>(),\n                        Vec::new(),\n                        cx,\n                    );\n                    return;\n                }\n            }\n            InlayHintRefreshReason::SettingsChange(new_settings) => {\n                match self.inlay_hint_cache.update_settings(\n                    &self.buffer,\n                    new_settings,\n                    self.visible_inlay_hints(cx),\n                    cx,\n                ) {\n                    ControlFlow::Break(Some(InlaySplice {\n                        to_remove,\n                        to_insert,\n                    })) => {\n                        self.splice_inlays(&to_remove, to_insert, cx);\n                        return;\n                    }\n                    ControlFlow::Break(None) => return,\n                    ControlFlow::Continue(()) => (InvalidationStrategy::RefreshRequested, None),\n                }\n            }\n            InlayHintRefreshReason::ExcerptsRemoved(excerpts_removed) => {\n                if let Some(InlaySplice {\n                    to_remove,\n                    to_insert,\n                }) = self.inlay_hint_cache.remove_excerpts(excerpts_removed)\n                {\n                    self.splice_inlays(&to_remove, to_insert, cx);\n                }\n                return;\n            }\n            InlayHintRefreshReason::NewLinesShown => (InvalidationStrategy::None, None),\n            InlayHintRefreshReason::BufferEdited(buffer_languages) => {\n                (InvalidationStrategy::BufferEdited, Some(buffer_languages))\n            }\n            InlayHintRefreshReason::RefreshRequested => {\n                (InvalidationStrategy::RefreshRequested, None)\n            }\n        };\n\n        if let Some(InlaySplice {\n            to_remove,\n            to_insert,\n        }) = self.inlay_hint_cache.spawn_hint_refresh(\n            reason_description,\n            self.excerpts_for_inlay_hints_query(required_languages.as_ref(), cx),\n            invalidate_cache,\n            ignore_debounce,\n            cx,\n        ) {\n            self.splice_inlays(&to_remove, to_insert, cx);\n        }\n    }\n\n    fn visible_inlay_hints(&self, cx: &Context<Editor>) -> Vec<Inlay> {\n        self.display_map\n            .read(cx)\n            .current_inlays()\n            .filter(move |inlay| matches!(inlay.id, InlayId::Hint(_)))\n            .cloned()\n            .collect()\n    }\n\n    pub fn excerpts_for_inlay_hints_query(\n        &self,\n        restrict_to_languages: Option<&HashSet<Arc<Language>>>,\n        cx: &mut Context<Editor>,\n    ) -> HashMap<ExcerptId, (Entity<Buffer>, clock::Global, Range<usize>)> {\n        let Some(project) = self.project.as_ref() else {\n            return HashMap::default();\n        };\n        let project = project.read(cx);\n        let multi_buffer = self.buffer().read(cx);\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let multi_buffer_visible_start = self\n            .scroll_manager\n            .anchor()\n            .anchor\n            .to_point(&multi_buffer_snapshot);\n        let multi_buffer_visible_end = multi_buffer_snapshot.clip_point(\n            multi_buffer_visible_start\n                + Point::new(self.visible_line_count().unwrap_or(0.).ceil() as u32, 0),\n            Bias::Left,\n        );\n        let multi_buffer_visible_range = multi_buffer_visible_start..multi_buffer_visible_end;\n        multi_buffer_snapshot\n            .range_to_buffer_ranges(multi_buffer_visible_range)\n            .into_iter()\n            .filter(|(_, excerpt_visible_range, _)| !excerpt_visible_range.is_empty())\n            .filter_map(|(buffer, excerpt_visible_range, excerpt_id)| {\n                let buffer_file = project::File::from_dyn(buffer.file())?;\n                let buffer_worktree = project.worktree_for_id(buffer_file.worktree_id(cx), cx)?;\n                let worktree_entry = buffer_worktree\n                    .read(cx)\n                    .entry_for_id(buffer_file.project_entry_id(cx)?)?;\n                if worktree_entry.is_ignored {\n                    return None;\n                }\n\n                let language = buffer.language()?;\n                if let Some(restrict_to_languages) = restrict_to_languages {\n                    if !restrict_to_languages.contains(language) {\n                        return None;\n                    }\n                }\n                Some((\n                    excerpt_id,\n                    (\n                        multi_buffer.buffer(buffer.remote_id()).unwrap(),\n                        buffer.version().clone(),\n                        excerpt_visible_range,\n                    ),\n                ))\n            })\n            .collect()\n    }\n\n    pub fn text_layout_details(&self, window: &mut Window) -> TextLayoutDetails {\n        TextLayoutDetails {\n            text_system: window.text_system().clone(),\n            editor_style: self.style.clone().unwrap(),\n            rem_size: window.rem_size(),\n            scroll_anchor: self.scroll_manager.anchor(),\n            visible_rows: self.visible_line_count(),\n            vertical_scroll_margin: self.scroll_manager.vertical_scroll_margin,\n        }\n    }\n\n    pub fn splice_inlays(\n        &self,\n        to_remove: &[InlayId],\n        to_insert: Vec<Inlay>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.splice_inlays(to_remove, to_insert, cx)\n        });\n        cx.notify();\n    }\n\n    fn trigger_on_type_formatting(\n        &self,\n        input: String,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        if input.len() != 1 {\n            return None;\n        }\n\n        let project = self.project.as_ref()?;\n        let position = self.selections.newest_anchor().head();\n        let (buffer, buffer_position) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(position, cx)?;\n\n        let settings = language_settings::language_settings(\n            buffer\n                .read(cx)\n                .language_at(buffer_position)\n                .map(|l| l.name()),\n            buffer.read(cx).file(),\n            cx,\n        );\n        if !settings.use_on_type_format {\n            return None;\n        }\n\n        // OnTypeFormatting returns a list of edits, no need to pass them between Zed instances,\n        // hence we do LSP request & edit on host side only — add formats to host's history.\n        let push_to_lsp_host_history = true;\n        // If this is not the host, append its history with new edits.\n        let push_to_client_history = project.read(cx).is_via_collab();\n\n        let on_type_formatting = project.update(cx, |project, cx| {\n            project.on_type_format(\n                buffer.clone(),\n                buffer_position,\n                input,\n                push_to_lsp_host_history,\n                cx,\n            )\n        });\n        Some(cx.spawn_in(window, |editor, mut cx| async move {\n            if let Some(transaction) = on_type_formatting.await? {\n                if push_to_client_history {\n                    buffer\n                        .update(&mut cx, |buffer, _| {\n                            buffer.push_transaction(transaction, Instant::now());\n                        })\n                        .ok();\n                }\n                editor.update(&mut cx, |editor, cx| {\n                    editor.refresh_document_highlights(cx);\n                })?;\n            }\n            Ok(())\n        }))\n    }\n\n    pub fn show_completions(\n        &mut self,\n        options: &ShowCompletions,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.pending_rename.is_some() {\n            return;\n        }\n\n        let Some(provider) = self.completion_provider.as_ref() else {\n            return;\n        };\n\n        if !self.snippet_stack.is_empty() && self.context_menu.borrow().as_ref().is_some() {\n            return;\n        }\n\n        let position = self.selections.newest_anchor().head();\n        if position.diff_base_anchor.is_some() {\n            return;\n        }\n        let (buffer, buffer_position) =\n            if let Some(output) = self.buffer.read(cx).text_anchor_for_position(position, cx) {\n                output\n            } else {\n                return;\n            };\n        let show_completion_documentation = buffer\n            .read(cx)\n            .snapshot()\n            .settings_at(buffer_position, cx)\n            .show_completion_documentation;\n\n        let query = Self::completion_query(&self.buffer.read(cx).read(cx), position);\n\n        let trigger_kind = match &options.trigger {\n            Some(trigger) if buffer.read(cx).completion_triggers().contains(trigger) => {\n                CompletionTriggerKind::TRIGGER_CHARACTER\n            }\n            _ => CompletionTriggerKind::INVOKED,\n        };\n        let completion_context = CompletionContext {\n            trigger_character: options.trigger.as_ref().and_then(|trigger| {\n                if trigger_kind == CompletionTriggerKind::TRIGGER_CHARACTER {\n                    Some(String::from(trigger))\n                } else {\n                    None\n                }\n            }),\n            trigger_kind,\n        };\n        let completions =\n            provider.completions(&buffer, buffer_position, completion_context, window, cx);\n        let sort_completions = provider.sort_completions();\n\n        let id = post_inc(&mut self.next_completion_id);\n        let task = cx.spawn_in(window, |editor, mut cx| {\n            async move {\n                editor.update(&mut cx, |this, _| {\n                    this.completion_tasks.retain(|(task_id, _)| *task_id >= id);\n                })?;\n                let completions = completions.await.log_err();\n                let menu = if let Some(completions) = completions {\n                    let mut menu = CompletionsMenu::new(\n                        id,\n                        sort_completions,\n                        show_completion_documentation,\n                        position,\n                        buffer.clone(),\n                        completions.into(),\n                    );\n\n                    menu.filter(query.as_deref(), cx.background_executor().clone())\n                        .await;\n\n                    menu.visible().then_some(menu)\n                } else {\n                    None\n                };\n\n                editor.update_in(&mut cx, |editor, window, cx| {\n                    match editor.context_menu.borrow().as_ref() {\n                        None => {}\n                        Some(CodeContextMenu::Completions(prev_menu)) => {\n                            if prev_menu.id > id {\n                                return;\n                            }\n                        }\n                        _ => return,\n                    }\n\n                    if editor.focus_handle.is_focused(window) && menu.is_some() {\n                        let mut menu = menu.unwrap();\n                        menu.resolve_visible_completions(editor.completion_provider.as_deref(), cx);\n\n                        *editor.context_menu.borrow_mut() =\n                            Some(CodeContextMenu::Completions(menu));\n\n                        if editor.show_edit_predictions_in_menu() {\n                            editor.update_visible_inline_completion(window, cx);\n                        } else {\n                            editor.discard_inline_completion(false, cx);\n                        }\n\n                        cx.notify();\n                    } else if editor.completion_tasks.len() <= 1 {\n                        // If there are no more completion tasks and the last menu was\n                        // empty, we should hide it.\n                        let was_hidden = editor.hide_context_menu(window, cx).is_none();\n                        // If it was already hidden and we don't show inline\n                        // completions in the menu, we should also show the\n                        // inline-completion when available.\n                        if was_hidden && editor.show_edit_predictions_in_menu() {\n                            editor.update_visible_inline_completion(window, cx);\n                        }\n                    }\n                })?;\n\n                Ok::<_, anyhow::Error>(())\n            }\n            .log_err()\n        });\n\n        self.completion_tasks.push((id, task));\n    }\n\n    pub fn confirm_completion(\n        &mut self,\n        action: &ConfirmCompletion,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.do_completion(action.item_ix, CompletionIntent::Complete, window, cx)\n    }\n\n    pub fn compose_completion(\n        &mut self,\n        action: &ComposeCompletion,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        self.do_completion(action.item_ix, CompletionIntent::Compose, window, cx)\n    }\n\n    fn do_completion(\n        &mut self,\n        item_ix: Option<usize>,\n        intent: CompletionIntent,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<Task<std::result::Result<(), anyhow::Error>>> {\n        use language::ToOffset as _;\n\n        let completions_menu =\n            if let CodeContextMenu::Completions(menu) = self.hide_context_menu(window, cx)? {\n                menu\n            } else {\n                return None;\n            };\n\n        let entries = completions_menu.entries.borrow();\n        let mat = entries.get(item_ix.unwrap_or(completions_menu.selected_item))?;\n        if self.show_edit_predictions_in_menu() {\n            self.discard_inline_completion(true, cx);\n        }\n        let candidate_id = mat.candidate_id;\n        drop(entries);\n\n        let buffer_handle = completions_menu.buffer;\n        let completion = completions_menu\n            .completions\n            .borrow()\n            .get(candidate_id)?\n            .clone();\n        cx.stop_propagation();\n\n        let snippet;\n        let text;\n\n        if completion.is_snippet() {\n            snippet = Some(Snippet::parse(&completion.new_text).log_err()?);\n            text = snippet.as_ref().unwrap().text.clone();\n        } else {\n            snippet = None;\n            text = completion.new_text.clone();\n        };\n        let selections = self.selections.all::<usize>(cx);\n        let buffer = buffer_handle.read(cx);\n        let old_range = completion.old_range.to_offset(buffer);\n        let old_text = buffer.text_for_range(old_range.clone()).collect::<String>();\n\n        let newest_selection = self.selections.newest_anchor();\n        if newest_selection.start.buffer_id != Some(buffer_handle.read(cx).remote_id()) {\n            return None;\n        }\n\n        let lookbehind = newest_selection\n            .start\n            .text_anchor\n            .to_offset(buffer)\n            .saturating_sub(old_range.start);\n        let lookahead = old_range\n            .end\n            .saturating_sub(newest_selection.end.text_anchor.to_offset(buffer));\n        let mut common_prefix_len = old_text\n            .bytes()\n            .zip(text.bytes())\n            .take_while(|(a, b)| a == b)\n            .count();\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut range_to_replace: Option<Range<isize>> = None;\n        let mut ranges = Vec::new();\n        let mut linked_edits = HashMap::<_, Vec<_>>::default();\n        for selection in &selections {\n            if snapshot.contains_str_at(selection.start.saturating_sub(lookbehind), &old_text) {\n                let start = selection.start.saturating_sub(lookbehind);\n                let end = selection.end + lookahead;\n                if selection.id == newest_selection.id {\n                    range_to_replace = Some(\n                        ((start + common_prefix_len) as isize - selection.start as isize)\n                            ..(end as isize - selection.start as isize),\n                    );\n                }\n                ranges.push(start + common_prefix_len..end);\n            } else {\n                common_prefix_len = 0;\n                ranges.clear();\n                ranges.extend(selections.iter().map(|s| {\n                    if s.id == newest_selection.id {\n                        range_to_replace = Some(\n                            old_range.start.to_offset_utf16(&snapshot).0 as isize\n                                - selection.start as isize\n                                ..old_range.end.to_offset_utf16(&snapshot).0 as isize\n                                    - selection.start as isize,\n                        );\n                        old_range.clone()\n                    } else {\n                        s.start..s.end\n                    }\n                }));\n                break;\n            }\n            if !self.linked_edit_ranges.is_empty() {\n                let start_anchor = snapshot.anchor_before(selection.head());\n                let end_anchor = snapshot.anchor_after(selection.tail());\n                if let Some(ranges) = self\n                    .linked_editing_ranges_for(start_anchor.text_anchor..end_anchor.text_anchor, cx)\n                {\n                    for (buffer, edits) in ranges {\n                        linked_edits.entry(buffer.clone()).or_default().extend(\n                            edits\n                                .into_iter()\n                                .map(|range| (range, text[common_prefix_len..].to_owned())),\n                        );\n                    }\n                }\n            }\n        }\n        let text = &text[common_prefix_len..];\n\n        cx.emit(EditorEvent::InputHandled {\n            utf16_range_to_replace: range_to_replace,\n            text: text.into(),\n        });\n\n        self.transact(window, cx, |this, window, cx| {\n            if let Some(mut snippet) = snippet {\n                snippet.text = text.to_string();\n                for tabstop in snippet\n                    .tabstops\n                    .iter_mut()\n                    .flat_map(|tabstop| tabstop.ranges.iter_mut())\n                {\n                    tabstop.start -= common_prefix_len as isize;\n                    tabstop.end -= common_prefix_len as isize;\n                }\n\n                this.insert_snippet(&ranges, snippet, window, cx).log_err();\n            } else {\n                this.buffer.update(cx, |buffer, cx| {\n                    buffer.edit(\n                        ranges.iter().map(|range| (range.clone(), text)),\n                        this.autoindent_mode.clone(),\n                        cx,\n                    );\n                });\n            }\n            for (buffer, edits) in linked_edits {\n                buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.snapshot();\n                    let edits = edits\n                        .into_iter()\n                        .map(|(range, text)| {\n                            use text::ToPoint as TP;\n                            let end_point = TP::to_point(&range.end, &snapshot);\n                            let start_point = TP::to_point(&range.start, &snapshot);\n                            (start_point..end_point, text)\n                        })\n                        .sorted_by_key(|(range, _)| range.start)\n                        .collect::<Vec<_>>();\n                    buffer.edit(edits, None, cx);\n                })\n            }\n\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n\n        let show_new_completions_on_confirm = completion\n            .confirm\n            .as_ref()\n            .map_or(false, |confirm| confirm(intent, window, cx));\n        if show_new_completions_on_confirm {\n            self.show_completions(&ShowCompletions { trigger: None }, window, cx);\n        }\n\n        let provider = self.completion_provider.as_ref()?;\n        drop(completion);\n        let apply_edits = provider.apply_additional_edits_for_completion(\n            buffer_handle,\n            completions_menu.completions.clone(),\n            candidate_id,\n            true,\n            cx,\n        );\n\n        let editor_settings = EditorSettings::get_global(cx);\n        if editor_settings.show_signature_help_after_edits || editor_settings.auto_signature_help {\n            // After the code completion is finished, users often want to know what signatures are needed.\n            // so we should automatically call signature_help\n            self.show_signature_help(&ShowSignatureHelp, window, cx);\n        }\n\n        Some(cx.foreground_executor().spawn(async move {\n            apply_edits.await?;\n            Ok(())\n        }))\n    }\n\n    pub fn toggle_code_actions(\n        &mut self,\n        action: &ToggleCodeActions,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut context_menu = self.context_menu.borrow_mut();\n        if let Some(CodeContextMenu::CodeActions(code_actions)) = context_menu.as_ref() {\n            if code_actions.deployed_from_indicator == action.deployed_from_indicator {\n                // Toggle if we're selecting the same one\n                *context_menu = None;\n                cx.notify();\n                return;\n            } else {\n                // Otherwise, clear it and start a new one\n                *context_menu = None;\n                cx.notify();\n            }\n        }\n        drop(context_menu);\n        let snapshot = self.snapshot(window, cx);\n        let deployed_from_indicator = action.deployed_from_indicator;\n        let mut task = self.code_actions_task.take();\n        let action = action.clone();\n        cx.spawn_in(window, |editor, mut cx| async move {\n            while let Some(prev_task) = task {\n                prev_task.await.log_err();\n                task = editor.update(&mut cx, |this, _| this.code_actions_task.take())?;\n            }\n\n            let spawned_test_task = editor.update_in(&mut cx, |editor, window, cx| {\n                if editor.focus_handle.is_focused(window) {\n                    let multibuffer_point = action\n                        .deployed_from_indicator\n                        .map(|row| DisplayPoint::new(row, 0).to_point(&snapshot))\n                        .unwrap_or_else(|| editor.selections.newest::<Point>(cx).head());\n                    let (buffer, buffer_row) = snapshot\n                        .buffer_snapshot\n                        .buffer_line_for_row(MultiBufferRow(multibuffer_point.row))\n                        .and_then(|(buffer_snapshot, range)| {\n                            editor\n                                .buffer\n                                .read(cx)\n                                .buffer(buffer_snapshot.remote_id())\n                                .map(|buffer| (buffer, range.start.row))\n                        })?;\n                    let (_, code_actions) = editor\n                        .available_code_actions\n                        .clone()\n                        .and_then(|(location, code_actions)| {\n                            let snapshot = location.buffer.read(cx).snapshot();\n                            let point_range = location.range.to_point(&snapshot);\n                            let point_range = point_range.start.row..=point_range.end.row;\n                            if point_range.contains(&buffer_row) {\n                                Some((location, code_actions))\n                            } else {\n                                None\n                            }\n                        })\n                        .unzip();\n                    let buffer_id = buffer.read(cx).remote_id();\n                    let tasks = editor\n                        .tasks\n                        .get(&(buffer_id, buffer_row))\n                        .map(|t| Arc::new(t.to_owned()));\n                    if tasks.is_none() && code_actions.is_none() {\n                        return None;\n                    }\n\n                    editor.completion_tasks.clear();\n                    editor.discard_inline_completion(false, cx);\n                    let task_context =\n                        tasks\n                            .as_ref()\n                            .zip(editor.project.clone())\n                            .map(|(tasks, project)| {\n                                Self::build_tasks_context(&project, &buffer, buffer_row, tasks, cx)\n                            });\n\n                    Some(cx.spawn_in(window, |editor, mut cx| async move {\n                        let task_context = match task_context {\n                            Some(task_context) => task_context.await,\n                            None => None,\n                        };\n                        let resolved_tasks =\n                            tasks.zip(task_context).map(|(tasks, task_context)| {\n                                Rc::new(ResolvedTasks {\n                                    templates: tasks.resolve(&task_context).collect(),\n                                    position: snapshot.buffer_snapshot.anchor_before(Point::new(\n                                        multibuffer_point.row,\n                                        tasks.column,\n                                    )),\n                                })\n                            });\n                        let spawn_straight_away = resolved_tasks\n                            .as_ref()\n                            .map_or(false, |tasks| tasks.templates.len() == 1)\n                            && code_actions\n                                .as_ref()\n                                .map_or(true, |actions| actions.is_empty());\n                        if let Ok(task) = editor.update_in(&mut cx, |editor, window, cx| {\n                            *editor.context_menu.borrow_mut() =\n                                Some(CodeContextMenu::CodeActions(CodeActionsMenu {\n                                    buffer,\n                                    actions: CodeActionContents {\n                                        tasks: resolved_tasks,\n                                        actions: code_actions,\n                                    },\n                                    selected_item: Default::default(),\n                                    scroll_handle: UniformListScrollHandle::default(),\n                                    deployed_from_indicator,\n                                }));\n                            if spawn_straight_away {\n                                if let Some(task) = editor.confirm_code_action(\n                                    &ConfirmCodeAction { item_ix: Some(0) },\n                                    window,\n                                    cx,\n                                ) {\n                                    cx.notify();\n                                    return task;\n                                }\n                            }\n                            cx.notify();\n                            Task::ready(Ok(()))\n                        }) {\n                            task.await\n                        } else {\n                            Ok(())\n                        }\n                    }))\n                } else {\n                    Some(Task::ready(Ok(())))\n                }\n            })?;\n            if let Some(task) = spawned_test_task {\n                task.await?;\n            }\n\n            Ok::<_, anyhow::Error>(())\n        })\n        .detach_and_log_err(cx);\n    }\n\n    pub fn confirm_code_action(\n        &mut self,\n        action: &ConfirmCodeAction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let actions_menu =\n            if let CodeContextMenu::CodeActions(menu) = self.hide_context_menu(window, cx)? {\n                menu\n            } else {\n                return None;\n            };\n        let action_ix = action.item_ix.unwrap_or(actions_menu.selected_item);\n        let action = actions_menu.actions.get(action_ix)?;\n        let title = action.label();\n        let buffer = actions_menu.buffer;\n        let workspace = self.workspace()?;\n\n        match action {\n            CodeActionsItem::Task(task_source_kind, resolved_task) => {\n                workspace.update(cx, |workspace, cx| {\n                    workspace::tasks::schedule_resolved_task(\n                        workspace,\n                        task_source_kind,\n                        resolved_task,\n                        false,\n                        cx,\n                    );\n\n                    Some(Task::ready(Ok(())))\n                })\n            }\n            CodeActionsItem::CodeAction {\n                excerpt_id,\n                action,\n                provider,\n            } => {\n                let apply_code_action =\n                    provider.apply_code_action(buffer, action, excerpt_id, true, window, cx);\n                let workspace = workspace.downgrade();\n                Some(cx.spawn_in(window, |editor, cx| async move {\n                    let project_transaction = apply_code_action.await?;\n                    Self::open_project_transaction(\n                        &editor,\n                        workspace,\n                        project_transaction,\n                        title,\n                        cx,\n                    )\n                    .await\n                }))\n            }\n        }\n    }\n\n    pub async fn open_project_transaction(\n        this: &WeakEntity<Editor>,\n        workspace: WeakEntity<Workspace>,\n        transaction: ProjectTransaction,\n        title: String,\n        mut cx: AsyncWindowContext,\n    ) -> Result<()> {\n        let mut entries = transaction.0.into_iter().collect::<Vec<_>>();\n        cx.update(|_, cx| {\n            entries.sort_unstable_by_key(|(buffer, _)| {\n                buffer.read(cx).file().map(|f| f.path().clone())\n            });\n        })?;\n\n        // If the project transaction's edits are all contained within this editor, then\n        // avoid opening a new editor to display them.\n\n        if let Some((buffer, transaction)) = entries.first() {\n            if entries.len() == 1 {\n                let excerpt = this.update(&mut cx, |editor, cx| {\n                    editor\n                        .buffer()\n                        .read(cx)\n                        .excerpt_containing(editor.selections.newest_anchor().head(), cx)\n                })?;\n                if let Some((_, excerpted_buffer, excerpt_range)) = excerpt {\n                    if excerpted_buffer == *buffer {\n                        let all_edits_within_excerpt = buffer.read_with(&cx, |buffer, _| {\n                            let excerpt_range = excerpt_range.to_offset(buffer);\n                            buffer\n                                .edited_ranges_for_transaction::<usize>(transaction)\n                                .all(|range| {\n                                    excerpt_range.start <= range.start\n                                        && excerpt_range.end >= range.end\n                                })\n                        })?;\n\n                        if all_edits_within_excerpt {\n                            return Ok(());\n                        }\n                    }\n                }\n            }\n        } else {\n            return Ok(());\n        }\n\n        let mut ranges_to_highlight = Vec::new();\n        let excerpt_buffer = cx.new(|cx| {\n            let mut multibuffer = MultiBuffer::new(Capability::ReadWrite).with_title(title);\n            for (buffer_handle, transaction) in &entries {\n                let buffer = buffer_handle.read(cx);\n                ranges_to_highlight.extend(\n                    multibuffer.push_excerpts_with_context_lines(\n                        buffer_handle.clone(),\n                        buffer\n                            .edited_ranges_for_transaction::<usize>(transaction)\n                            .collect(),\n                        DEFAULT_MULTIBUFFER_CONTEXT,\n                        cx,\n                    ),\n                );\n            }\n            multibuffer.push_transaction(entries.iter().map(|(b, t)| (b, t)), cx);\n            multibuffer\n        })?;\n\n        workspace.update_in(&mut cx, |workspace, window, cx| {\n            let project = workspace.project().clone();\n            let editor = cx\n                .new(|cx| Editor::for_multibuffer(excerpt_buffer, Some(project), true, window, cx));\n            workspace.add_item_to_active_pane(Box::new(editor.clone()), None, true, window, cx);\n            editor.update(cx, |editor, cx| {\n                editor.highlight_background::<Self>(\n                    &ranges_to_highlight,\n                    |theme| theme.editor_highlighted_line_background,\n                    cx,\n                );\n            });\n        })?;\n\n        Ok(())\n    }\n\n    pub fn clear_code_action_providers(&mut self) {\n        self.code_action_providers.clear();\n        self.available_code_actions.take();\n    }\n\n    pub fn add_code_action_provider(\n        &mut self,\n        provider: Rc<dyn CodeActionProvider>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self\n            .code_action_providers\n            .iter()\n            .any(|existing_provider| existing_provider.id() == provider.id())\n        {\n            return;\n        }\n\n        self.code_action_providers.push(provider);\n        self.refresh_code_actions(window, cx);\n    }\n\n    pub fn remove_code_action_provider(\n        &mut self,\n        id: Arc<str>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.code_action_providers\n            .retain(|provider| provider.id() != id);\n        self.refresh_code_actions(window, cx);\n    }\n\n    fn refresh_code_actions(&mut self, window: &mut Window, cx: &mut Context<Self>) -> Option<()> {\n        let buffer = self.buffer.read(cx);\n        let newest_selection = self.selections.newest_anchor().clone();\n        if newest_selection.head().diff_base_anchor.is_some() {\n            return None;\n        }\n        let (start_buffer, start) = buffer.text_anchor_for_position(newest_selection.start, cx)?;\n        let (end_buffer, end) = buffer.text_anchor_for_position(newest_selection.end, cx)?;\n        if start_buffer != end_buffer {\n            return None;\n        }\n\n        self.code_actions_task = Some(cx.spawn_in(window, |this, mut cx| async move {\n            cx.background_executor()\n                .timer(CODE_ACTIONS_DEBOUNCE_TIMEOUT)\n                .await;\n\n            let (providers, tasks) = this.update_in(&mut cx, |this, window, cx| {\n                let providers = this.code_action_providers.clone();\n                let tasks = this\n                    .code_action_providers\n                    .iter()\n                    .map(|provider| provider.code_actions(&start_buffer, start..end, window, cx))\n                    .collect::<Vec<_>>();\n                (providers, tasks)\n            })?;\n\n            let mut actions = Vec::new();\n            for (provider, provider_actions) in\n                providers.into_iter().zip(future::join_all(tasks).await)\n            {\n                if let Some(provider_actions) = provider_actions.log_err() {\n                    actions.extend(provider_actions.into_iter().map(|action| {\n                        AvailableCodeAction {\n                            excerpt_id: newest_selection.start.excerpt_id,\n                            action,\n                            provider: provider.clone(),\n                        }\n                    }));\n                }\n            }\n\n            this.update(&mut cx, |this, cx| {\n                this.available_code_actions = if actions.is_empty() {\n                    None\n                } else {\n                    Some((\n                        Location {\n                            buffer: start_buffer,\n                            range: start..end,\n                        },\n                        actions.into(),\n                    ))\n                };\n                cx.notify();\n            })\n        }));\n        None\n    }\n\n    fn start_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(delay) = ProjectSettings::get_global(cx).git.inline_blame_delay() {\n            self.show_git_blame_inline = false;\n\n            self.show_git_blame_inline_delay_task =\n                Some(cx.spawn_in(window, |this, mut cx| async move {\n                    cx.background_executor().timer(delay).await;\n\n                    this.update(&mut cx, |this, cx| {\n                        this.show_git_blame_inline = true;\n                        cx.notify();\n                    })\n                    .log_err();\n                }));\n        }\n    }\n\n    fn refresh_document_highlights(&mut self, cx: &mut Context<Self>) -> Option<()> {\n        if self.pending_rename.is_some() {\n            return None;\n        }\n\n        let provider = self.semantics_provider.clone()?;\n        let buffer = self.buffer.read(cx);\n        let newest_selection = self.selections.newest_anchor().clone();\n        let cursor_position = newest_selection.head();\n        let (cursor_buffer, cursor_buffer_position) =\n            buffer.text_anchor_for_position(cursor_position, cx)?;\n        let (tail_buffer, _) = buffer.text_anchor_for_position(newest_selection.tail(), cx)?;\n        if cursor_buffer != tail_buffer {\n            return None;\n        }\n        let debounce = EditorSettings::get_global(cx).lsp_highlight_debounce;\n        self.document_highlights_task = Some(cx.spawn(|this, mut cx| async move {\n            cx.background_executor()\n                .timer(Duration::from_millis(debounce))\n                .await;\n\n            let highlights = if let Some(highlights) = cx\n                .update(|cx| {\n                    provider.document_highlights(&cursor_buffer, cursor_buffer_position, cx)\n                })\n                .ok()\n                .flatten()\n            {\n                highlights.await.log_err()\n            } else {\n                None\n            };\n\n            if let Some(highlights) = highlights {\n                this.update(&mut cx, |this, cx| {\n                    if this.pending_rename.is_some() {\n                        return;\n                    }\n\n                    let buffer_id = cursor_position.buffer_id;\n                    let buffer = this.buffer.read(cx);\n                    if !buffer\n                        .text_anchor_for_position(cursor_position, cx)\n                        .map_or(false, |(buffer, _)| buffer == cursor_buffer)\n                    {\n                        return;\n                    }\n\n                    let cursor_buffer_snapshot = cursor_buffer.read(cx);\n                    let mut write_ranges = Vec::new();\n                    let mut read_ranges = Vec::new();\n                    for highlight in highlights {\n                        for (excerpt_id, excerpt_range) in\n                            buffer.excerpts_for_buffer(cursor_buffer.read(cx).remote_id(), cx)\n                        {\n                            let start = highlight\n                                .range\n                                .start\n                                .max(&excerpt_range.context.start, cursor_buffer_snapshot);\n                            let end = highlight\n                                .range\n                                .end\n                                .min(&excerpt_range.context.end, cursor_buffer_snapshot);\n                            if start.cmp(&end, cursor_buffer_snapshot).is_ge() {\n                                continue;\n                            }\n\n                            let range = Anchor {\n                                buffer_id,\n                                excerpt_id,\n                                text_anchor: start,\n                                diff_base_anchor: None,\n                            }..Anchor {\n                                buffer_id,\n                                excerpt_id,\n                                text_anchor: end,\n                                diff_base_anchor: None,\n                            };\n                            if highlight.kind == lsp::DocumentHighlightKind::WRITE {\n                                write_ranges.push(range);\n                            } else {\n                                read_ranges.push(range);\n                            }\n                        }\n                    }\n\n                    this.highlight_background::<DocumentHighlightRead>(\n                        &read_ranges,\n                        |theme| theme.editor_document_highlight_read_background,\n                        cx,\n                    );\n                    this.highlight_background::<DocumentHighlightWrite>(\n                        &write_ranges,\n                        |theme| theme.editor_document_highlight_write_background,\n                        cx,\n                    );\n                    cx.notify();\n                })\n                .log_err();\n            }\n        }));\n        None\n    }\n\n    pub fn refresh_inline_completion(\n        &mut self,\n        debounce: bool,\n        user_requested: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let provider = self.edit_prediction_provider()?;\n        let cursor = self.selections.newest_anchor().head();\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n\n        if !self.inline_completions_enabled_in_buffer(&buffer, cursor_buffer_position, cx) {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        if !user_requested\n            && (!self.should_show_edit_predictions()\n                || !self.is_focused(window)\n                || buffer.read(cx).is_empty())\n        {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        self.update_visible_inline_completion(window, cx);\n        provider.refresh(\n            self.project.clone(),\n            buffer,\n            cursor_buffer_position,\n            debounce,\n            cx,\n        );\n        Some(())\n    }\n\n    fn show_edit_predictions_in_menu(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled { show_in_menu, .. } => show_in_menu,\n        }\n    }\n\n    pub fn edit_predictions_enabled(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled { .. } => true,\n        }\n    }\n\n    fn edit_prediction_requires_modifier(&self) -> bool {\n        match self.edit_prediction_settings {\n            EditPredictionSettings::Disabled => false,\n            EditPredictionSettings::Enabled {\n                preview_requires_modifier,\n                ..\n            } => preview_requires_modifier,\n        }\n    }\n\n    fn edit_prediction_settings_at_position(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: language::Anchor,\n        cx: &App,\n    ) -> EditPredictionSettings {\n        if self.mode != EditorMode::Full\n            || !self.show_inline_completions_override.unwrap_or(true)\n            || self.inline_completions_disabled_in_scope(buffer, buffer_position, cx)\n        {\n            return EditPredictionSettings::Disabled;\n        }\n\n        let buffer = buffer.read(cx);\n\n        let file = buffer.file();\n\n        if !language_settings(buffer.language().map(|l| l.name()), file, cx).show_edit_predictions {\n            return EditPredictionSettings::Disabled;\n        };\n\n        let by_provider = matches!(\n            self.menu_inline_completions_policy,\n            MenuInlineCompletionsPolicy::ByProvider\n        );\n\n        let show_in_menu = by_provider\n            && self\n                .edit_prediction_provider\n                .as_ref()\n                .map_or(false, |provider| {\n                    provider.provider.show_completions_in_menu()\n                });\n\n        let preview_requires_modifier =\n            all_language_settings(file, cx).edit_predictions_mode() == EditPredictionsMode::Auto;\n\n        EditPredictionSettings::Enabled {\n            show_in_menu,\n            preview_requires_modifier,\n        }\n    }\n\n    fn should_show_edit_predictions(&self) -> bool {\n        self.snippet_stack.is_empty() && self.edit_predictions_enabled()\n    }\n\n    pub fn edit_prediction_preview_is_active(&self) -> bool {\n        matches!(\n            self.edit_prediction_preview,\n            EditPredictionPreview::Active { .. }\n        )\n    }\n\n    pub fn inline_completions_enabled(&self, cx: &App) -> bool {\n        let cursor = self.selections.newest_anchor().head();\n        if let Some((buffer, cursor_position)) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)\n        {\n            self.inline_completions_enabled_in_buffer(&buffer, cursor_position, cx)\n        } else {\n            false\n        }\n    }\n\n    fn inline_completions_enabled_in_buffer(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: language::Anchor,\n        cx: &App,\n    ) -> bool {\n        maybe!({\n            let provider = self.edit_prediction_provider()?;\n            if !provider.is_enabled(&buffer, buffer_position, cx) {\n                return Some(false);\n            }\n            let buffer = buffer.read(cx);\n            let Some(file) = buffer.file() else {\n                return Some(true);\n            };\n            let settings = all_language_settings(Some(file), cx);\n            Some(settings.inline_completions_enabled_for_path(file.path()))\n        })\n        .unwrap_or(false)\n    }\n\n    fn cycle_inline_completion(\n        &mut self,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let provider = self.edit_prediction_provider()?;\n        let cursor = self.selections.newest_anchor().head();\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n        if self.inline_completions_hidden_for_vim_mode || !self.should_show_edit_predictions() {\n            return None;\n        }\n\n        provider.cycle(buffer, cursor_buffer_position, direction, cx);\n        self.update_visible_inline_completion(window, cx);\n\n        Some(())\n    }\n\n    pub fn show_inline_completion(\n        &mut self,\n        _: &ShowEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.has_active_inline_completion() {\n            self.refresh_inline_completion(false, true, window, cx);\n            return;\n        }\n\n        self.update_visible_inline_completion(window, cx);\n    }\n\n    pub fn display_cursor_names(\n        &mut self,\n        _: &DisplayCursorNames,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_cursor_names(window, cx);\n    }\n\n    fn show_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.show_cursor_names = true;\n        cx.notify();\n        cx.spawn_in(window, |this, mut cx| async move {\n            cx.background_executor().timer(CURSORS_VISIBLE_FOR).await;\n            this.update(&mut cx, |this, cx| {\n                this.show_cursor_names = false;\n                cx.notify()\n            })\n            .ok()\n        })\n        .detach();\n    }\n\n    pub fn next_edit_prediction(\n        &mut self,\n        _: &NextEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.has_active_inline_completion() {\n            self.cycle_inline_completion(Direction::Next, window, cx);\n        } else {\n            let is_copilot_disabled = self\n                .refresh_inline_completion(false, true, window, cx)\n                .is_none();\n            if is_copilot_disabled {\n                cx.propagate();\n            }\n        }\n    }\n\n    pub fn previous_edit_prediction(\n        &mut self,\n        _: &PreviousEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.has_active_inline_completion() {\n            self.cycle_inline_completion(Direction::Prev, window, cx);\n        } else {\n            let is_copilot_disabled = self\n                .refresh_inline_completion(false, true, window, cx)\n                .is_none();\n            if is_copilot_disabled {\n                cx.propagate();\n            }\n        }\n    }\n\n    pub fn accept_edit_prediction(\n        &mut self,\n        _: &AcceptEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.show_edit_predictions_in_menu() {\n            self.hide_context_menu(window, cx);\n        }\n\n        let Some(active_inline_completion) = self.active_inline_completion.as_ref() else {\n            return;\n        };\n\n        self.report_inline_completion_event(\n            active_inline_completion.completion_id.clone(),\n            true,\n            cx,\n        );\n\n        match &active_inline_completion.completion {\n            InlineCompletion::Move { target, .. } => {\n                let target = *target;\n\n                if let Some(position_map) = &self.last_position_map {\n                    if position_map\n                        .visible_row_range\n                        .contains(&target.to_display_point(&position_map.snapshot).row())\n                        || !self.edit_prediction_requires_modifier()\n                    {\n                        // Note that this is also done in vim's handler of the Tab action.\n                        self.change_selections(\n                            Some(Autoscroll::newest()),\n                            window,\n                            cx,\n                            |selections| {\n                                selections.select_anchor_ranges([target..target]);\n                            },\n                        );\n                        self.clear_row_highlights::<EditPredictionPreview>();\n\n                        self.edit_prediction_preview = EditPredictionPreview::Active {\n                            previous_scroll_position: None,\n                        };\n                    } else {\n                        self.edit_prediction_preview = EditPredictionPreview::Active {\n                            previous_scroll_position: Some(position_map.snapshot.scroll_anchor),\n                        };\n                        self.highlight_rows::<EditPredictionPreview>(\n                            target..target,\n                            cx.theme().colors().editor_highlighted_line_background,\n                            true,\n                            cx,\n                        );\n                        self.request_autoscroll(Autoscroll::fit(), cx);\n                    }\n                }\n            }\n            InlineCompletion::Edit { edits, .. } => {\n                if let Some(provider) = self.edit_prediction_provider() {\n                    provider.accept(cx);\n                }\n\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let last_edit_end = edits.last().unwrap().0.end.bias_right(&snapshot);\n\n                self.buffer.update(cx, |buffer, cx| {\n                    buffer.edit(edits.iter().cloned(), None, cx)\n                });\n\n                self.change_selections(None, window, cx, |s| {\n                    s.select_anchor_ranges([last_edit_end..last_edit_end])\n                });\n\n                self.update_visible_inline_completion(window, cx);\n                if self.active_inline_completion.is_none() {\n                    self.refresh_inline_completion(true, true, window, cx);\n                }\n\n                cx.notify();\n            }\n        }\n    }\n\n    pub fn accept_partial_inline_completion(\n        &mut self,\n        _: &AcceptPartialEditPrediction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(active_inline_completion) = self.active_inline_completion.as_ref() else {\n            return;\n        };\n        if self.selections.count() != 1 {\n            return;\n        }\n\n        self.report_inline_completion_event(\n            active_inline_completion.completion_id.clone(),\n            true,\n            cx,\n        );\n\n        match &active_inline_completion.completion {\n            InlineCompletion::Move { target, .. } => {\n                let target = *target;\n                self.change_selections(Some(Autoscroll::newest()), window, cx, |selections| {\n                    selections.select_anchor_ranges([target..target]);\n                });\n            }\n            InlineCompletion::Edit { edits, .. } => {\n                // Find an insertion that starts at the cursor position.\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                let cursor_offset = self.selections.newest::<usize>(cx).head();\n                let insertion = edits.iter().find_map(|(range, text)| {\n                    let range = range.to_offset(&snapshot);\n                    if range.is_empty() && range.start == cursor_offset {\n                        Some(text)\n                    } else {\n                        None\n                    }\n                });\n\n                if let Some(text) = insertion {\n                    let mut partial_completion = text\n                        .chars()\n                        .by_ref()\n                        .take_while(|c| c.is_alphabetic())\n                        .collect::<String>();\n                    if partial_completion.is_empty() {\n                        partial_completion = text\n                            .chars()\n                            .by_ref()\n                            .take_while(|c| c.is_whitespace() || !c.is_alphabetic())\n                            .collect::<String>();\n                    }\n\n                    cx.emit(EditorEvent::InputHandled {\n                        utf16_range_to_replace: None,\n                        text: partial_completion.clone().into(),\n                    });\n\n                    self.insert_with_autoindent_mode(&partial_completion, None, window, cx);\n\n                    self.refresh_inline_completion(true, true, window, cx);\n                    cx.notify();\n                } else {\n                    self.accept_edit_prediction(&Default::default(), window, cx);\n                }\n            }\n        }\n    }\n\n    fn discard_inline_completion(\n        &mut self,\n        should_report_inline_completion_event: bool,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if should_report_inline_completion_event {\n            let completion_id = self\n                .active_inline_completion\n                .as_ref()\n                .and_then(|active_completion| active_completion.completion_id.clone());\n\n            self.report_inline_completion_event(completion_id, false, cx);\n        }\n\n        if let Some(provider) = self.edit_prediction_provider() {\n            provider.discard(cx);\n        }\n\n        self.take_active_inline_completion(cx)\n    }\n\n    fn report_inline_completion_event(&self, id: Option<SharedString>, accepted: bool, cx: &App) {\n        let Some(provider) = self.edit_prediction_provider() else {\n            return;\n        };\n\n        let Some((_, buffer, _)) = self\n            .buffer\n            .read(cx)\n            .excerpt_containing(self.selections.newest_anchor().head(), cx)\n        else {\n            return;\n        };\n\n        let extension = buffer\n            .read(cx)\n            .file()\n            .and_then(|file| Some(file.path().extension()?.to_string_lossy().to_string()));\n\n        let event_type = match accepted {\n            true => \"Edit Prediction Accepted\",\n            false => \"Edit Prediction Discarded\",\n        };\n        telemetry::event!(\n            event_type,\n            provider = provider.name(),\n            prediction_id = id,\n            suggestion_accepted = accepted,\n            file_extension = extension,\n        );\n    }\n\n    pub fn has_active_inline_completion(&self) -> bool {\n        self.active_inline_completion.is_some()\n    }\n\n    fn take_active_inline_completion(&mut self, cx: &mut Context<Self>) -> bool {\n        let Some(active_inline_completion) = self.active_inline_completion.take() else {\n            return false;\n        };\n\n        self.splice_inlays(&active_inline_completion.inlay_ids, Default::default(), cx);\n        self.clear_highlights::<InlineCompletionHighlight>(cx);\n        self.stale_inline_completion_in_menu = Some(active_inline_completion);\n        true\n    }\n\n    /// Returns true when we're displaying the edit prediction popover below the cursor\n    /// like we are not previewing and the LSP autocomplete menu is visible\n    /// or we are in `when_holding_modifier` mode.\n    pub fn edit_prediction_visible_in_cursor_popover(&self, has_completion: bool) -> bool {\n        if self.edit_prediction_preview_is_active()\n            || !self.show_edit_predictions_in_menu()\n            || !self.edit_predictions_enabled()\n        {\n            return false;\n        }\n\n        if self.has_visible_completions_menu() {\n            return true;\n        }\n\n        has_completion && self.edit_prediction_requires_modifier()\n    }\n\n    fn handle_modifiers_changed(\n        &mut self,\n        modifiers: Modifiers,\n        position_map: &PositionMap,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.show_edit_predictions_in_menu() {\n            self.update_edit_prediction_preview(&modifiers, window, cx);\n        }\n\n        let mouse_position = window.mouse_position();\n        if !position_map.text_hitbox.is_hovered(window) {\n            return;\n        }\n\n        self.update_hovered_link(\n            position_map.point_for_position(mouse_position),\n            &position_map.snapshot,\n            modifiers,\n            window,\n            cx,\n        )\n    }\n\n    fn update_edit_prediction_preview(\n        &mut self,\n        modifiers: &Modifiers,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let accept_keybind = self.accept_edit_prediction_keybind(window, cx);\n        let Some(accept_keystroke) = accept_keybind.keystroke() else {\n            return;\n        };\n\n        if &accept_keystroke.modifiers == modifiers && accept_keystroke.modifiers.modified() {\n            if matches!(\n                self.edit_prediction_preview,\n                EditPredictionPreview::Inactive\n            ) {\n                self.edit_prediction_preview = EditPredictionPreview::Active {\n                    previous_scroll_position: None,\n                };\n\n                self.update_visible_inline_completion(window, cx);\n                cx.notify();\n            }\n        } else if let EditPredictionPreview::Active {\n            previous_scroll_position,\n        } = self.edit_prediction_preview\n        {\n            if let (Some(previous_scroll_position), Some(position_map)) =\n                (previous_scroll_position, self.last_position_map.as_ref())\n            {\n                self.set_scroll_position(\n                    previous_scroll_position\n                        .scroll_position(&position_map.snapshot.display_snapshot),\n                    window,\n                    cx,\n                );\n            }\n\n            self.edit_prediction_preview = EditPredictionPreview::Inactive;\n            self.clear_row_highlights::<EditPredictionPreview>();\n            self.update_visible_inline_completion(window, cx);\n            cx.notify();\n        }\n    }\n\n    fn update_visible_inline_completion(\n        &mut self,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        let selection = self.selections.newest_anchor();\n        let cursor = selection.head();\n        let multibuffer = self.buffer.read(cx).snapshot(cx);\n        let offset_selection = selection.map(|endpoint| endpoint.to_offset(&multibuffer));\n        let excerpt_id = cursor.excerpt_id;\n\n        let show_in_menu = self.show_edit_predictions_in_menu();\n        let completions_menu_has_precedence = !show_in_menu\n            && (self.context_menu.borrow().is_some()\n                || (!self.completion_tasks.is_empty() && !self.has_active_inline_completion()));\n\n        if completions_menu_has_precedence\n            || !offset_selection.is_empty()\n            || self\n                .active_inline_completion\n                .as_ref()\n                .map_or(false, |completion| {\n                    let invalidation_range = completion.invalidation_range.to_offset(&multibuffer);\n                    let invalidation_range = invalidation_range.start..=invalidation_range.end;\n                    !invalidation_range.contains(&offset_selection.head())\n                })\n        {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        self.take_active_inline_completion(cx);\n        let Some(provider) = self.edit_prediction_provider() else {\n            self.edit_prediction_settings = EditPredictionSettings::Disabled;\n            return None;\n        };\n\n        let (buffer, cursor_buffer_position) =\n            self.buffer.read(cx).text_anchor_for_position(cursor, cx)?;\n\n        self.edit_prediction_settings =\n            self.edit_prediction_settings_at_position(&buffer, cursor_buffer_position, cx);\n\n        if !self.edit_prediction_settings.is_enabled() {\n            self.discard_inline_completion(false, cx);\n            return None;\n        }\n\n        self.edit_prediction_cursor_on_leading_whitespace =\n            multibuffer.is_line_whitespace_upto(cursor);\n\n        let inline_completion = provider.suggest(&buffer, cursor_buffer_position, cx)?;\n        let edits = inline_completion\n            .edits\n            .into_iter()\n            .flat_map(|(range, new_text)| {\n                let start = multibuffer.anchor_in_excerpt(excerpt_id, range.start)?;\n                let end = multibuffer.anchor_in_excerpt(excerpt_id, range.end)?;\n                Some((start..end, new_text))\n            })\n            .collect::<Vec<_>>();\n        if edits.is_empty() {\n            return None;\n        }\n\n        let first_edit_start = edits.first().unwrap().0.start;\n        let first_edit_start_point = first_edit_start.to_point(&multibuffer);\n        let edit_start_row = first_edit_start_point.row.saturating_sub(2);\n\n        let last_edit_end = edits.last().unwrap().0.end;\n        let last_edit_end_point = last_edit_end.to_point(&multibuffer);\n        let edit_end_row = cmp::min(multibuffer.max_point().row, last_edit_end_point.row + 2);\n\n        let cursor_row = cursor.to_point(&multibuffer).row;\n\n        let snapshot = multibuffer.buffer_for_excerpt(excerpt_id).cloned()?;\n\n        let mut inlay_ids = Vec::new();\n        let invalidation_row_range;\n        let move_invalidation_row_range = if cursor_row < edit_start_row {\n            Some(cursor_row..edit_end_row)\n        } else if cursor_row > edit_end_row {\n            Some(edit_start_row..cursor_row)\n        } else {\n            None\n        };\n        let is_move =\n            move_invalidation_row_range.is_some() || self.inline_completions_hidden_for_vim_mode;\n        let completion = if is_move {\n            invalidation_row_range =\n                move_invalidation_row_range.unwrap_or(edit_start_row..edit_end_row);\n            let target = first_edit_start;\n            InlineCompletion::Move { target, snapshot }\n        } else {\n            let show_completions_in_buffer = !self.edit_prediction_visible_in_cursor_popover(true)\n                && !self.inline_completions_hidden_for_vim_mode;\n\n            if show_completions_in_buffer {\n                if edits\n                    .iter()\n                    .all(|(range, _)| range.to_offset(&multibuffer).is_empty())\n                {\n                    let mut inlays = Vec::new();\n                    for (range, new_text) in &edits {\n                        let inlay = Inlay::inline_completion(\n                            post_inc(&mut self.next_inlay_id),\n                            range.start,\n                            new_text.as_str(),\n                        );\n                        inlay_ids.push(inlay.id);\n                        inlays.push(inlay);\n                    }\n\n                    self.splice_inlays(&[], inlays, cx);\n                } else {\n                    let background_color = cx.theme().status().deleted_background;\n                    self.highlight_text::<InlineCompletionHighlight>(\n                        edits.iter().map(|(range, _)| range.clone()).collect(),\n                        HighlightStyle {\n                            background_color: Some(background_color),\n                            ..Default::default()\n                        },\n                        cx,\n                    );\n                }\n            }\n\n            invalidation_row_range = edit_start_row..edit_end_row;\n\n            let display_mode = if all_edits_insertions_or_deletions(&edits, &multibuffer) {\n                if provider.show_tab_accept_marker() {\n                    EditDisplayMode::TabAccept\n                } else {\n                    EditDisplayMode::Inline\n                }\n            } else {\n                EditDisplayMode::DiffPopover\n            };\n\n            InlineCompletion::Edit {\n                edits,\n                edit_preview: inline_completion.edit_preview,\n                display_mode,\n                snapshot,\n            }\n        };\n\n        let invalidation_range = multibuffer\n            .anchor_before(Point::new(invalidation_row_range.start, 0))\n            ..multibuffer.anchor_after(Point::new(\n                invalidation_row_range.end,\n                multibuffer.line_len(MultiBufferRow(invalidation_row_range.end)),\n            ));\n\n        self.stale_inline_completion_in_menu = None;\n        self.active_inline_completion = Some(InlineCompletionState {\n            inlay_ids,\n            completion,\n            completion_id: inline_completion.id,\n            invalidation_range,\n        });\n\n        cx.notify();\n\n        Some(())\n    }\n\n    pub fn edit_prediction_provider(&self) -> Option<Arc<dyn InlineCompletionProviderHandle>> {\n        Some(self.edit_prediction_provider.as_ref()?.provider.clone())\n    }\n\n    fn render_code_actions_indicator(\n        &self,\n        _style: &EditorStyle,\n        row: DisplayRow,\n        is_active: bool,\n        cx: &mut Context<Self>,\n    ) -> Option<IconButton> {\n        if self.available_code_actions.is_some() {\n            Some(\n                IconButton::new(\"code_actions_indicator\", ui::IconName::Bolt)\n                    .shape(ui::IconButtonShape::Square)\n                    .icon_size(IconSize::XSmall)\n                    .icon_color(Color::Muted)\n                    .toggle_state(is_active)\n                    .tooltip({\n                        let focus_handle = self.focus_handle.clone();\n                        move |window, cx| {\n                            Tooltip::for_action_in(\n                                \"Toggle Code Actions\",\n                                &ToggleCodeActions {\n                                    deployed_from_indicator: None,\n                                },\n                                &focus_handle,\n                                window,\n                                cx,\n                            )\n                        }\n                    })\n                    .on_click(cx.listener(move |editor, _e, window, cx| {\n                        window.focus(&editor.focus_handle(cx));\n                        editor.toggle_code_actions(\n                            &ToggleCodeActions {\n                                deployed_from_indicator: Some(row),\n                            },\n                            window,\n                            cx,\n                        );\n                    })),\n            )\n        } else {\n            None\n        }\n    }\n\n    fn clear_tasks(&mut self) {\n        self.tasks.clear()\n    }\n\n    fn insert_tasks(&mut self, key: (BufferId, BufferRow), value: RunnableTasks) {\n        if self.tasks.insert(key, value).is_some() {\n            // This case should hopefully be rare, but just in case...\n            log::error!(\"multiple different run targets found on a single line, only the last target will be rendered\")\n        }\n    }\n\n    fn build_tasks_context(\n        project: &Entity<Project>,\n        buffer: &Entity<Buffer>,\n        buffer_row: u32,\n        tasks: &Arc<RunnableTasks>,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<task::TaskContext>> {\n        let position = Point::new(buffer_row, tasks.column);\n        let range_start = buffer.read(cx).anchor_at(position, Bias::Right);\n        let location = Location {\n            buffer: buffer.clone(),\n            range: range_start..range_start,\n        };\n        // Fill in the environmental variables from the tree-sitter captures\n        let mut captured_task_variables = TaskVariables::default();\n        for (capture_name, value) in tasks.extra_variables.clone() {\n            captured_task_variables.insert(\n                task::VariableName::Custom(capture_name.into()),\n                value.clone(),\n            );\n        }\n        project.update(cx, |project, cx| {\n            project.task_store().update(cx, |task_store, cx| {\n                task_store.task_context_for_location(captured_task_variables, location, cx)\n            })\n        })\n    }\n\n    pub fn spawn_nearest_task(\n        &mut self,\n        action: &SpawnNearestTask,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some((workspace, _)) = self.workspace.clone() else {\n            return;\n        };\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n\n        // Try to find a closest, enclosing node using tree-sitter that has a\n        // task\n        let Some((buffer, buffer_row, tasks)) = self\n            .find_enclosing_node_task(cx)\n            // Or find the task that's closest in row-distance.\n            .or_else(|| self.find_closest_task(cx))\n        else {\n            return;\n        };\n\n        let reveal_strategy = action.reveal;\n        let task_context = Self::build_tasks_context(&project, &buffer, buffer_row, &tasks, cx);\n        cx.spawn_in(window, |_, mut cx| async move {\n            let context = task_context.await?;\n            let (task_source_kind, mut resolved_task) = tasks.resolve(&context).next()?;\n\n            let resolved = resolved_task.resolved.as_mut()?;\n            resolved.reveal = reveal_strategy;\n\n            workspace\n                .update(&mut cx, |workspace, cx| {\n                    workspace::tasks::schedule_resolved_task(\n                        workspace,\n                        task_source_kind,\n                        resolved_task,\n                        false,\n                        cx,\n                    );\n                })\n                .ok()\n        })\n        .detach();\n    }\n\n    fn find_closest_task(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<(Entity<Buffer>, u32, Arc<RunnableTasks>)> {\n        let cursor_row = self.selections.newest_adjusted(cx).head().row;\n\n        let ((buffer_id, row), tasks) = self\n            .tasks\n            .iter()\n            .min_by_key(|((_, row), _)| cursor_row.abs_diff(*row))?;\n\n        let buffer = self.buffer.read(cx).buffer(*buffer_id)?;\n        let tasks = Arc::new(tasks.to_owned());\n        Some((buffer, *row, tasks))\n    }\n\n    fn find_enclosing_node_task(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<(Entity<Buffer>, u32, Arc<RunnableTasks>)> {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let offset = self.selections.newest::<usize>(cx).head();\n        let excerpt = snapshot.excerpt_containing(offset..offset)?;\n        let buffer_id = excerpt.buffer().remote_id();\n\n        let layer = excerpt.buffer().syntax_layer_at(offset)?;\n        let mut cursor = layer.node().walk();\n\n        while cursor.goto_first_child_for_byte(offset).is_some() {\n            if cursor.node().end_byte() == offset {\n                cursor.goto_next_sibling();\n            }\n        }\n\n        // Ascend to the smallest ancestor that contains the range and has a task.\n        loop {\n            let node = cursor.node();\n            let node_range = node.byte_range();\n            let symbol_start_row = excerpt.buffer().offset_to_point(node.start_byte()).row;\n\n            // Check if this node contains our offset\n            if node_range.start <= offset && node_range.end >= offset {\n                // If it contains offset, check for task\n                if let Some(tasks) = self.tasks.get(&(buffer_id, symbol_start_row)) {\n                    let buffer = self.buffer.read(cx).buffer(buffer_id)?;\n                    return Some((buffer, symbol_start_row, Arc::new(tasks.to_owned())));\n                }\n            }\n\n            if !cursor.goto_parent() {\n                break;\n            }\n        }\n        None\n    }\n\n    fn render_run_indicator(\n        &self,\n        _style: &EditorStyle,\n        is_active: bool,\n        row: DisplayRow,\n        cx: &mut Context<Self>,\n    ) -> IconButton {\n        IconButton::new((\"run_indicator\", row.0 as usize), ui::IconName::Play)\n            .shape(ui::IconButtonShape::Square)\n            .icon_size(IconSize::XSmall)\n            .icon_color(Color::Muted)\n            .toggle_state(is_active)\n            .on_click(cx.listener(move |editor, _e, window, cx| {\n                window.focus(&editor.focus_handle(cx));\n                editor.toggle_code_actions(\n                    &ToggleCodeActions {\n                        deployed_from_indicator: Some(row),\n                    },\n                    window,\n                    cx,\n                );\n            }))\n    }\n\n    pub fn context_menu_visible(&self) -> bool {\n        !self.edit_prediction_preview_is_active()\n            && self\n                .context_menu\n                .borrow()\n                .as_ref()\n                .map_or(false, |menu| menu.visible())\n    }\n\n    fn context_menu_origin(&self) -> Option<ContextMenuOrigin> {\n        self.context_menu\n            .borrow()\n            .as_ref()\n            .map(|menu| menu.origin())\n    }\n\n    fn edit_prediction_cursor_popover_height(&self) -> Pixels {\n        px(30.)\n    }\n\n    fn current_user_player_color(&self, cx: &mut App) -> PlayerColor {\n        if self.read_only(cx) {\n            cx.theme().players().read_only()\n        } else {\n            self.style.as_ref().unwrap().local_player\n        }\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    fn render_edit_prediction_cursor_popover(\n        &self,\n        min_width: Pixels,\n        max_width: Pixels,\n        cursor_point: Point,\n        style: &EditorStyle,\n        accept_keystroke: &gpui::Keystroke,\n        _window: &Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        let provider = self.edit_prediction_provider.as_ref()?;\n\n        if provider.provider.needs_terms_acceptance(cx) {\n            return Some(\n                h_flex()\n                    .min_w(min_width)\n                    .flex_1()\n                    .px_2()\n                    .py_1()\n                    .gap_3()\n                    .elevation_2(cx)\n                    .hover(|style| style.bg(cx.theme().colors().element_hover))\n                    .id(\"accept-terms\")\n                    .cursor_pointer()\n                    .on_mouse_down(MouseButton::Left, |_, window, _| window.prevent_default())\n                    .on_click(cx.listener(|this, _event, window, cx| {\n                        cx.stop_propagation();\n                        this.report_editor_event(\"Edit Prediction Provider ToS Clicked\", None, cx);\n                        window.dispatch_action(\n                            zed_actions::OpenZedPredictOnboarding.boxed_clone(),\n                            cx,\n                        );\n                    }))\n                    .child(\n                        h_flex()\n                            .flex_1()\n                            .gap_2()\n                            .child(Icon::new(IconName::ZedPredict))\n                            .child(Label::new(\"Accept Terms of Service\"))\n                            .child(div().w_full())\n                            .child(\n                                Icon::new(IconName::ArrowUpRight)\n                                    .color(Color::Muted)\n                                    .size(IconSize::Small),\n                            )\n                            .into_any_element(),\n                    )\n                    .into_any(),\n            );\n        }\n\n        let is_refreshing = provider.provider.is_refreshing(cx);\n\n        fn pending_completion_container() -> Div {\n            h_flex()\n                .h_full()\n                .flex_1()\n                .gap_2()\n                .child(Icon::new(IconName::ZedPredict))\n        }\n\n        let completion = match &self.active_inline_completion {\n            Some(completion) => match &completion.completion {\n                InlineCompletion::Move {\n                    target, snapshot, ..\n                } if !self.has_visible_completions_menu() => {\n                    use text::ToPoint as _;\n\n                    return Some(\n                        h_flex()\n                            .px_2()\n                            .py_1()\n                            .elevation_2(cx)\n                            .border_color(cx.theme().colors().border)\n                            .rounded_tl(px(0.))\n                            .gap_2()\n                            .child(\n                                if target.text_anchor.to_point(&snapshot).row > cursor_point.row {\n                                    Icon::new(IconName::ZedPredictDown)\n                                } else {\n                                    Icon::new(IconName::ZedPredictUp)\n                                },\n                            )\n                            .child(Label::new(\"Hold\").size(LabelSize::Small))\n                            .children(ui::render_modifiers(\n                                &accept_keystroke.modifiers,\n                                PlatformStyle::platform(),\n                                Some(Color::Default),\n                                Some(IconSize::Small.rems().into()),\n                                true,\n                            ))\n                            .into_any(),\n                    );\n                }\n                _ => self.render_edit_prediction_cursor_popover_preview(\n                    completion,\n                    cursor_point,\n                    style,\n                    cx,\n                )?,\n            },\n\n            None if is_refreshing => match &self.stale_inline_completion_in_menu {\n                Some(stale_completion) => self.render_edit_prediction_cursor_popover_preview(\n                    stale_completion,\n                    cursor_point,\n                    style,\n                    cx,\n                )?,\n\n                None => {\n                    pending_completion_container().child(Label::new(\"...\").size(LabelSize::Small))\n                }\n            },\n\n            None => pending_completion_container().child(Label::new(\"No Prediction\")),\n        };\n\n        let completion = if is_refreshing {\n            completion\n                .with_animation(\n                    \"loading-completion\",\n                    Animation::new(Duration::from_secs(2))\n                        .repeat()\n                        .with_easing(pulsating_between(0.4, 0.8)),\n                    |label, delta| label.opacity(delta),\n                )\n                .into_any_element()\n        } else {\n            completion.into_any_element()\n        };\n\n        let has_completion = self.active_inline_completion.is_some();\n\n        Some(\n            h_flex()\n                .min_w(min_width)\n                .max_w(max_width)\n                .flex_1()\n                .px_2()\n                .elevation_2(cx)\n                .border_color(cx.theme().colors().border)\n                .child(div().py_1().overflow_hidden().child(completion))\n                .child(\n                    h_flex()\n                        .h_full()\n                        .border_l_1()\n                        .border_color(cx.theme().colors().border)\n                        .gap_1()\n                        .py_1()\n                        .pl_2()\n                        .child(\n                            h_flex()\n                                .font(theme::ThemeSettings::get_global(cx).buffer_font.clone())\n                                .gap_1()\n                                .children(ui::render_modifiers(\n                                    &accept_keystroke.modifiers,\n                                    PlatformStyle::platform(),\n                                    Some(if !has_completion {\n                                        Color::Muted\n                                    } else {\n                                        Color::Default\n                                    }),\n                                    None,\n                                    true,\n                                )),\n                        )\n                        .child(Label::new(\"Preview\").into_any_element())\n                        .opacity(if has_completion { 1.0 } else { 0.4 }),\n                )\n                .into_any(),\n        )\n    }\n\n    fn render_edit_prediction_cursor_popover_preview(\n        &self,\n        completion: &InlineCompletionState,\n        cursor_point: Point,\n        style: &EditorStyle,\n        cx: &mut Context<Editor>,\n    ) -> Option<Div> {\n        use text::ToPoint as _;\n\n        fn render_relative_row_jump(\n            prefix: impl Into<String>,\n            current_row: u32,\n            target_row: u32,\n        ) -> Div {\n            let (row_diff, arrow) = if target_row < current_row {\n                (current_row - target_row, IconName::ArrowUp)\n            } else {\n                (target_row - current_row, IconName::ArrowDown)\n            };\n\n            h_flex()\n                .child(\n                    Label::new(format!(\"{}{}\", prefix.into(), row_diff))\n                        .color(Color::Muted)\n                        .size(LabelSize::Small),\n                )\n                .child(Icon::new(arrow).color(Color::Muted).size(IconSize::Small))\n        }\n\n        match &completion.completion {\n            InlineCompletion::Move {\n                target, snapshot, ..\n            } => Some(\n                h_flex()\n                    .px_2()\n                    .gap_2()\n                    .flex_1()\n                    .child(\n                        if target.text_anchor.to_point(&snapshot).row > cursor_point.row {\n                            Icon::new(IconName::ZedPredictDown)\n                        } else {\n                            Icon::new(IconName::ZedPredictUp)\n                        },\n                    )\n                    .child(Label::new(\"Jump to Edit\")),\n            ),\n\n            InlineCompletion::Edit {\n                edits,\n                edit_preview,\n                snapshot,\n                display_mode: _,\n            } => {\n                let first_edit_row = edits.first()?.0.start.text_anchor.to_point(&snapshot).row;\n\n                let highlighted_edits = crate::inline_completion_edit_text(\n                    &snapshot,\n                    &edits,\n                    edit_preview.as_ref()?,\n                    true,\n                    cx,\n                );\n\n                let len_total = highlighted_edits.text.len();\n                let first_line = &highlighted_edits.text\n                    [..highlighted_edits.text.find('\\n').unwrap_or(len_total)];\n                let first_line_len = first_line.len();\n\n                let first_highlight_start = highlighted_edits\n                    .highlights\n                    .first()\n                    .map_or(0, |(range, _)| range.start);\n                let drop_prefix_len = first_line\n                    .char_indices()\n                    .find(|(_, c)| !c.is_whitespace())\n                    .map_or(first_highlight_start, |(ix, _)| {\n                        ix.min(first_highlight_start)\n                    });\n\n                let preview_text = &first_line[drop_prefix_len..];\n                let preview_len = preview_text.len();\n                let highlights = highlighted_edits\n                    .highlights\n                    .into_iter()\n                    .take_until(|(range, _)| range.start > first_line_len)\n                    .map(|(range, style)| {\n                        (\n                            range.start - drop_prefix_len\n                                ..(range.end - drop_prefix_len).min(preview_len),\n                            style,\n                        )\n                    });\n\n                let styled_text = gpui::StyledText::new(SharedString::new(preview_text))\n                    .with_highlights(&style.text, highlights);\n\n                let preview = h_flex()\n                    .gap_1()\n                    .min_w_16()\n                    .child(styled_text)\n                    .when(len_total > first_line_len, |parent| parent.child(\"…\"));\n\n                let left = if first_edit_row != cursor_point.row {\n                    render_relative_row_jump(\"\", cursor_point.row, first_edit_row)\n                        .into_any_element()\n                } else {\n                    Icon::new(IconName::ZedPredict).into_any_element()\n                };\n\n                Some(\n                    h_flex()\n                        .h_full()\n                        .flex_1()\n                        .gap_2()\n                        .pr_1()\n                        .overflow_x_hidden()\n                        .font(theme::ThemeSettings::get_global(cx).buffer_font.clone())\n                        .child(left)\n                        .child(preview),\n                )\n            }\n        }\n    }\n\n    fn render_context_menu(\n        &self,\n        style: &EditorStyle,\n        max_height_in_lines: u32,\n        y_flipped: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        let menu = self.context_menu.borrow();\n        let menu = menu.as_ref()?;\n        if !menu.visible() {\n            return None;\n        };\n        Some(menu.render(style, max_height_in_lines, y_flipped, window, cx))\n    }\n\n    fn render_context_menu_aside(\n        &self,\n        style: &EditorStyle,\n        max_size: Size<Pixels>,\n        cx: &mut Context<Editor>,\n    ) -> Option<AnyElement> {\n        self.context_menu.borrow().as_ref().and_then(|menu| {\n            if menu.visible() {\n                menu.render_aside(\n                    style,\n                    max_size,\n                    self.workspace.as_ref().map(|(w, _)| w.clone()),\n                    cx,\n                )\n            } else {\n                None\n            }\n        })\n    }\n\n    fn hide_context_menu(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<CodeContextMenu> {\n        cx.notify();\n        self.completion_tasks.clear();\n        let context_menu = self.context_menu.borrow_mut().take();\n        self.stale_inline_completion_in_menu.take();\n        self.update_visible_inline_completion(window, cx);\n        context_menu\n    }\n\n    fn show_snippet_choices(\n        &mut self,\n        choices: &Vec<String>,\n        selection: Range<Anchor>,\n        cx: &mut Context<Self>,\n    ) {\n        if selection.start.buffer_id.is_none() {\n            return;\n        }\n        let buffer_id = selection.start.buffer_id.unwrap();\n        let buffer = self.buffer().read(cx).buffer(buffer_id);\n        let id = post_inc(&mut self.next_completion_id);\n\n        if let Some(buffer) = buffer {\n            *self.context_menu.borrow_mut() = Some(CodeContextMenu::Completions(\n                CompletionsMenu::new_snippet_choices(id, true, choices, selection, buffer),\n            ));\n        }\n    }\n\n    pub fn insert_snippet(\n        &mut self,\n        insertion_ranges: &[Range<usize>],\n        snippet: Snippet,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        struct Tabstop<T> {\n            is_end_tabstop: bool,\n            ranges: Vec<Range<T>>,\n            choices: Option<Vec<String>>,\n        }\n\n        let tabstops = self.buffer.update(cx, |buffer, cx| {\n            let snippet_text: Arc<str> = snippet.text.clone().into();\n            buffer.edit(\n                insertion_ranges\n                    .iter()\n                    .cloned()\n                    .map(|range| (range, snippet_text.clone())),\n                Some(AutoindentMode::EachLine),\n                cx,\n            );\n\n            let snapshot = &*buffer.read(cx);\n            let snippet = &snippet;\n            snippet\n                .tabstops\n                .iter()\n                .map(|tabstop| {\n                    let is_end_tabstop = tabstop.ranges.first().map_or(false, |tabstop| {\n                        tabstop.is_empty() && tabstop.start == snippet.text.len() as isize\n                    });\n                    let mut tabstop_ranges = tabstop\n                        .ranges\n                        .iter()\n                        .flat_map(|tabstop_range| {\n                            let mut delta = 0_isize;\n                            insertion_ranges.iter().map(move |insertion_range| {\n                                let insertion_start = insertion_range.start as isize + delta;\n                                delta +=\n                                    snippet.text.len() as isize - insertion_range.len() as isize;\n\n                                let start = ((insertion_start + tabstop_range.start) as usize)\n                                    .min(snapshot.len());\n                                let end = ((insertion_start + tabstop_range.end) as usize)\n                                    .min(snapshot.len());\n                                snapshot.anchor_before(start)..snapshot.anchor_after(end)\n                            })\n                        })\n                        .collect::<Vec<_>>();\n                    tabstop_ranges.sort_unstable_by(|a, b| a.start.cmp(&b.start, snapshot));\n\n                    Tabstop {\n                        is_end_tabstop,\n                        ranges: tabstop_ranges,\n                        choices: tabstop.choices.clone(),\n                    }\n                })\n                .collect::<Vec<_>>()\n        });\n        if let Some(tabstop) = tabstops.first() {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select_ranges(tabstop.ranges.iter().cloned());\n            });\n\n            if let Some(choices) = &tabstop.choices {\n                if let Some(selection) = tabstop.ranges.first() {\n                    self.show_snippet_choices(choices, selection.clone(), cx)\n                }\n            }\n\n            // If we're already at the last tabstop and it's at the end of the snippet,\n            // we're done, we don't need to keep the state around.\n            if !tabstop.is_end_tabstop {\n                let choices = tabstops\n                    .iter()\n                    .map(|tabstop| tabstop.choices.clone())\n                    .collect();\n\n                let ranges = tabstops\n                    .into_iter()\n                    .map(|tabstop| tabstop.ranges)\n                    .collect::<Vec<_>>();\n\n                self.snippet_stack.push(SnippetState {\n                    active_index: 0,\n                    ranges,\n                    choices,\n                });\n            }\n\n            // Check whether the just-entered snippet ends with an auto-closable bracket.\n            if self.autoclose_regions.is_empty() {\n                let snapshot = self.buffer.read(cx).snapshot(cx);\n                for selection in &mut self.selections.all::<Point>(cx) {\n                    let selection_head = selection.head();\n                    let Some(scope) = snapshot.language_scope_at(selection_head) else {\n                        continue;\n                    };\n\n                    let mut bracket_pair = None;\n                    let next_chars = snapshot.chars_at(selection_head).collect::<String>();\n                    let prev_chars = snapshot\n                        .reversed_chars_at(selection_head)\n                        .collect::<String>();\n                    for (pair, enabled) in scope.brackets() {\n                        if enabled\n                            && pair.close\n                            && prev_chars.starts_with(pair.start.as_str())\n                            && next_chars.starts_with(pair.end.as_str())\n                        {\n                            bracket_pair = Some(pair.clone());\n                            break;\n                        }\n                    }\n                    if let Some(pair) = bracket_pair {\n                        let start = snapshot.anchor_after(selection_head);\n                        let end = snapshot.anchor_after(selection_head);\n                        self.autoclose_regions.push(AutocloseRegion {\n                            selection_id: selection.id,\n                            range: start..end,\n                            pair,\n                        });\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub fn move_to_next_snippet_tabstop(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.move_to_snippet_tabstop(Bias::Right, window, cx)\n    }\n\n    pub fn move_to_prev_snippet_tabstop(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        self.move_to_snippet_tabstop(Bias::Left, window, cx)\n    }\n\n    pub fn move_to_snippet_tabstop(\n        &mut self,\n        bias: Bias,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> bool {\n        if let Some(mut snippet) = self.snippet_stack.pop() {\n            match bias {\n                Bias::Left => {\n                    if snippet.active_index > 0 {\n                        snippet.active_index -= 1;\n                    } else {\n                        self.snippet_stack.push(snippet);\n                        return false;\n                    }\n                }\n                Bias::Right => {\n                    if snippet.active_index + 1 < snippet.ranges.len() {\n                        snippet.active_index += 1;\n                    } else {\n                        self.snippet_stack.push(snippet);\n                        return false;\n                    }\n                }\n            }\n            if let Some(current_ranges) = snippet.ranges.get(snippet.active_index) {\n                self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.select_anchor_ranges(current_ranges.iter().cloned())\n                });\n\n                if let Some(choices) = &snippet.choices[snippet.active_index] {\n                    if let Some(selection) = current_ranges.first() {\n                        self.show_snippet_choices(&choices, selection.clone(), cx);\n                    }\n                }\n\n                // If snippet state is not at the last tabstop, push it back on the stack\n                if snippet.active_index + 1 < snippet.ranges.len() {\n                    self.snippet_stack.push(snippet);\n                }\n                return true;\n            }\n        }\n\n        false\n    }\n\n    pub fn clear(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_all(&SelectAll, window, cx);\n            this.insert(\"\", window, cx);\n        });\n    }\n\n    pub fn backspace(&mut self, _: &Backspace, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            let mut linked_ranges = HashMap::<_, Vec<_>>::default();\n            if !this.linked_edit_ranges.is_empty() {\n                let selections = this.selections.all::<MultiBufferPoint>(cx);\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n\n                for selection in selections.iter() {\n                    let selection_start = snapshot.anchor_before(selection.start).text_anchor;\n                    let selection_end = snapshot.anchor_after(selection.end).text_anchor;\n                    if selection_start.buffer_id != selection_end.buffer_id {\n                        continue;\n                    }\n                    if let Some(ranges) =\n                        this.linked_editing_ranges_for(selection_start..selection_end, cx)\n                    {\n                        for (buffer, entries) in ranges {\n                            linked_ranges.entry(buffer).or_default().extend(entries);\n                        }\n                    }\n                }\n            }\n\n            let mut selections = this.selections.all::<MultiBufferPoint>(cx);\n            if !this.selections.line_mode {\n                let display_map = this.display_map.update(cx, |map, cx| map.snapshot(cx));\n                for selection in &mut selections {\n                    if selection.is_empty() {\n                        let old_head = selection.head();\n                        let mut new_head =\n                            movement::left(&display_map, old_head.to_display_point(&display_map))\n                                .to_point(&display_map);\n                        if let Some((buffer, line_buffer_range)) = display_map\n                            .buffer_snapshot\n                            .buffer_line_for_row(MultiBufferRow(old_head.row))\n                        {\n                            let indent_size =\n                                buffer.indent_size_for_line(line_buffer_range.start.row);\n                            let indent_len = match indent_size.kind {\n                                IndentKind::Space => {\n                                    buffer.settings_at(line_buffer_range.start, cx).tab_size\n                                }\n                                IndentKind::Tab => NonZeroU32::new(1).unwrap(),\n                            };\n                            if old_head.column <= indent_size.len && old_head.column > 0 {\n                                let indent_len = indent_len.get();\n                                new_head = cmp::min(\n                                    new_head,\n                                    MultiBufferPoint::new(\n                                        old_head.row,\n                                        ((old_head.column - 1) / indent_len) * indent_len,\n                                    ),\n                                );\n                            }\n                        }\n\n                        selection.set_head(new_head, SelectionGoal::None);\n                    }\n                }\n            }\n\n            this.signature_help_state.set_backspace_pressed(true);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n            this.insert(\"\", window, cx);\n            let empty_str: Arc<str> = Arc::from(\"\");\n            for (buffer, edits) in linked_ranges {\n                let snapshot = buffer.read(cx).snapshot();\n                use text::ToPoint as TP;\n\n                let edits = edits\n                    .into_iter()\n                    .map(|range| {\n                        let end_point = TP::to_point(&range.end, &snapshot);\n                        let mut start_point = TP::to_point(&range.start, &snapshot);\n\n                        if end_point == start_point {\n                            let offset = text::ToOffset::to_offset(&range.start, &snapshot)\n                                .saturating_sub(1);\n                            start_point =\n                                snapshot.clip_point(TP::to_point(&offset, &snapshot), Bias::Left);\n                        };\n\n                        (start_point..end_point, empty_str.clone())\n                    })\n                    .sorted_by_key(|(range, _)| range.start)\n                    .collect::<Vec<_>>();\n                buffer.update(cx, |this, cx| {\n                    this.edit(edits, None, cx);\n                })\n            }\n            this.refresh_inline_completion(true, false, window, cx);\n            linked_editing_ranges::refresh_linked_ranges(this, window, cx);\n        });\n    }\n\n    pub fn delete(&mut self, _: &Delete, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let line_mode = s.line_mode;\n                s.move_with(|map, selection| {\n                    if selection.is_empty() && !line_mode {\n                        let cursor = movement::right(map, selection.head());\n                        selection.end = cursor;\n                        selection.reversed = true;\n                        selection.goal = SelectionGoal::None;\n                    }\n                })\n            });\n            this.insert(\"\", window, cx);\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    pub fn tab_prev(&mut self, _: &TabPrev, window: &mut Window, cx: &mut Context<Self>) {\n        if self.move_to_prev_snippet_tabstop(window, cx) {\n            return;\n        }\n\n        self.outdent(&Outdent, window, cx);\n    }\n\n    pub fn tab(&mut self, _: &Tab, window: &mut Window, cx: &mut Context<Self>) {\n        if self.move_to_next_snippet_tabstop(window, cx) || self.read_only(cx) {\n            return;\n        }\n\n        let mut selections = self.selections.all_adjusted(cx);\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n        let rows_iter = selections.iter().map(|s| s.head().row);\n        let suggested_indents = snapshot.suggested_indents(rows_iter, cx);\n\n        let mut edits = Vec::new();\n        let mut prev_edited_row = 0;\n        let mut row_delta = 0;\n        for selection in &mut selections {\n            if selection.start.row != prev_edited_row {\n                row_delta = 0;\n            }\n            prev_edited_row = selection.end.row;\n\n            // If the selection is non-empty, then increase the indentation of the selected lines.\n            if !selection.is_empty() {\n                row_delta =\n                    Self::indent_selection(buffer, &snapshot, selection, &mut edits, row_delta, cx);\n                continue;\n            }\n\n            // If the selection is empty and the cursor is in the leading whitespace before the\n            // suggested indentation, then auto-indent the line.\n            let cursor = selection.head();\n            let current_indent = snapshot.indent_size_for_line(MultiBufferRow(cursor.row));\n            if let Some(suggested_indent) =\n                suggested_indents.get(&MultiBufferRow(cursor.row)).copied()\n            {\n                if cursor.column < suggested_indent.len\n                    && cursor.column <= current_indent.len\n                    && current_indent.len <= suggested_indent.len\n                {\n                    selection.start = Point::new(cursor.row, suggested_indent.len);\n                    selection.end = selection.start;\n                    if row_delta == 0 {\n                        edits.extend(Buffer::edit_for_indent_size_adjustment(\n                            cursor.row,\n                            current_indent,\n                            suggested_indent,\n                        ));\n                        row_delta = suggested_indent.len - current_indent.len;\n                    }\n                    continue;\n                }\n            }\n\n            // Otherwise, insert a hard or soft tab.\n            let settings = buffer.settings_at(cursor, cx);\n            let tab_size = if settings.hard_tabs {\n                IndentSize::tab()\n            } else {\n                let tab_size = settings.tab_size.get();\n                let char_column = snapshot\n                    .text_for_range(Point::new(cursor.row, 0)..cursor)\n                    .flat_map(str::chars)\n                    .count()\n                    + row_delta as usize;\n                let chars_to_next_tab_stop = tab_size - (char_column as u32 % tab_size);\n                IndentSize::spaces(chars_to_next_tab_stop)\n            };\n            selection.start = Point::new(cursor.row, cursor.column + row_delta + tab_size.len);\n            selection.end = selection.start;\n            edits.push((cursor..cursor, tab_size.chars().collect::<String>()));\n            row_delta += tab_size.len;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |b, cx| b.edit(edits, None, cx));\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    pub fn indent(&mut self, _: &Indent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        let mut selections = self.selections.all::<Point>(cx);\n        let mut prev_edited_row = 0;\n        let mut row_delta = 0;\n        let mut edits = Vec::new();\n        let buffer = self.buffer.read(cx);\n        let snapshot = buffer.snapshot(cx);\n        for selection in &mut selections {\n            if selection.start.row != prev_edited_row {\n                row_delta = 0;\n            }\n            prev_edited_row = selection.end.row;\n\n            row_delta =\n                Self::indent_selection(buffer, &snapshot, selection, &mut edits, row_delta, cx);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |b, cx| b.edit(edits, None, cx));\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n        });\n    }\n\n    fn indent_selection(\n        buffer: &MultiBuffer,\n        snapshot: &MultiBufferSnapshot,\n        selection: &mut Selection<Point>,\n        edits: &mut Vec<(Range<Point>, String)>,\n        delta_for_start_row: u32,\n        cx: &App,\n    ) -> u32 {\n        let settings = buffer.settings_at(selection.start, cx);\n        let tab_size = settings.tab_size.get();\n        let indent_kind = if settings.hard_tabs {\n            IndentKind::Tab\n        } else {\n            IndentKind::Space\n        };\n        let mut start_row = selection.start.row;\n        let mut end_row = selection.end.row + 1;\n\n        // If a selection ends at the beginning of a line, don't indent\n        // that last line.\n        if selection.end.column == 0 && selection.end.row > selection.start.row {\n            end_row -= 1;\n        }\n\n        // Avoid re-indenting a row that has already been indented by a\n        // previous selection, but still update this selection's column\n        // to reflect that indentation.\n        if delta_for_start_row > 0 {\n            start_row += 1;\n            selection.start.column += delta_for_start_row;\n            if selection.end.row == selection.start.row {\n                selection.end.column += delta_for_start_row;\n            }\n        }\n\n        let mut delta_for_end_row = 0;\n        let has_multiple_rows = start_row + 1 != end_row;\n        for row in start_row..end_row {\n            let current_indent = snapshot.indent_size_for_line(MultiBufferRow(row));\n            let indent_delta = match (current_indent.kind, indent_kind) {\n                (IndentKind::Space, IndentKind::Space) => {\n                    let columns_to_next_tab_stop = tab_size - (current_indent.len % tab_size);\n                    IndentSize::spaces(columns_to_next_tab_stop)\n                }\n                (IndentKind::Tab, IndentKind::Space) => IndentSize::spaces(tab_size),\n                (_, IndentKind::Tab) => IndentSize::tab(),\n            };\n\n            let start = if has_multiple_rows || current_indent.len < selection.start.column {\n                0\n            } else {\n                selection.start.column\n            };\n            let row_start = Point::new(row, start);\n            edits.push((\n                row_start..row_start,\n                indent_delta.chars().collect::<String>(),\n            ));\n\n            // Update this selection's endpoints to reflect the indentation.\n            if row == selection.start.row {\n                selection.start.column += indent_delta.len;\n            }\n            if row == selection.end.row {\n                selection.end.column += indent_delta.len;\n                delta_for_end_row = indent_delta.len;\n            }\n        }\n\n        if selection.start.row == selection.end.row {\n            delta_for_start_row + delta_for_end_row\n        } else {\n            delta_for_end_row\n        }\n    }\n\n    pub fn outdent(&mut self, _: &Outdent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(cx);\n        let mut deletion_ranges = Vec::new();\n        let mut last_outdent = None;\n        {\n            let buffer = self.buffer.read(cx);\n            let snapshot = buffer.snapshot(cx);\n            for selection in &selections {\n                let settings = buffer.settings_at(selection.start, cx);\n                let tab_size = settings.tab_size.get();\n                let mut rows = selection.spanned_rows(false, &display_map);\n\n                // Avoid re-outdenting a row that has already been outdented by a\n                // previous selection.\n                if let Some(last_row) = last_outdent {\n                    if last_row == rows.start {\n                        rows.start = rows.start.next_row();\n                    }\n                }\n                let has_multiple_rows = rows.len() > 1;\n                for row in rows.iter_rows() {\n                    let indent_size = snapshot.indent_size_for_line(row);\n                    if indent_size.len > 0 {\n                        let deletion_len = match indent_size.kind {\n                            IndentKind::Space => {\n                                let columns_to_prev_tab_stop = indent_size.len % tab_size;\n                                if columns_to_prev_tab_stop == 0 {\n                                    tab_size\n                                } else {\n                                    columns_to_prev_tab_stop\n                                }\n                            }\n                            IndentKind::Tab => 1,\n                        };\n                        let start = if has_multiple_rows\n                            || deletion_len > selection.start.column\n                            || indent_size.len < selection.start.column\n                        {\n                            0\n                        } else {\n                            selection.start.column - deletion_len\n                        };\n                        deletion_ranges.push(\n                            Point::new(row.0, start)..Point::new(row.0, start + deletion_len),\n                        );\n                        last_outdent = Some(row);\n                    }\n                }\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                let empty_str: Arc<str> = Arc::default();\n                buffer.edit(\n                    deletion_ranges\n                        .into_iter()\n                        .map(|range| (range, empty_str.clone())),\n                    None,\n                    cx,\n                );\n            });\n            let selections = this.selections.all::<usize>(cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n        });\n    }\n\n    pub fn autoindent(&mut self, _: &AutoIndent, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n        let selections = self\n            .selections\n            .all::<usize>(cx)\n            .into_iter()\n            .map(|s| s.range());\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.autoindent_ranges(selections, cx);\n            });\n            let selections = this.selections.all::<usize>(cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n        });\n    }\n\n    pub fn delete_line(&mut self, _: &DeleteLine, window: &mut Window, cx: &mut Context<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(cx);\n\n        let mut new_cursors = Vec::new();\n        let mut edit_ranges = Vec::new();\n        let mut selections = selections.iter().peekable();\n        while let Some(selection) = selections.next() {\n            let mut rows = selection.spanned_rows(false, &display_map);\n            let goal_display_column = selection.head().to_display_point(&display_map).column();\n\n            // Accumulate contiguous regions of rows that we want to delete.\n            while let Some(next_selection) = selections.peek() {\n                let next_rows = next_selection.spanned_rows(false, &display_map);\n                if next_rows.start <= rows.end {\n                    rows.end = next_rows.end;\n                    selections.next().unwrap();\n                } else {\n                    break;\n                }\n            }\n\n            let buffer = &display_map.buffer_snapshot;\n            let mut edit_start = Point::new(rows.start.0, 0).to_offset(buffer);\n            let edit_end;\n            let cursor_buffer_row;\n            if buffer.max_point().row >= rows.end.0 {\n                // If there's a line after the range, delete the \\n from the end of the row range\n                // and position the cursor on the next line.\n                edit_end = Point::new(rows.end.0, 0).to_offset(buffer);\n                cursor_buffer_row = rows.end;\n            } else {\n                // If there isn't a line after the range, delete the \\n from the line before the\n                // start of the row range and position the cursor there.\n                edit_start = edit_start.saturating_sub(1);\n                edit_end = buffer.len();\n                cursor_buffer_row = rows.start.previous_row();\n            }\n\n            let mut cursor = Point::new(cursor_buffer_row.0, 0).to_display_point(&display_map);\n            *cursor.column_mut() =\n                cmp::min(goal_display_column, display_map.line_len(cursor.row()));\n\n            new_cursors.push((\n                selection.id,\n                buffer.anchor_after(cursor.to_point(&display_map)),\n            ));\n            edit_ranges.push(edit_start..edit_end);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let buffer = this.buffer.update(cx, |buffer, cx| {\n                let empty_str: Arc<str> = Arc::default();\n                buffer.edit(\n                    edit_ranges\n                        .into_iter()\n                        .map(|range| (range, empty_str.clone())),\n                    None,\n                    cx,\n                );\n                buffer.snapshot(cx)\n            });\n            let new_selections = new_cursors\n                .into_iter()\n                .map(|(id, cursor)| {\n                    let cursor = cursor.to_point(&buffer);\n                    Selection {\n                        id,\n                        start: cursor,\n                        end: cursor,\n                        reversed: false,\n                        goal: SelectionGoal::None,\n                    }\n                })\n                .collect();\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n        });\n    }\n\n    pub fn join_lines_impl(\n        &mut self,\n        insert_whitespace: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n        let mut row_ranges = Vec::<Range<MultiBufferRow>>::new();\n        for selection in self.selections.all::<Point>(cx) {\n            let start = MultiBufferRow(selection.start.row);\n            // Treat single line selections as if they include the next line. Otherwise this action\n            // would do nothing for single line selections individual cursors.\n            let end = if selection.start.row == selection.end.row {\n                MultiBufferRow(selection.start.row + 1)\n            } else {\n                MultiBufferRow(selection.end.row)\n            };\n\n            if let Some(last_row_range) = row_ranges.last_mut() {\n                if start <= last_row_range.end {\n                    last_row_range.end = end;\n                    continue;\n                }\n            }\n            row_ranges.push(start..end);\n        }\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut cursor_positions = Vec::new();\n        for row_range in &row_ranges {\n            let anchor = snapshot.anchor_before(Point::new(\n                row_range.end.previous_row().0,\n                snapshot.line_len(row_range.end.previous_row()),\n            ));\n            cursor_positions.push(anchor..anchor);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            for row_range in row_ranges.into_iter().rev() {\n                for row in row_range.iter_rows().rev() {\n                    let end_of_line = Point::new(row.0, snapshot.line_len(row));\n                    let next_line_row = row.next_row();\n                    let indent = snapshot.indent_size_for_line(next_line_row);\n                    let start_of_next_line = Point::new(next_line_row.0, indent.len);\n\n                    let replace =\n                        if snapshot.line_len(next_line_row) > indent.len && insert_whitespace {\n                            \" \"\n                        } else {\n                            \"\"\n                        };\n\n                    this.buffer.update(cx, |buffer, cx| {\n                        buffer.edit([(end_of_line..start_of_next_line, replace)], None, cx)\n                    });\n                }\n            }\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select_anchor_ranges(cursor_positions)\n            });\n        });\n    }\n\n    pub fn join_lines(&mut self, _: &JoinLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.join_lines_impl(true, window, cx);\n    }\n\n    pub fn sort_lines_case_sensitive(\n        &mut self,\n        _: &SortLinesCaseSensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_lines(window, cx, |lines| lines.sort())\n    }\n\n    pub fn sort_lines_case_insensitive(\n        &mut self,\n        _: &SortLinesCaseInsensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_lines(window, cx, |lines| {\n            lines.sort_by_key(|line| line.to_lowercase())\n        })\n    }\n\n    pub fn unique_lines_case_insensitive(\n        &mut self,\n        _: &UniqueLinesCaseInsensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_lines(window, cx, |lines| {\n            let mut seen = HashSet::default();\n            lines.retain(|line| seen.insert(line.to_lowercase()));\n        })\n    }\n\n    pub fn unique_lines_case_sensitive(\n        &mut self,\n        _: &UniqueLinesCaseSensitive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_lines(window, cx, |lines| {\n            let mut seen = HashSet::default();\n            lines.retain(|line| seen.insert(*line));\n        })\n    }\n\n    pub fn revert_file(&mut self, _: &RevertFile, window: &mut Window, cx: &mut Context<Self>) {\n        let mut revert_changes = HashMap::default();\n        let snapshot = self.snapshot(window, cx);\n        for hunk in snapshot\n            .hunks_for_ranges(Some(Point::zero()..snapshot.buffer_snapshot.max_point()).into_iter())\n        {\n            self.prepare_revert_change(&mut revert_changes, &hunk, cx);\n        }\n        if !revert_changes.is_empty() {\n            self.transact(window, cx, |editor, window, cx| {\n                editor.revert(revert_changes, window, cx);\n            });\n        }\n    }\n\n    pub fn reload_file(&mut self, _: &ReloadFile, window: &mut Window, cx: &mut Context<Self>) {\n        let Some(project) = self.project.clone() else {\n            return;\n        };\n        self.reload(project, window, cx)\n            .detach_and_notify_err(window, cx);\n    }\n\n    pub fn revert_selected_hunks(\n        &mut self,\n        _: &RevertSelectedHunks,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.all(cx).into_iter().map(|s| s.range());\n        self.revert_hunks_in_ranges(selections, window, cx);\n    }\n\n    fn revert_hunks_in_ranges(\n        &mut self,\n        ranges: impl Iterator<Item = Range<Point>>,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) {\n        let mut revert_changes = HashMap::default();\n        let snapshot = self.snapshot(window, cx);\n        for hunk in &snapshot.hunks_for_ranges(ranges) {\n            self.prepare_revert_change(&mut revert_changes, &hunk, cx);\n        }\n        if !revert_changes.is_empty() {\n            self.transact(window, cx, |editor, window, cx| {\n                editor.revert(revert_changes, window, cx);\n            });\n        }\n    }\n\n    pub fn open_active_item_in_terminal(\n        &mut self,\n        _: &OpenInTerminal,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(working_directory) = self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let project_path = buffer.read(cx).project_path(cx)?;\n            let project = self.project.as_ref()?.read(cx);\n            let entry = project.entry_for_path(&project_path, cx)?;\n            let parent = match &entry.canonical_path {\n                Some(canonical_path) => canonical_path.to_path_buf(),\n                None => project.absolute_path(&project_path, cx)?,\n            }\n            .parent()?\n            .to_path_buf();\n            Some(parent)\n        }) {\n            window.dispatch_action(OpenTerminal { working_directory }.boxed_clone(), cx);\n        }\n    }\n\n    pub fn prepare_revert_change(\n        &self,\n        revert_changes: &mut HashMap<BufferId, Vec<(Range<text::Anchor>, Rope)>>,\n        hunk: &MultiBufferDiffHunk,\n        cx: &mut App,\n    ) -> Option<()> {\n        let buffer = self.buffer.read(cx);\n        let diff = buffer.diff_for(hunk.buffer_id)?;\n        let buffer = buffer.buffer(hunk.buffer_id)?;\n        let buffer = buffer.read(cx);\n        let original_text = diff\n            .read(cx)\n            .base_text()\n            .as_ref()?\n            .as_rope()\n            .slice(hunk.diff_base_byte_range.clone());\n        let buffer_snapshot = buffer.snapshot();\n        let buffer_revert_changes = revert_changes.entry(buffer.remote_id()).or_default();\n        if let Err(i) = buffer_revert_changes.binary_search_by(|probe| {\n            probe\n                .0\n                .start\n                .cmp(&hunk.buffer_range.start, &buffer_snapshot)\n                .then(probe.0.end.cmp(&hunk.buffer_range.end, &buffer_snapshot))\n        }) {\n            buffer_revert_changes.insert(i, (hunk.buffer_range.clone(), original_text));\n            Some(())\n        } else {\n            None\n        }\n    }\n\n    pub fn reverse_lines(&mut self, _: &ReverseLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.manipulate_lines(window, cx, |lines| lines.reverse())\n    }\n\n    pub fn shuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n        self.manipulate_lines(window, cx, |lines| lines.shuffle(&mut thread_rng()))\n    }\n\n    fn manipulate_lines<Fn>(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        mut callback: Fn,\n    ) where\n        Fn: FnMut(&mut Vec<&str>),\n    {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n\n        let selections = self.selections.all::<Point>(cx);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n        let mut added_lines = 0;\n        let mut removed_lines = 0;\n\n        while let Some(selection) = selections.next() {\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            let start_point = Point::new(start_row.0, 0);\n            let end_point = Point::new(\n                end_row.previous_row().0,\n                buffer.line_len(end_row.previous_row()),\n            );\n            let text = buffer\n                .text_for_range(start_point..end_point)\n                .collect::<String>();\n\n            let mut lines = text.split('\\n').collect_vec();\n\n            let lines_before = lines.len();\n            callback(&mut lines);\n            let lines_after = lines.len();\n\n            edits.push((start_point..end_point, lines.join(\"\\n\")));\n\n            // Selections must change based on added and removed line count\n            let start_row =\n                MultiBufferRow(start_point.row + added_lines as u32 - removed_lines as u32);\n            let end_row = MultiBufferRow(start_row.0 + lines_after.saturating_sub(1) as u32);\n            new_selections.push(Selection {\n                id: selection.id,\n                start: start_row,\n                end: end_row,\n                goal: SelectionGoal::None,\n                reversed: selection.reversed,\n            });\n\n            if lines_after > lines_before {\n                added_lines += lines_after - lines_before;\n            } else if lines_before > lines_after {\n                removed_lines += lines_before - lines_after;\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let buffer = this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n                buffer.snapshot(cx)\n            });\n\n            // Recalculate offsets on newly edited buffer\n            let new_selections = new_selections\n                .iter()\n                .map(|s| {\n                    let start_point = Point::new(s.start.0, 0);\n                    let end_point = Point::new(s.end.0, buffer.line_len(s.end));\n                    Selection {\n                        id: s.id,\n                        start: buffer.point_to_offset(start_point),\n                        end: buffer.point_to_offset(end_point),\n                        goal: s.goal,\n                        reversed: s.reversed,\n                    }\n                })\n                .collect();\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn convert_to_upper_case(\n        &mut self,\n        _: &ConvertToUpperCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_uppercase())\n    }\n\n    pub fn convert_to_lower_case(\n        &mut self,\n        _: &ConvertToLowerCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_lowercase())\n    }\n\n    pub fn convert_to_title_case(\n        &mut self,\n        _: &ConvertToTitleCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.split('\\n')\n                .map(|line| line.to_case(Case::Title))\n                .join(\"\\n\")\n        })\n    }\n\n    pub fn convert_to_snake_case(\n        &mut self,\n        _: &ConvertToSnakeCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Snake))\n    }\n\n    pub fn convert_to_kebab_case(\n        &mut self,\n        _: &ConvertToKebabCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Kebab))\n    }\n\n    pub fn convert_to_upper_camel_case(\n        &mut self,\n        _: &ConvertToUpperCamelCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.split('\\n')\n                .map(|line| line.to_case(Case::UpperCamel))\n                .join(\"\\n\")\n        })\n    }\n\n    pub fn convert_to_lower_camel_case(\n        &mut self,\n        _: &ConvertToLowerCamelCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| text.to_case(Case::Camel))\n    }\n\n    pub fn convert_to_opposite_case(\n        &mut self,\n        _: &ConvertToOppositeCase,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.manipulate_text(window, cx, |text| {\n            text.chars()\n                .fold(String::with_capacity(text.len()), |mut t, c| {\n                    if c.is_uppercase() {\n                        t.extend(c.to_lowercase());\n                    } else {\n                        t.extend(c.to_uppercase());\n                    }\n                    t\n                })\n        })\n    }\n\n    fn manipulate_text<Fn>(&mut self, window: &mut Window, cx: &mut Context<Self>, mut callback: Fn)\n    where\n        Fn: FnMut(&str) -> String,\n    {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut new_selections = Vec::new();\n        let mut edits = Vec::new();\n        let mut selection_adjustment = 0i32;\n\n        for selection in self.selections.all::<usize>(cx) {\n            let selection_is_empty = selection.is_empty();\n\n            let (start, end) = if selection_is_empty {\n                let word_range = movement::surrounding_word(\n                    &display_map,\n                    selection.start.to_display_point(&display_map),\n                );\n                let start = word_range.start.to_offset(&display_map, Bias::Left);\n                let end = word_range.end.to_offset(&display_map, Bias::Left);\n                (start, end)\n            } else {\n                (selection.start, selection.end)\n            };\n\n            let text = buffer.text_for_range(start..end).collect::<String>();\n            let old_length = text.len() as i32;\n            let text = callback(&text);\n\n            new_selections.push(Selection {\n                start: (start as i32 - selection_adjustment) as usize,\n                end: ((start + text.len()) as i32 - selection_adjustment) as usize,\n                goal: SelectionGoal::None,\n                ..selection\n            });\n\n            selection_adjustment += old_length - text.len() as i32;\n\n            edits.push((start..end, text));\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn duplicate(\n        &mut self,\n        upwards: bool,\n        whole_lines: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let selections = self.selections.all::<Point>(cx);\n\n        let mut edits = Vec::new();\n        let mut selections_iter = selections.iter().peekable();\n        while let Some(selection) = selections_iter.next() {\n            let mut rows = selection.spanned_rows(false, &display_map);\n            // duplicate line-wise\n            if whole_lines || selection.start == selection.end {\n                // Avoid duplicating the same lines twice.\n                while let Some(next_selection) = selections_iter.peek() {\n                    let next_rows = next_selection.spanned_rows(false, &display_map);\n                    if next_rows.start < rows.end {\n                        rows.end = next_rows.end;\n                        selections_iter.next().unwrap();\n                    } else {\n                        break;\n                    }\n                }\n\n                // Copy the text from the selected row region and splice it either at the start\n                // or end of the region.\n                let start = Point::new(rows.start.0, 0);\n                let end = Point::new(\n                    rows.end.previous_row().0,\n                    buffer.line_len(rows.end.previous_row()),\n                );\n                let text = buffer\n                    .text_for_range(start..end)\n                    .chain(Some(\"\\n\"))\n                    .collect::<String>();\n                let insert_location = if upwards {\n                    Point::new(rows.end.0, 0)\n                } else {\n                    start\n                };\n                edits.push((insert_location..insert_location, text));\n            } else {\n                // duplicate character-wise\n                let start = selection.start;\n                let end = selection.end;\n                let text = buffer.text_for_range(start..end).collect::<String>();\n                edits.push((selection.end..selection.end, text));\n            }\n        }\n\n        self.transact(window, cx, |this, _, cx| {\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            this.request_autoscroll(Autoscroll::fit(), cx);\n        });\n    }\n\n    pub fn duplicate_line_up(\n        &mut self,\n        _: &DuplicateLineUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(true, true, window, cx);\n    }\n\n    pub fn duplicate_line_down(\n        &mut self,\n        _: &DuplicateLineDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(false, true, window, cx);\n    }\n\n    pub fn duplicate_selection(\n        &mut self,\n        _: &DuplicateSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.duplicate(false, false, window, cx);\n    }\n\n    pub fn move_line_up(&mut self, _: &MoveLineUp, window: &mut Window, cx: &mut Context<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut unfold_ranges = Vec::new();\n        let mut refold_creases = Vec::new();\n\n        let selections = self.selections.all::<Point>(cx);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n\n        while let Some(selection) = selections.next() {\n            // Find all the selections that span a contiguous row range\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            // Move the text spanned by the row range to be before the line preceding the row range\n            if start_row.0 > 0 {\n                let range_to_move = Point::new(\n                    start_row.previous_row().0,\n                    buffer.line_len(start_row.previous_row()),\n                )\n                    ..Point::new(\n                        end_row.previous_row().0,\n                        buffer.line_len(end_row.previous_row()),\n                    );\n                let insertion_point = display_map\n                    .prev_line_boundary(Point::new(start_row.previous_row().0, 0))\n                    .0;\n\n                // Don't move lines across excerpts\n                if buffer\n                    .excerpt_containing(insertion_point..range_to_move.end)\n                    .is_some()\n                {\n                    let text = buffer\n                        .text_for_range(range_to_move.clone())\n                        .flat_map(|s| s.chars())\n                        .skip(1)\n                        .chain(['\\n'])\n                        .collect::<String>();\n\n                    edits.push((\n                        buffer.anchor_after(range_to_move.start)\n                            ..buffer.anchor_before(range_to_move.end),\n                        String::new(),\n                    ));\n                    let insertion_anchor = buffer.anchor_after(insertion_point);\n                    edits.push((insertion_anchor..insertion_anchor, text));\n\n                    let row_delta = range_to_move.start.row - insertion_point.row + 1;\n\n                    // Move selections up\n                    new_selections.extend(contiguous_row_selections.drain(..).map(\n                        |mut selection| {\n                            selection.start.row -= row_delta;\n                            selection.end.row -= row_delta;\n                            selection\n                        },\n                    ));\n\n                    // Move folds up\n                    unfold_ranges.push(range_to_move.clone());\n                    for fold in display_map.folds_in_range(\n                        buffer.anchor_before(range_to_move.start)\n                            ..buffer.anchor_after(range_to_move.end),\n                    ) {\n                        let mut start = fold.range.start.to_point(&buffer);\n                        let mut end = fold.range.end.to_point(&buffer);\n                        start.row -= row_delta;\n                        end.row -= row_delta;\n                        refold_creases.push(Crease::simple(start..end, fold.placeholder.clone()));\n                    }\n                }\n            }\n\n            // If we didn't move line(s), preserve the existing selections\n            new_selections.append(&mut contiguous_row_selections);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.unfold_ranges(&unfold_ranges, true, true, cx);\n            this.buffer.update(cx, |buffer, cx| {\n                for (range, text) in edits {\n                    buffer.edit([(range, text)], None, cx);\n                }\n            });\n            this.fold_creases(refold_creases, true, window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            })\n        });\n    }\n\n    pub fn move_line_down(\n        &mut self,\n        _: &MoveLineDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n\n        let mut edits = Vec::new();\n        let mut unfold_ranges = Vec::new();\n        let mut refold_creases = Vec::new();\n\n        let selections = self.selections.all::<Point>(cx);\n        let mut selections = selections.iter().peekable();\n        let mut contiguous_row_selections = Vec::new();\n        let mut new_selections = Vec::new();\n\n        while let Some(selection) = selections.next() {\n            // Find all the selections that span a contiguous row range\n            let (start_row, end_row) = consume_contiguous_rows(\n                &mut contiguous_row_selections,\n                selection,\n                &display_map,\n                &mut selections,\n            );\n\n            // Move the text spanned by the row range to be after the last line of the row range\n            if end_row.0 <= buffer.max_point().row {\n                let range_to_move =\n                    MultiBufferPoint::new(start_row.0, 0)..MultiBufferPoint::new(end_row.0, 0);\n                let insertion_point = display_map\n                    .next_line_boundary(MultiBufferPoint::new(end_row.0, 0))\n                    .0;\n\n                // Don't move lines across excerpt boundaries\n                if buffer\n                    .excerpt_containing(range_to_move.start..insertion_point)\n                    .is_some()\n                {\n                    let mut text = String::from(\"\\n\");\n                    text.extend(buffer.text_for_range(range_to_move.clone()));\n                    text.pop(); // Drop trailing newline\n                    edits.push((\n                        buffer.anchor_after(range_to_move.start)\n                            ..buffer.anchor_before(range_to_move.end),\n                        String::new(),\n                    ));\n                    let insertion_anchor = buffer.anchor_after(insertion_point);\n                    edits.push((insertion_anchor..insertion_anchor, text));\n\n                    let row_delta = insertion_point.row - range_to_move.end.row + 1;\n\n                    // Move selections down\n                    new_selections.extend(contiguous_row_selections.drain(..).map(\n                        |mut selection| {\n                            selection.start.row += row_delta;\n                            selection.end.row += row_delta;\n                            selection\n                        },\n                    ));\n\n                    // Move folds down\n                    unfold_ranges.push(range_to_move.clone());\n                    for fold in display_map.folds_in_range(\n                        buffer.anchor_before(range_to_move.start)\n                            ..buffer.anchor_after(range_to_move.end),\n                    ) {\n                        let mut start = fold.range.start.to_point(&buffer);\n                        let mut end = fold.range.end.to_point(&buffer);\n                        start.row += row_delta;\n                        end.row += row_delta;\n                        refold_creases.push(Crease::simple(start..end, fold.placeholder.clone()));\n                    }\n                }\n            }\n\n            // If we didn't move line(s), preserve the existing selections\n            new_selections.append(&mut contiguous_row_selections);\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.unfold_ranges(&unfold_ranges, true, true, cx);\n            this.buffer.update(cx, |buffer, cx| {\n                for (range, text) in edits {\n                    buffer.edit([(range, text)], None, cx);\n                }\n            });\n            this.fold_creases(refold_creases, true, window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections)\n            });\n        });\n    }\n\n    pub fn transpose(&mut self, _: &Transpose, window: &mut Window, cx: &mut Context<Self>) {\n        let text_layout_details = &self.text_layout_details(window);\n        self.transact(window, cx, |this, window, cx| {\n            let edits = this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let mut edits: Vec<(Range<usize>, String)> = Default::default();\n                let line_mode = s.line_mode;\n                s.move_with(|display_map, selection| {\n                    if !selection.is_empty() || line_mode {\n                        return;\n                    }\n\n                    let mut head = selection.head();\n                    let mut transpose_offset = head.to_offset(display_map, Bias::Right);\n                    if head.column() == display_map.line_len(head.row()) {\n                        transpose_offset = display_map\n                            .buffer_snapshot\n                            .clip_offset(transpose_offset.saturating_sub(1), Bias::Left);\n                    }\n\n                    if transpose_offset == 0 {\n                        return;\n                    }\n\n                    *head.column_mut() += 1;\n                    head = display_map.clip_point(head, Bias::Right);\n                    let goal = SelectionGoal::HorizontalPosition(\n                        display_map\n                            .x_for_display_point(head, text_layout_details)\n                            .into(),\n                    );\n                    selection.collapse_to(head, goal);\n\n                    let transpose_start = display_map\n                        .buffer_snapshot\n                        .clip_offset(transpose_offset.saturating_sub(1), Bias::Left);\n                    if edits.last().map_or(true, |e| e.0.end <= transpose_start) {\n                        let transpose_end = display_map\n                            .buffer_snapshot\n                            .clip_offset(transpose_offset + 1, Bias::Right);\n                        if let Some(ch) =\n                            display_map.buffer_snapshot.chars_at(transpose_start).next()\n                        {\n                            edits.push((transpose_start..transpose_offset, String::new()));\n                            edits.push((transpose_end..transpose_end, ch.to_string()));\n                        }\n                    }\n                });\n                edits\n            });\n            this.buffer\n                .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n            let selections = this.selections.all::<usize>(cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections);\n            });\n        });\n    }\n\n    pub fn rewrap(&mut self, _: &Rewrap, _: &mut Window, cx: &mut Context<Self>) {\n        self.rewrap_impl(IsVimMode::No, cx)\n    }\n\n    pub fn rewrap_impl(&mut self, is_vim_mode: IsVimMode, cx: &mut Context<Self>) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selections = self.selections.all::<Point>(cx);\n        let mut selections = selections.iter().peekable();\n\n        let mut edits = Vec::new();\n        let mut rewrapped_row_ranges = Vec::<RangeInclusive<u32>>::new();\n\n        while let Some(selection) = selections.next() {\n            let mut start_row = selection.start.row;\n            let mut end_row = selection.end.row;\n\n            // Skip selections that overlap with a range that has already been rewrapped.\n            let selection_range = start_row..end_row;\n            if rewrapped_row_ranges\n                .iter()\n                .any(|range| range.overlaps(&selection_range))\n            {\n                continue;\n            }\n\n            let mut should_rewrap = is_vim_mode == IsVimMode::Yes;\n\n            if let Some(language_scope) = buffer.language_scope_at(selection.head()) {\n                match language_scope.language_name().as_ref() {\n                    \"Markdown\" | \"Plain Text\" => {\n                        should_rewrap = true;\n                    }\n                    _ => {}\n                }\n            }\n\n            let tab_size = buffer.settings_at(selection.head(), cx).tab_size;\n\n            // Since not all lines in the selection may be at the same indent\n            // level, choose the indent size that is the most common between all\n            // of the lines.\n            //\n            // If there is a tie, we use the deepest indent.\n            let (indent_size, indent_end) = {\n                let mut indent_size_occurrences = HashMap::default();\n                let mut rows_by_indent_size = HashMap::<IndentSize, Vec<u32>>::default();\n\n                for row in start_row..=end_row {\n                    let indent = buffer.indent_size_for_line(MultiBufferRow(row));\n                    rows_by_indent_size.entry(indent).or_default().push(row);\n                    *indent_size_occurrences.entry(indent).or_insert(0) += 1;\n                }\n\n                let indent_size = indent_size_occurrences\n                    .into_iter()\n                    .max_by_key(|(indent, count)| (*count, indent.len_with_expanded_tabs(tab_size)))\n                    .map(|(indent, _)| indent)\n                    .unwrap_or_default();\n                let row = rows_by_indent_size[&indent_size][0];\n                let indent_end = Point::new(row, indent_size.len);\n\n                (indent_size, indent_end)\n            };\n\n            let mut line_prefix = indent_size.chars().collect::<String>();\n\n            if let Some(comment_prefix) =\n                buffer\n                    .language_scope_at(selection.head())\n                    .and_then(|language| {\n                        language\n                            .line_comment_prefixes()\n                            .iter()\n                            .find(|prefix| buffer.contains_str_at(indent_end, prefix))\n                            .cloned()\n                    })\n            {\n                line_prefix.push_str(&comment_prefix);\n                should_rewrap = true;\n            }\n\n            if !should_rewrap {\n                continue;\n            }\n\n            if selection.is_empty() {\n                'expand_upwards: while start_row > 0 {\n                    let prev_row = start_row - 1;\n                    if buffer.contains_str_at(Point::new(prev_row, 0), &line_prefix)\n                        && buffer.line_len(MultiBufferRow(prev_row)) as usize > line_prefix.len()\n                    {\n                        start_row = prev_row;\n                    } else {\n                        break 'expand_upwards;\n                    }\n                }\n\n                'expand_downwards: while end_row < buffer.max_point().row {\n                    let next_row = end_row + 1;\n                    if buffer.contains_str_at(Point::new(next_row, 0), &line_prefix)\n                        && buffer.line_len(MultiBufferRow(next_row)) as usize > line_prefix.len()\n                    {\n                        end_row = next_row;\n                    } else {\n                        break 'expand_downwards;\n                    }\n                }\n            }\n\n            let start = Point::new(start_row, 0);\n            let end = Point::new(end_row, buffer.line_len(MultiBufferRow(end_row)));\n            let selection_text = buffer.text_for_range(start..end).collect::<String>();\n            let Some(lines_without_prefixes) = selection_text\n                .lines()\n                .map(|line| {\n                    line.strip_prefix(&line_prefix)\n                        .or_else(|| line.trim_start().strip_prefix(&line_prefix.trim_start()))\n                        .ok_or_else(|| {\n                            anyhow!(\"line did not start with prefix {line_prefix:?}: {line:?}\")\n                        })\n                })\n                .collect::<Result<Vec<_>, _>>()\n                .log_err()\n            else {\n                continue;\n            };\n\n            let wrap_column = buffer\n                .settings_at(Point::new(start_row, 0), cx)\n                .preferred_line_length as usize;\n            let wrapped_text = wrap_with_prefix(\n                line_prefix,\n                lines_without_prefixes.join(\" \"),\n                wrap_column,\n                tab_size,\n            );\n\n            // TODO: should always use char-based diff while still supporting cursor behavior that\n            // matches vim.\n            let diff = match is_vim_mode {\n                IsVimMode::Yes => TextDiff::from_lines(&selection_text, &wrapped_text),\n                IsVimMode::No => TextDiff::from_chars(&selection_text, &wrapped_text),\n            };\n            let mut offset = start.to_offset(&buffer);\n            let mut moved_since_edit = true;\n\n            for change in diff.iter_all_changes() {\n                let value = change.value();\n                match change.tag() {\n                    ChangeTag::Equal => {\n                        offset += value.len();\n                        moved_since_edit = true;\n                    }\n                    ChangeTag::Delete => {\n                        let start = buffer.anchor_after(offset);\n                        let end = buffer.anchor_before(offset + value.len());\n\n                        if moved_since_edit {\n                            edits.push((start..end, String::new()));\n                        } else {\n                            edits.last_mut().unwrap().0.end = end;\n                        }\n\n                        offset += value.len();\n                        moved_since_edit = false;\n                    }\n                    ChangeTag::Insert => {\n                        if moved_since_edit {\n                            let anchor = buffer.anchor_after(offset);\n                            edits.push((anchor..anchor, value.to_string()));\n                        } else {\n                            edits.last_mut().unwrap().1.push_str(value);\n                        }\n\n                        moved_since_edit = false;\n                    }\n                }\n            }\n\n            rewrapped_row_ranges.push(start_row..=end_row);\n        }\n\n        self.buffer\n            .update(cx, |buffer, cx| buffer.edit(edits, None, cx));\n    }\n\n    pub fn cut_common(&mut self, window: &mut Window, cx: &mut Context<Self>) -> ClipboardItem {\n        let mut text = String::new();\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selections = self.selections.all::<Point>(cx);\n        let mut clipboard_selections = Vec::with_capacity(selections.len());\n        {\n            let max_point = buffer.max_point();\n            let mut is_first = true;\n            for selection in &mut selections {\n                let is_entire_line = selection.is_empty() || self.selections.line_mode;\n                if is_entire_line {\n                    selection.start = Point::new(selection.start.row, 0);\n                    if !selection.is_empty() && selection.end.column == 0 {\n                        selection.end = cmp::min(max_point, selection.end);\n                    } else {\n                        selection.end = cmp::min(max_point, Point::new(selection.end.row + 1, 0));\n                    }\n                    selection.goal = SelectionGoal::None;\n                }\n                if is_first {\n                    is_first = false;\n                } else {\n                    text += \"\\n\";\n                }\n                let mut len = 0;\n                for chunk in buffer.text_for_range(selection.start..selection.end) {\n                    text.push_str(chunk);\n                    len += chunk.len();\n                }\n                clipboard_selections.push(ClipboardSelection {\n                    len,\n                    is_entire_line,\n                    first_line_indent: buffer\n                        .indent_size_for_line(MultiBufferRow(selection.start.row))\n                        .len,\n                });\n            }\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections);\n            });\n            this.insert(\"\", window, cx);\n        });\n        ClipboardItem::new_string_with_json_metadata(text, clipboard_selections)\n    }\n\n    pub fn cut(&mut self, _: &Cut, window: &mut Window, cx: &mut Context<Self>) {\n        let item = self.cut_common(window, cx);\n        cx.write_to_clipboard(item);\n    }\n\n    pub fn kill_ring_cut(&mut self, _: &KillRingCut, window: &mut Window, cx: &mut Context<Self>) {\n        self.change_selections(None, window, cx, |s| {\n            s.move_with(|snapshot, sel| {\n                if sel.is_empty() {\n                    sel.end = DisplayPoint::new(sel.end.row(), snapshot.line_len(sel.end.row()))\n                }\n            });\n        });\n        let item = self.cut_common(window, cx);\n        cx.set_global(KillRing(item))\n    }\n\n    pub fn kill_ring_yank(\n        &mut self,\n        _: &KillRingYank,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let (text, metadata) = if let Some(KillRing(item)) = cx.try_global() {\n            if let Some(ClipboardEntry::String(kill_ring)) = item.entries().first() {\n                (kill_ring.text().to_string(), kill_ring.metadata_json())\n            } else {\n                return;\n            }\n        } else {\n            return;\n        };\n        self.do_paste(&text, metadata, false, window, cx);\n    }\n\n    pub fn copy(&mut self, _: &Copy, _: &mut Window, cx: &mut Context<Self>) {\n        let selections = self.selections.all::<Point>(cx);\n        let buffer = self.buffer.read(cx).read(cx);\n        let mut text = String::new();\n\n        let mut clipboard_selections = Vec::with_capacity(selections.len());\n        {\n            let max_point = buffer.max_point();\n            let mut is_first = true;\n            for selection in selections.iter() {\n                let mut start = selection.start;\n                let mut end = selection.end;\n                let is_entire_line = selection.is_empty() || self.selections.line_mode;\n                if is_entire_line {\n                    start = Point::new(start.row, 0);\n                    end = cmp::min(max_point, Point::new(end.row + 1, 0));\n                }\n                if is_first {\n                    is_first = false;\n                } else {\n                    text += \"\\n\";\n                }\n                let mut len = 0;\n                for chunk in buffer.text_for_range(start..end) {\n                    text.push_str(chunk);\n                    len += chunk.len();\n                }\n                clipboard_selections.push(ClipboardSelection {\n                    len,\n                    is_entire_line,\n                    first_line_indent: buffer.indent_size_for_line(MultiBufferRow(start.row)).len,\n                });\n            }\n        }\n\n        cx.write_to_clipboard(ClipboardItem::new_string_with_json_metadata(\n            text,\n            clipboard_selections,\n        ));\n    }\n\n    pub fn do_paste(\n        &mut self,\n        text: &String,\n        clipboard_selections: Option<Vec<ClipboardSelection>>,\n        handle_entire_lines: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        let clipboard_text = Cow::Borrowed(text);\n\n        self.transact(window, cx, |this, window, cx| {\n            if let Some(mut clipboard_selections) = clipboard_selections {\n                let old_selections = this.selections.all::<usize>(cx);\n                let all_selections_were_entire_line =\n                    clipboard_selections.iter().all(|s| s.is_entire_line);\n                let first_selection_indent_column =\n                    clipboard_selections.first().map(|s| s.first_line_indent);\n                if clipboard_selections.len() != old_selections.len() {\n                    clipboard_selections.drain(..);\n                }\n                let cursor_offset = this.selections.last::<usize>(cx).head();\n                let mut auto_indent_on_paste = true;\n\n                this.buffer.update(cx, |buffer, cx| {\n                    let snapshot = buffer.read(cx);\n                    auto_indent_on_paste =\n                        snapshot.settings_at(cursor_offset, cx).auto_indent_on_paste;\n\n                    let mut start_offset = 0;\n                    let mut edits = Vec::new();\n                    let mut original_indent_columns = Vec::new();\n                    for (ix, selection) in old_selections.iter().enumerate() {\n                        let to_insert;\n                        let entire_line;\n                        let original_indent_column;\n                        if let Some(clipboard_selection) = clipboard_selections.get(ix) {\n                            let end_offset = start_offset + clipboard_selection.len;\n                            to_insert = &clipboard_text[start_offset..end_offset];\n                            entire_line = clipboard_selection.is_entire_line;\n                            start_offset = end_offset + 1;\n                            original_indent_column = Some(clipboard_selection.first_line_indent);\n                        } else {\n                            to_insert = clipboard_text.as_str();\n                            entire_line = all_selections_were_entire_line;\n                            original_indent_column = first_selection_indent_column\n                        }\n\n                        // If the corresponding selection was empty when this slice of the\n                        // clipboard text was written, then the entire line containing the\n                        // selection was copied. If this selection is also currently empty,\n                        // then paste the line before the current line of the buffer.\n                        let range = if selection.is_empty() && handle_entire_lines && entire_line {\n                            let column = selection.start.to_point(&snapshot).column as usize;\n                            let line_start = selection.start - column;\n                            line_start..line_start\n                        } else {\n                            selection.range()\n                        };\n\n                        edits.push((range, to_insert));\n                        original_indent_columns.extend(original_indent_column);\n                    }\n                    drop(snapshot);\n\n                    buffer.edit(\n                        edits,\n                        if auto_indent_on_paste {\n                            Some(AutoindentMode::Block {\n                                original_indent_columns,\n                            })\n                        } else {\n                            None\n                        },\n                        cx,\n                    );\n                });\n\n                let selections = this.selections.all::<usize>(cx);\n                this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.select(selections)\n                });\n            } else {\n                this.insert(&clipboard_text, window, cx);\n            }\n        });\n    }\n\n    pub fn paste(&mut self, _: &Paste, window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(item) = cx.read_from_clipboard() {\n            let entries = item.entries();\n\n            match entries.first() {\n                // For now, we only support applying metadata if there's one string. In the future, we can incorporate all the selections\n                // of all the pasted entries.\n                Some(ClipboardEntry::String(clipboard_string)) if entries.len() == 1 => self\n                    .do_paste(\n                        clipboard_string.text(),\n                        clipboard_string.metadata_json::<Vec<ClipboardSelection>>(),\n                        true,\n                        window,\n                        cx,\n                    ),\n                _ => self.do_paste(&item.text().unwrap_or_default(), None, true, window, cx),\n            }\n        }\n    }\n\n    pub fn undo(&mut self, _: &Undo, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        if let Some(transaction_id) = self.buffer.update(cx, |buffer, cx| buffer.undo(cx)) {\n            if let Some((selections, _)) =\n                self.selection_history.transaction(transaction_id).cloned()\n            {\n                self.change_selections(None, window, cx, |s| {\n                    s.select_anchors(selections.to_vec());\n                });\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_inline_completion(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n            cx.emit(EditorEvent::TransactionUndone { transaction_id });\n        }\n    }\n\n    pub fn redo(&mut self, _: &Redo, window: &mut Window, cx: &mut Context<Self>) {\n        if self.read_only(cx) {\n            return;\n        }\n\n        if let Some(transaction_id) = self.buffer.update(cx, |buffer, cx| buffer.redo(cx)) {\n            if let Some((_, Some(selections))) =\n                self.selection_history.transaction(transaction_id).cloned()\n            {\n                self.change_selections(None, window, cx, |s| {\n                    s.select_anchors(selections.to_vec());\n                });\n            }\n            self.request_autoscroll(Autoscroll::fit(), cx);\n            self.unmark_text(window, cx);\n            self.refresh_inline_completion(true, false, window, cx);\n            cx.emit(EditorEvent::Edited { transaction_id });\n        }\n    }\n\n    pub fn finalize_last_transaction(&mut self, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.finalize_last_transaction(cx));\n    }\n\n    pub fn group_until_transaction(&mut self, tx_id: TransactionId, cx: &mut Context<Self>) {\n        self.buffer\n            .update(cx, |buffer, cx| buffer.group_until_transaction(tx_id, cx));\n    }\n\n    pub fn move_left(&mut self, _: &MoveLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() && !line_mode {\n                    movement::left(map, selection.start)\n                } else {\n                    selection.start\n                };\n                selection.collapse_to(cursor, SelectionGoal::None);\n            });\n        })\n    }\n\n    pub fn select_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n        })\n    }\n\n    pub fn move_right(&mut self, _: &MoveRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                let cursor = if selection.is_empty() && !line_mode {\n                    movement::right(map, selection.end)\n                } else {\n                    selection.end\n                };\n                selection.collapse_to(cursor, SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n        })\n    }\n\n    pub fn move_up(&mut self, _: &MoveUp, window: &mut Window, cx: &mut Context<Self>) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up(\n                    map,\n                    selection.start,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn move_up_by_lines(\n        &mut self,\n        action: &MoveUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn move_down_by_lines(\n        &mut self,\n        action: &MoveDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.start,\n                    action.lines,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        })\n    }\n\n    pub fn select_down_by_lines(\n        &mut self,\n        action: &SelectDownByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_up_by_lines(\n        &mut self,\n        action: &SelectUpByLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, action.lines, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn select_page_up(\n        &mut self,\n        _: &SelectPageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_up(\n        &mut self,\n        action: &MovePageUp,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_first(self.completion_provider.as_deref(), cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        let autoscroll = if action.center_cursor {\n            Autoscroll::center()\n        } else {\n            Autoscroll::fit()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(autoscroll), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::up_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::up(map, head, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_down(&mut self, _: &MoveDown, window: &mut Window, cx: &mut Context<Self>) {\n        self.take_rename(true, window, cx);\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let text_layout_details = &self.text_layout_details(window);\n        let selection_count = self.selections.count();\n        let first_selection = self.selections.first_anchor();\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down(\n                    map,\n                    selection.end,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n\n        if selection_count == 1 && first_selection.range() == self.selections.first_anchor().range()\n        {\n            cx.propagate();\n        }\n    }\n\n    pub fn select_page_down(\n        &mut self,\n        _: &SelectPageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down_by_rows(map, head, row_count, goal, false, text_layout_details)\n            })\n        })\n    }\n\n    pub fn move_page_down(\n        &mut self,\n        action: &MovePageDown,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.take_rename(true, window, cx).is_some() {\n            return;\n        }\n\n        if self\n            .context_menu\n            .borrow_mut()\n            .as_mut()\n            .map(|menu| menu.select_last(self.completion_provider.as_deref(), cx))\n            .unwrap_or(false)\n        {\n            return;\n        }\n\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let Some(row_count) = self.visible_row_count() else {\n            return;\n        };\n\n        let autoscroll = if action.center_cursor {\n            Autoscroll::center()\n        } else {\n            Autoscroll::fit()\n        };\n\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(autoscroll), window, cx, |s| {\n            let line_mode = s.line_mode;\n            s.move_with(|map, selection| {\n                if !selection.is_empty() && !line_mode {\n                    selection.goal = SelectionGoal::None;\n                }\n                let (cursor, goal) = movement::down_by_rows(\n                    map,\n                    selection.end,\n                    row_count,\n                    selection.goal,\n                    false,\n                    text_layout_details,\n                );\n                selection.collapse_to(cursor, goal);\n            });\n        });\n    }\n\n    pub fn select_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n        let text_layout_details = &self.text_layout_details(window);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, goal| {\n                movement::down(map, head, goal, false, text_layout_details)\n            })\n        });\n    }\n\n    pub fn context_menu_first(\n        &mut self,\n        _: &ContextMenuFirst,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_first(self.completion_provider.as_deref(), cx);\n        }\n    }\n\n    pub fn context_menu_prev(\n        &mut self,\n        _: &ContextMenuPrev,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_prev(self.completion_provider.as_deref(), cx);\n        }\n    }\n\n    pub fn context_menu_next(\n        &mut self,\n        _: &ContextMenuNext,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_next(self.completion_provider.as_deref(), cx);\n        }\n    }\n\n    pub fn context_menu_last(\n        &mut self,\n        _: &ContextMenuLast,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(context_menu) = self.context_menu.borrow_mut().as_mut() {\n            context_menu.select_last(self.completion_provider.as_deref(), cx);\n        }\n    }\n\n    pub fn move_to_previous_word_start(\n        &mut self,\n        _: &MoveToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_previous_subword_start(\n        &mut self,\n        _: &MoveToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_word_start(\n        &mut self,\n        _: &SelectToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_word_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_previous_subword_start(\n        &mut self,\n        _: &SelectToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::previous_subword_start(map, head),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_previous_word_start(\n        &mut self,\n        action: &DeleteToPreviousWordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let line_mode = s.line_mode;\n                s.move_with(|map, selection| {\n                    if selection.is_empty() && !line_mode {\n                        let cursor = if action.ignore_newlines {\n                            movement::previous_word_start(map, selection.head())\n                        } else {\n                            movement::previous_word_start_or_newline(map, selection.head())\n                        };\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(\"\", window, cx);\n        });\n    }\n\n    pub fn delete_to_previous_subword_start(\n        &mut self,\n        _: &DeleteToPreviousSubwordStart,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_autoclose_pair(window, cx);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let line_mode = s.line_mode;\n                s.move_with(|map, selection| {\n                    if selection.is_empty() && !line_mode {\n                        let cursor = movement::previous_subword_start(map, selection.head());\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(\"\", window, cx);\n        });\n    }\n\n    pub fn move_to_next_word_end(\n        &mut self,\n        _: &MoveToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn move_to_next_subword_end(\n        &mut self,\n        _: &MoveToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_word_end(\n        &mut self,\n        _: &SelectToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_word_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn select_to_next_subword_end(\n        &mut self,\n        _: &SelectToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (movement::next_subword_end(map, head), SelectionGoal::None)\n            });\n        })\n    }\n\n    pub fn delete_to_next_word_end(\n        &mut self,\n        action: &DeleteToNextWordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                let line_mode = s.line_mode;\n                s.move_with(|map, selection| {\n                    if selection.is_empty() && !line_mode {\n                        let cursor = if action.ignore_newlines {\n                            movement::next_word_end(map, selection.head())\n                        } else {\n                            movement::next_word_end_or_newline(map, selection.head())\n                        };\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(\"\", window, cx);\n        });\n    }\n\n    pub fn delete_to_next_subword_end(\n        &mut self,\n        _: &DeleteToNextSubwordEnd,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|map, selection| {\n                    if selection.is_empty() {\n                        let cursor = movement::next_subword_end(map, selection.head());\n                        selection.set_head(cursor, SelectionGoal::None);\n                    }\n                });\n            });\n            this.insert(\"\", window, cx);\n        });\n    }\n\n    pub fn move_to_beginning_of_line(\n        &mut self,\n        action: &MoveToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_beginning_of_line(\n        &mut self,\n        action: &SelectToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::indented_line_beginning(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        });\n    }\n\n    pub fn delete_to_beginning_of_line(\n        &mut self,\n        _: &DeleteToBeginningOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.move_with(|_, selection| {\n                    selection.reversed = true;\n                });\n            });\n\n            this.select_to_beginning_of_line(\n                &SelectToBeginningOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.backspace(&Backspace, window, cx);\n        });\n    }\n\n    pub fn move_to_end_of_line(\n        &mut self,\n        action: &MoveToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_cursors_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_line(\n        &mut self,\n        action: &SelectToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::line_end(map, head, action.stop_at_soft_wraps),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn delete_to_end_of_line(\n        &mut self,\n        _: &DeleteToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.delete(&Delete, window, cx);\n        });\n    }\n\n    pub fn cut_to_end_of_line(\n        &mut self,\n        _: &CutToEndOfLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, window, cx| {\n            this.select_to_end_of_line(\n                &SelectToEndOfLine {\n                    stop_at_soft_wraps: false,\n                },\n                window,\n                cx,\n            );\n            this.cut(&Cut, window, cx);\n        });\n    }\n\n    pub fn move_to_start_of_paragraph(\n        &mut self,\n        _: &MoveToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::start_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_end_of_paragraph(\n        &mut self,\n        _: &MoveToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_with(|map, selection| {\n                selection.collapse_to(\n                    movement::end_of_paragraph(map, selection.head(), 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_start_of_paragraph(\n        &mut self,\n        _: &SelectToStartOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::start_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn select_to_end_of_paragraph(\n        &mut self,\n        _: &SelectToEndOfParagraph,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_heads_with(|map, head, _| {\n                (\n                    movement::end_of_paragraph(map, head, 1),\n                    SelectionGoal::None,\n                )\n            });\n        })\n    }\n\n    pub fn move_to_beginning(\n        &mut self,\n        _: &MoveToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(vec![0..0]);\n        });\n    }\n\n    pub fn select_to_beginning(\n        &mut self,\n        _: &SelectToBeginning,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut selection = self.selections.last::<Point>(cx);\n        selection.set_head(Point::zero(), SelectionGoal::None);\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn move_to_end(&mut self, _: &MoveToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        if matches!(self.mode, EditorMode::SingleLine { .. }) {\n            cx.propagate();\n            return;\n        }\n\n        let cursor = self.buffer.read(cx).read(cx).len();\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(vec![cursor..cursor])\n        });\n    }\n\n    pub fn set_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n        self.nav_history = nav_history;\n    }\n\n    pub fn nav_history(&self) -> Option<&ItemNavHistory> {\n        self.nav_history.as_ref()\n    }\n\n    fn push_to_nav_history(\n        &mut self,\n        cursor_anchor: Anchor,\n        new_position: Option<Point>,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(nav_history) = self.nav_history.as_mut() {\n            let buffer = self.buffer.read(cx).read(cx);\n            let cursor_position = cursor_anchor.to_point(&buffer);\n            let scroll_state = self.scroll_manager.anchor();\n            let scroll_top_row = scroll_state.top_row(&buffer);\n            drop(buffer);\n\n            if let Some(new_position) = new_position {\n                let row_delta = (new_position.row as i64 - cursor_position.row as i64).abs();\n                if row_delta < MIN_NAVIGATION_HISTORY_ROW_DELTA {\n                    return;\n                }\n            }\n\n            nav_history.push(\n                Some(NavigationData {\n                    cursor_anchor,\n                    cursor_position,\n                    scroll_anchor: scroll_state,\n                    scroll_top_row,\n                }),\n                cx,\n            );\n        }\n    }\n\n    pub fn select_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let mut selection = self.selections.first::<usize>(cx);\n        selection.set_head(buffer.len(), SelectionGoal::None);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(vec![selection]);\n        });\n    }\n\n    pub fn select_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n        let end = self.buffer.read(cx).read(cx).len();\n        self.change_selections(None, window, cx, |s| {\n            s.select_ranges(vec![0..end]);\n        });\n    }\n\n    pub fn select_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let mut selections = self.selections.all::<Point>(cx);\n        let max_point = display_map.buffer_snapshot.max_point();\n        for selection in &mut selections {\n            let rows = selection.spanned_rows(true, &display_map);\n            selection.start = Point::new(rows.start.0, 0);\n            selection.end = cmp::min(max_point, Point::new(rows.end.0, 0));\n            selection.reversed = false;\n        }\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(selections);\n        });\n    }\n\n    pub fn split_selection_into_lines(\n        &mut self,\n        _: &SplitSelectionIntoLines,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut to_unfold = Vec::new();\n        let mut new_selection_ranges = Vec::new();\n        {\n            let selections = self.selections.all::<Point>(cx);\n            let buffer = self.buffer.read(cx).read(cx);\n            for selection in selections {\n                for row in selection.start.row..selection.end.row {\n                    let cursor = Point::new(row, buffer.line_len(MultiBufferRow(row)));\n                    new_selection_ranges.push(cursor..cursor);\n                }\n                new_selection_ranges.push(selection.end..selection.end);\n                to_unfold.push(selection.start..selection.end);\n            }\n        }\n        self.unfold_ranges(&to_unfold, true, true, cx);\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select_ranges(new_selection_ranges);\n        });\n    }\n\n    pub fn add_selection_above(\n        &mut self,\n        _: &AddSelectionAbove,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(true, window, cx);\n    }\n\n    pub fn add_selection_below(\n        &mut self,\n        _: &AddSelectionBelow,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.add_selection(false, window, cx);\n    }\n\n    fn add_selection(&mut self, above: bool, window: &mut Window, cx: &mut Context<Self>) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let mut selections = self.selections.all::<Point>(cx);\n        let text_layout_details = self.text_layout_details(window);\n        let mut state = self.add_selections_state.take().unwrap_or_else(|| {\n            let oldest_selection = selections.iter().min_by_key(|s| s.id).unwrap().clone();\n            let range = oldest_selection.display_range(&display_map).sorted();\n\n            let start_x = display_map.x_for_display_point(range.start, &text_layout_details);\n            let end_x = display_map.x_for_display_point(range.end, &text_layout_details);\n            let positions = start_x.min(end_x)..start_x.max(end_x);\n\n            selections.clear();\n            let mut stack = Vec::new();\n            for row in range.start.row().0..=range.end.row().0 {\n                if let Some(selection) = self.selections.build_columnar_selection(\n                    &display_map,\n                    DisplayRow(row),\n                    &positions,\n                    oldest_selection.reversed,\n                    &text_layout_details,\n                ) {\n                    stack.push(selection.id);\n                    selections.push(selection);\n                }\n            }\n\n            if above {\n                stack.reverse();\n            }\n\n            AddSelectionsState { above, stack }\n        });\n\n        let last_added_selection = *state.stack.last().unwrap();\n        let mut new_selections = Vec::new();\n        if above == state.above {\n            let end_row = if above {\n                DisplayRow(0)\n            } else {\n                display_map.max_point().row()\n            };\n\n            'outer: for selection in selections {\n                if selection.id == last_added_selection {\n                    let range = selection.display_range(&display_map).sorted();\n                    debug_assert_eq!(range.start.row(), range.end.row());\n                    let mut row = range.start.row();\n                    let positions =\n                        if let SelectionGoal::HorizontalRange { start, end } = selection.goal {\n                            px(start)..px(end)\n                        } else {\n                            let start_x =\n                                display_map.x_for_display_point(range.start, &text_layout_details);\n                            let end_x =\n                                display_map.x_for_display_point(range.end, &text_layout_details);\n                            start_x.min(end_x)..start_x.max(end_x)\n                        };\n\n                    while row != end_row {\n                        if above {\n                            row.0 -= 1;\n                        } else {\n                            row.0 += 1;\n                        }\n\n                        if let Some(new_selection) = self.selections.build_columnar_selection(\n                            &display_map,\n                            row,\n                            &positions,\n                            selection.reversed,\n                            &text_layout_details,\n                        ) {\n                            state.stack.push(new_selection.id);\n                            if above {\n                                new_selections.push(new_selection);\n                                new_selections.push(selection);\n                            } else {\n                                new_selections.push(selection);\n                                new_selections.push(new_selection);\n                            }\n\n                            continue 'outer;\n                        }\n                    }\n                }\n\n                new_selections.push(selection);\n            }\n        } else {\n            new_selections = selections;\n            new_selections.retain(|s| s.id != last_added_selection);\n            state.stack.pop();\n        }\n\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.select(new_selections);\n        });\n        if state.stack.len() > 1 {\n            self.add_selections_state = Some(state);\n        }\n    }\n\n    pub fn select_next_match_internal(\n        &mut self,\n        display_map: &DisplaySnapshot,\n        replace_newest: bool,\n        autoscroll: Option<Autoscroll>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        fn select_next_match_ranges(\n            this: &mut Editor,\n            range: Range<usize>,\n            replace_newest: bool,\n            auto_scroll: Option<Autoscroll>,\n            window: &mut Window,\n            cx: &mut Context<Editor>,\n        ) {\n            this.unfold_ranges(&[range.clone()], false, true, cx);\n            this.change_selections(auto_scroll, window, cx, |s| {\n                if replace_newest {\n                    s.delete(s.newest_anchor().id);\n                }\n                s.insert_range(range.clone());\n            });\n        }\n\n        let buffer = &display_map.buffer_snapshot;\n        let mut selections = self.selections.all::<usize>(cx);\n        if let Some(mut select_next_state) = self.select_next_state.take() {\n            let query = &select_next_state.query;\n            if !select_next_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n\n                let bytes_after_last_selection =\n                    buffer.bytes_in_range(last_selection.end..buffer.len());\n                let bytes_before_first_selection = buffer.bytes_in_range(0..first_selection.start);\n                let query_matches = query\n                    .stream_find_iter(bytes_after_last_selection)\n                    .map(|result| (last_selection.end, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_before_first_selection)\n                            .map(|result| (0, result)),\n                    );\n\n                for (start_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        start_offset + query_match.start()..start_offset + query_match.end();\n                    let display_range = offset_range.start.to_display_point(display_map)\n                        ..offset_range.end.to_display_point(display_map);\n\n                    if !select_next_state.wordwise\n                        || (!movement::is_inside_word(display_map, display_range.start)\n                            && !movement::is_inside_word(display_map, display_range.end))\n                    {\n                        // TODO: This is n^2, because we might check all the selections\n                        if !selections\n                            .iter()\n                            .any(|selection| selection.range().overlaps(&offset_range))\n                        {\n                            next_selected_range = Some(offset_range);\n                            break;\n                        }\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    select_next_match_ranges(\n                        self,\n                        next_selected_range,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                } else {\n                    select_next_state.done = true;\n                }\n            }\n\n            self.select_next_state = Some(select_next_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let word_range = movement::surrounding_word(\n                        display_map,\n                        selection.start.to_display_point(display_map),\n                    );\n                    selection.start = word_range.start.to_offset(display_map, Bias::Left);\n                    selection.end = word_range.end.to_offset(display_map, Bias::Left);\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                    select_next_match_ranges(\n                        self,\n                        selection.start..selection.end,\n                        replace_newest,\n                        autoscroll,\n                        window,\n                        cx,\n                    );\n                }\n\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(\"ensured that there's only one selection\");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: AhoCorasick::new(&[query])?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_next_state = Some(select_state);\n                } else {\n                    self.select_next_state = None;\n                }\n            } else if let Some(selected_text) = selected_text {\n                self.select_next_state = Some(SelectNextState {\n                    query: AhoCorasick::new(&[selected_text])?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_next_match_internal(\n                    display_map,\n                    replace_newest,\n                    autoscroll,\n                    window,\n                    cx,\n                )?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn select_all_matches(\n        &mut self,\n        _action: &SelectAllMatches,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.push_to_selection_history();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        self.select_next_match_internal(&display_map, false, None, window, cx)?;\n        let Some(select_next_state) = self.select_next_state.as_mut() else {\n            return Ok(());\n        };\n        if select_next_state.done {\n            return Ok(());\n        }\n\n        let mut new_selections = self.selections.all::<usize>(cx);\n\n        let buffer = &display_map.buffer_snapshot;\n        let query_matches = select_next_state\n            .query\n            .stream_find_iter(buffer.bytes_in_range(0..buffer.len()));\n\n        for query_match in query_matches {\n            let query_match = query_match.unwrap(); // can only fail due to I/O\n            let offset_range = query_match.start()..query_match.end();\n            let display_range = offset_range.start.to_display_point(&display_map)\n                ..offset_range.end.to_display_point(&display_map);\n\n            if !select_next_state.wordwise\n                || (!movement::is_inside_word(&display_map, display_range.start)\n                    && !movement::is_inside_word(&display_map, display_range.end))\n            {\n                self.selections.change_with(cx, |selections| {\n                    new_selections.push(Selection {\n                        id: selections.new_selection_id(),\n                        start: offset_range.start,\n                        end: offset_range.end,\n                        reversed: false,\n                        goal: SelectionGoal::None,\n                    });\n                });\n            }\n        }\n\n        new_selections.sort_by_key(|selection| selection.start);\n        let mut ix = 0;\n        while ix + 1 < new_selections.len() {\n            let current_selection = &new_selections[ix];\n            let next_selection = &new_selections[ix + 1];\n            if current_selection.range().overlaps(&next_selection.range()) {\n                if current_selection.id < next_selection.id {\n                    new_selections.remove(ix + 1);\n                } else {\n                    new_selections.remove(ix);\n                }\n            } else {\n                ix += 1;\n            }\n        }\n\n        let reversed = self.selections.oldest::<usize>(cx).reversed;\n\n        for selection in new_selections.iter_mut() {\n            selection.reversed = reversed;\n        }\n\n        select_next_state.done = true;\n        self.unfold_ranges(\n            &new_selections\n                .iter()\n                .map(|selection| selection.range())\n                .collect::<Vec<_>>(),\n            false,\n            false,\n            cx,\n        );\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |selections| {\n            selections.select(new_selections)\n        });\n\n        Ok(())\n    }\n\n    pub fn select_next(\n        &mut self,\n        action: &SelectNext,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.push_to_selection_history();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        self.select_next_match_internal(\n            &display_map,\n            action.replace_newest,\n            Some(Autoscroll::newest()),\n            window,\n            cx,\n        )?;\n        Ok(())\n    }\n\n    pub fn select_previous(\n        &mut self,\n        action: &SelectPrevious,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.push_to_selection_history();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = &display_map.buffer_snapshot;\n        let mut selections = self.selections.all::<usize>(cx);\n        if let Some(mut select_prev_state) = self.select_prev_state.take() {\n            let query = &select_prev_state.query;\n            if !select_prev_state.done {\n                let first_selection = selections.iter().min_by_key(|s| s.id).unwrap();\n                let last_selection = selections.iter().max_by_key(|s| s.id).unwrap();\n                let mut next_selected_range = None;\n                // When we're iterating matches backwards, the oldest match will actually be the furthest one in the buffer.\n                let bytes_before_last_selection =\n                    buffer.reversed_bytes_in_range(0..last_selection.start);\n                let bytes_after_first_selection =\n                    buffer.reversed_bytes_in_range(first_selection.end..buffer.len());\n                let query_matches = query\n                    .stream_find_iter(bytes_before_last_selection)\n                    .map(|result| (last_selection.start, result))\n                    .chain(\n                        query\n                            .stream_find_iter(bytes_after_first_selection)\n                            .map(|result| (buffer.len(), result)),\n                    );\n                for (end_offset, query_match) in query_matches {\n                    let query_match = query_match.unwrap(); // can only fail due to I/O\n                    let offset_range =\n                        end_offset - query_match.end()..end_offset - query_match.start();\n                    let display_range = offset_range.start.to_display_point(&display_map)\n                        ..offset_range.end.to_display_point(&display_map);\n\n                    if !select_prev_state.wordwise\n                        || (!movement::is_inside_word(&display_map, display_range.start)\n                            && !movement::is_inside_word(&display_map, display_range.end))\n                    {\n                        next_selected_range = Some(offset_range);\n                        break;\n                    }\n                }\n\n                if let Some(next_selected_range) = next_selected_range {\n                    self.unfold_ranges(&[next_selected_range.clone()], false, true, cx);\n                    self.change_selections(Some(Autoscroll::newest()), window, cx, |s| {\n                        if action.replace_newest {\n                            s.delete(s.newest_anchor().id);\n                        }\n                        s.insert_range(next_selected_range);\n                    });\n                } else {\n                    select_prev_state.done = true;\n                }\n            }\n\n            self.select_prev_state = Some(select_prev_state);\n        } else {\n            let mut only_carets = true;\n            let mut same_text_selected = true;\n            let mut selected_text = None;\n\n            let mut selections_iter = selections.iter().peekable();\n            while let Some(selection) = selections_iter.next() {\n                if selection.start != selection.end {\n                    only_carets = false;\n                }\n\n                if same_text_selected {\n                    if selected_text.is_none() {\n                        selected_text =\n                            Some(buffer.text_for_range(selection.range()).collect::<String>());\n                    }\n\n                    if let Some(next_selection) = selections_iter.peek() {\n                        if next_selection.range().len() == selection.range().len() {\n                            let next_selected_text = buffer\n                                .text_for_range(next_selection.range())\n                                .collect::<String>();\n                            if Some(next_selected_text) != selected_text {\n                                same_text_selected = false;\n                                selected_text = None;\n                            }\n                        } else {\n                            same_text_selected = false;\n                            selected_text = None;\n                        }\n                    }\n                }\n            }\n\n            if only_carets {\n                for selection in &mut selections {\n                    let word_range = movement::surrounding_word(\n                        &display_map,\n                        selection.start.to_display_point(&display_map),\n                    );\n                    selection.start = word_range.start.to_offset(&display_map, Bias::Left);\n                    selection.end = word_range.end.to_offset(&display_map, Bias::Left);\n                    selection.goal = SelectionGoal::None;\n                    selection.reversed = false;\n                }\n                if selections.len() == 1 {\n                    let selection = selections\n                        .last()\n                        .expect(\"ensured that there's only one selection\");\n                    let query = buffer\n                        .text_for_range(selection.start..selection.end)\n                        .collect::<String>();\n                    let is_empty = query.is_empty();\n                    let select_state = SelectNextState {\n                        query: AhoCorasick::new(&[query.chars().rev().collect::<String>()])?,\n                        wordwise: true,\n                        done: is_empty,\n                    };\n                    self.select_prev_state = Some(select_state);\n                } else {\n                    self.select_prev_state = None;\n                }\n\n                self.unfold_ranges(\n                    &selections.iter().map(|s| s.range()).collect::<Vec<_>>(),\n                    false,\n                    true,\n                    cx,\n                );\n                self.change_selections(Some(Autoscroll::newest()), window, cx, |s| {\n                    s.select(selections);\n                });\n            } else if let Some(selected_text) = selected_text {\n                self.select_prev_state = Some(SelectNextState {\n                    query: AhoCorasick::new(&[selected_text.chars().rev().collect::<String>()])?,\n                    wordwise: false,\n                    done: false,\n                });\n                self.select_previous(action, window, cx)?;\n            }\n        }\n        Ok(())\n    }\n\n    pub fn toggle_comments(\n        &mut self,\n        action: &ToggleComments,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.read_only(cx) {\n            return;\n        }\n        let text_layout_details = &self.text_layout_details(window);\n        self.transact(window, cx, |this, window, cx| {\n            let mut selections = this.selections.all::<MultiBufferPoint>(cx);\n            let mut edits = Vec::new();\n            let mut selection_edit_ranges = Vec::new();\n            let mut last_toggled_row = None;\n            let snapshot = this.buffer.read(cx).read(cx);\n            let empty_str: Arc<str> = Arc::default();\n            let mut suffixes_inserted = Vec::new();\n            let ignore_indent = action.ignore_indent;\n\n            fn comment_prefix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_prefix: &str,\n                comment_prefix_whitespace: &str,\n                ignore_indent: bool,\n            ) -> Range<Point> {\n                let indent_size = if ignore_indent {\n                    0\n                } else {\n                    snapshot.indent_size_for_line(row).len\n                };\n\n                let start = Point::new(row.0, indent_size);\n\n                let mut line_bytes = snapshot\n                    .bytes_in_range(start..snapshot.max_point())\n                    .flatten()\n                    .copied();\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_bytes\n                    .by_ref()\n                    .take(comment_prefix.len())\n                    .eq(comment_prefix.bytes())\n                {\n                    // Include any whitespace that matches the comment prefix.\n                    let matching_whitespace_len = line_bytes\n                        .zip(comment_prefix_whitespace.bytes())\n                        .take_while(|(a, b)| a == b)\n                        .count() as u32;\n                    let end = Point::new(\n                        start.row,\n                        start.column + comment_prefix.len() as u32 + matching_whitespace_len,\n                    );\n                    start..end\n                } else {\n                    start..start\n                }\n            }\n\n            fn comment_suffix_range(\n                snapshot: &MultiBufferSnapshot,\n                row: MultiBufferRow,\n                comment_suffix: &str,\n                comment_suffix_has_leading_space: bool,\n            ) -> Range<Point> {\n                let end = Point::new(row.0, snapshot.line_len(row));\n                let suffix_start_column = end.column.saturating_sub(comment_suffix.len() as u32);\n\n                let mut line_end_bytes = snapshot\n                    .bytes_in_range(Point::new(end.row, suffix_start_column.saturating_sub(1))..end)\n                    .flatten()\n                    .copied();\n\n                let leading_space_len = if suffix_start_column > 0\n                    && line_end_bytes.next() == Some(b' ')\n                    && comment_suffix_has_leading_space\n                {\n                    1\n                } else {\n                    0\n                };\n\n                // If this line currently begins with the line comment prefix, then record\n                // the range containing the prefix.\n                if line_end_bytes.by_ref().eq(comment_suffix.bytes()) {\n                    let start = Point::new(end.row, suffix_start_column - leading_space_len);\n                    start..end\n                } else {\n                    end..end\n                }\n            }\n\n            // TODO: Handle selections that cross excerpts\n            for selection in &mut selections {\n                let start_column = snapshot\n                    .indent_size_for_line(MultiBufferRow(selection.start.row))\n                    .len;\n                let language = if let Some(language) =\n                    snapshot.language_scope_at(Point::new(selection.start.row, start_column))\n                {\n                    language\n                } else {\n                    continue;\n                };\n\n                selection_edit_ranges.clear();\n\n                // If multiple selections contain a given row, avoid processing that\n                // row more than once.\n                let mut start_row = MultiBufferRow(selection.start.row);\n                if last_toggled_row == Some(start_row) {\n                    start_row = start_row.next_row();\n                }\n                let end_row =\n                    if selection.end.row > selection.start.row && selection.end.column == 0 {\n                        MultiBufferRow(selection.end.row - 1)\n                    } else {\n                        MultiBufferRow(selection.end.row)\n                    };\n                last_toggled_row = Some(end_row);\n\n                if start_row > end_row {\n                    continue;\n                }\n\n                // If the language has line comments, toggle those.\n                let mut full_comment_prefixes = language.line_comment_prefixes().to_vec();\n\n                // If ignore_indent is set, trim spaces from the right side of all full_comment_prefixes\n                if ignore_indent {\n                    full_comment_prefixes = full_comment_prefixes\n                        .into_iter()\n                        .map(|s| Arc::from(s.trim_end()))\n                        .collect();\n                }\n\n                if !full_comment_prefixes.is_empty() {\n                    let first_prefix = full_comment_prefixes\n                        .first()\n                        .expect(\"prefixes is non-empty\");\n                    let prefix_trimmed_lengths = full_comment_prefixes\n                        .iter()\n                        .map(|p| p.trim_end_matches(' ').len())\n                        .collect::<SmallVec<[usize; 4]>>();\n\n                    let mut all_selection_lines_are_comments = true;\n\n                    for row in start_row.0..=end_row.0 {\n                        let row = MultiBufferRow(row);\n                        if start_row < end_row && snapshot.is_line_blank(row) {\n                            continue;\n                        }\n\n                        let prefix_range = full_comment_prefixes\n                            .iter()\n                            .zip(prefix_trimmed_lengths.iter().copied())\n                            .map(|(prefix, trimmed_prefix_len)| {\n                                comment_prefix_range(\n                                    snapshot.deref(),\n                                    row,\n                                    &prefix[..trimmed_prefix_len],\n                                    &prefix[trimmed_prefix_len..],\n                                    ignore_indent,\n                                )\n                            })\n                            .max_by_key(|range| range.end.column - range.start.column)\n                            .expect(\"prefixes is non-empty\");\n\n                        if prefix_range.is_empty() {\n                            all_selection_lines_are_comments = false;\n                        }\n\n                        selection_edit_ranges.push(prefix_range);\n                    }\n\n                    if all_selection_lines_are_comments {\n                        edits.extend(\n                            selection_edit_ranges\n                                .iter()\n                                .cloned()\n                                .map(|range| (range, empty_str.clone())),\n                        );\n                    } else {\n                        let min_column = selection_edit_ranges\n                            .iter()\n                            .map(|range| range.start.column)\n                            .min()\n                            .unwrap_or(0);\n                        edits.extend(selection_edit_ranges.iter().map(|range| {\n                            let position = Point::new(range.start.row, min_column);\n                            (position..position, first_prefix.clone())\n                        }));\n                    }\n                } else if let Some((full_comment_prefix, comment_suffix)) =\n                    language.block_comment_delimiters()\n                {\n                    let comment_prefix = full_comment_prefix.trim_end_matches(' ');\n                    let comment_prefix_whitespace = &full_comment_prefix[comment_prefix.len()..];\n                    let prefix_range = comment_prefix_range(\n                        snapshot.deref(),\n                        start_row,\n                        comment_prefix,\n                        comment_prefix_whitespace,\n                        ignore_indent,\n                    );\n                    let suffix_range = comment_suffix_range(\n                        snapshot.deref(),\n                        end_row,\n                        comment_suffix.trim_start_matches(' '),\n                        comment_suffix.starts_with(' '),\n                    );\n\n                    if prefix_range.is_empty() || suffix_range.is_empty() {\n                        edits.push((\n                            prefix_range.start..prefix_range.start,\n                            full_comment_prefix.clone(),\n                        ));\n                        edits.push((suffix_range.end..suffix_range.end, comment_suffix.clone()));\n                        suffixes_inserted.push((end_row, comment_suffix.len()));\n                    } else {\n                        edits.push((prefix_range, empty_str.clone()));\n                        edits.push((suffix_range, empty_str.clone()));\n                    }\n                } else {\n                    continue;\n                }\n            }\n\n            drop(snapshot);\n            this.buffer.update(cx, |buffer, cx| {\n                buffer.edit(edits, None, cx);\n            });\n\n            // Adjust selections so that they end before any comment suffixes that\n            // were inserted.\n            let mut suffixes_inserted = suffixes_inserted.into_iter().peekable();\n            let mut selections = this.selections.all::<Point>(cx);\n            let snapshot = this.buffer.read(cx).read(cx);\n            for selection in &mut selections {\n                while let Some((row, suffix_len)) = suffixes_inserted.peek().copied() {\n                    match row.cmp(&MultiBufferRow(selection.end.row)) {\n                        Ordering::Less => {\n                            suffixes_inserted.next();\n                            continue;\n                        }\n                        Ordering::Greater => break,\n                        Ordering::Equal => {\n                            if selection.end.column == snapshot.line_len(row) {\n                                if selection.is_empty() {\n                                    selection.start.column -= suffix_len as u32;\n                                }\n                                selection.end.column -= suffix_len as u32;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            drop(snapshot);\n            this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections)\n            });\n\n            let selections = this.selections.all::<Point>(cx);\n            let selections_on_single_row = selections.windows(2).all(|selections| {\n                selections[0].start.row == selections[1].start.row\n                    && selections[0].end.row == selections[1].end.row\n                    && selections[0].start.row == selections[0].end.row\n            });\n            let selections_selecting = selections\n                .iter()\n                .any(|selection| selection.start != selection.end);\n            let advance_downwards = action.advance_downwards\n                && selections_on_single_row\n                && !selections_selecting\n                && !matches!(this.mode, EditorMode::SingleLine { .. });\n\n            if advance_downwards {\n                let snapshot = this.buffer.read(cx).snapshot(cx);\n\n                this.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.move_cursors_with(|display_snapshot, display_point, _| {\n                        let mut point = display_point.to_point(display_snapshot);\n                        point.row += 1;\n                        point = snapshot.clip_point(point, Bias::Left);\n                        let display_point = point.to_display_point(display_snapshot);\n                        let goal = SelectionGoal::HorizontalPosition(\n                            display_snapshot\n                                .x_for_display_point(display_point, text_layout_details)\n                                .into(),\n                        );\n                        (display_point, goal)\n                    })\n                });\n            }\n        });\n    }\n\n    pub fn select_enclosing_symbol(\n        &mut self,\n        _: &SelectEnclosingSymbol,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let old_selections = self.selections.all::<usize>(cx).into_boxed_slice();\n\n        fn update_selection(\n            selection: &Selection<usize>,\n            buffer_snap: &MultiBufferSnapshot,\n        ) -> Option<Selection<usize>> {\n            let cursor = selection.head();\n            let (_buffer_id, symbols) = buffer_snap.symbols_containing(cursor, None)?;\n            for symbol in symbols.iter().rev() {\n                let start = symbol.range.start.to_offset(buffer_snap);\n                let end = symbol.range.end.to_offset(buffer_snap);\n                let new_range = start..end;\n                if start < selection.start || end > selection.end {\n                    return Some(Selection {\n                        id: selection.id,\n                        start: new_range.start,\n                        end: new_range.end,\n                        goal: SelectionGoal::None,\n                        reversed: selection.reversed,\n                    });\n                }\n            }\n            None\n        }\n\n        let mut selected_larger_symbol = false;\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| match update_selection(selection, &buffer) {\n                Some(new_selection) => {\n                    if new_selection.range() != selection.range() {\n                        selected_larger_symbol = true;\n                    }\n                    new_selection\n                }\n                None => selection.clone(),\n            })\n            .collect::<Vec<_>>();\n\n        if selected_larger_symbol {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n        }\n    }\n\n    pub fn select_larger_syntax_node(\n        &mut self,\n        _: &SelectLargerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let old_selections = self.selections.all::<usize>(cx).into_boxed_slice();\n\n        let mut stack = mem::take(&mut self.select_larger_syntax_node_stack);\n        let mut selected_larger_node = false;\n        let new_selections = old_selections\n            .iter()\n            .map(|selection| {\n                let old_range = selection.start..selection.end;\n                let mut new_range = old_range.clone();\n                let mut new_node = None;\n                while let Some((node, containing_range)) = buffer.syntax_ancestor(new_range.clone())\n                {\n                    new_node = Some(node);\n                    new_range = containing_range;\n                    if !display_map.intersects_fold(new_range.start)\n                        && !display_map.intersects_fold(new_range.end)\n                    {\n                        break;\n                    }\n                }\n\n                if let Some(node) = new_node {\n                    // Log the ancestor, to support using this action as a way to explore TreeSitter\n                    // nodes. Parent and grandparent are also logged because this operation will not\n                    // visit nodes that have the same range as their parent.\n                    log::info!(\"Node: {node:?}\");\n                    let parent = node.parent();\n                    log::info!(\"Parent: {parent:?}\");\n                    let grandparent = parent.and_then(|x| x.parent());\n                    log::info!(\"Grandparent: {grandparent:?}\");\n                }\n\n                selected_larger_node |= new_range != old_range;\n                Selection {\n                    id: selection.id,\n                    start: new_range.start,\n                    end: new_range.end,\n                    goal: SelectionGoal::None,\n                    reversed: selection.reversed,\n                }\n            })\n            .collect::<Vec<_>>();\n\n        if selected_larger_node {\n            stack.push(old_selections);\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(new_selections);\n            });\n        }\n        self.select_larger_syntax_node_stack = stack;\n    }\n\n    pub fn select_smaller_syntax_node(\n        &mut self,\n        _: &SelectSmallerSyntaxNode,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut stack = mem::take(&mut self.select_larger_syntax_node_stack);\n        if let Some(selections) = stack.pop() {\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select(selections.to_vec());\n            });\n        }\n        self.select_larger_syntax_node_stack = stack;\n    }\n\n    fn refresh_runnables(&mut self, window: &mut Window, cx: &mut Context<Self>) -> Task<()> {\n        if !EditorSettings::get_global(cx).gutter.runnables {\n            self.clear_tasks();\n            return Task::ready(());\n        }\n        let project = self.project.as_ref().map(Entity::downgrade);\n        cx.spawn_in(window, |this, mut cx| async move {\n            cx.background_executor().timer(UPDATE_DEBOUNCE).await;\n            let Some(project) = project.and_then(|p| p.upgrade()) else {\n                return;\n            };\n            let Ok(display_snapshot) = this.update(&mut cx, |this, cx| {\n                this.display_map.update(cx, |map, cx| map.snapshot(cx))\n            }) else {\n                return;\n            };\n\n            let hide_runnables = project\n                .update(&mut cx, |project, cx| {\n                    // Do not display any test indicators in non-dev server remote projects.\n                    project.is_via_collab() && project.ssh_connection_string(cx).is_none()\n                })\n                .unwrap_or(true);\n            if hide_runnables {\n                return;\n            }\n            let new_rows =\n                cx.background_executor()\n                    .spawn({\n                        let snapshot = display_snapshot.clone();\n                        async move {\n                            Self::fetch_runnable_ranges(&snapshot, Anchor::min()..Anchor::max())\n                        }\n                    })\n                    .await;\n\n            let rows = Self::runnable_rows(project, display_snapshot, new_rows, cx.clone());\n            this.update(&mut cx, |this, _| {\n                this.clear_tasks();\n                for (key, value) in rows {\n                    this.insert_tasks(key, value);\n                }\n            })\n            .ok();\n        })\n    }\n    fn fetch_runnable_ranges(\n        snapshot: &DisplaySnapshot,\n        range: Range<Anchor>,\n    ) -> Vec<language::RunnableRange> {\n        snapshot.buffer_snapshot.runnable_ranges(range).collect()\n    }\n\n    fn runnable_rows(\n        project: Entity<Project>,\n        snapshot: DisplaySnapshot,\n        runnable_ranges: Vec<RunnableRange>,\n        mut cx: AsyncWindowContext,\n    ) -> Vec<((BufferId, u32), RunnableTasks)> {\n        runnable_ranges\n            .into_iter()\n            .filter_map(|mut runnable| {\n                let tasks = cx\n                    .update(|_, cx| Self::templates_with_tags(&project, &mut runnable.runnable, cx))\n                    .ok()?;\n                if tasks.is_empty() {\n                    return None;\n                }\n\n                let point = runnable.run_range.start.to_point(&snapshot.buffer_snapshot);\n\n                let row = snapshot\n                    .buffer_snapshot\n                    .buffer_line_for_row(MultiBufferRow(point.row))?\n                    .1\n                    .start\n                    .row;\n\n                let context_range =\n                    BufferOffset(runnable.full_range.start)..BufferOffset(runnable.full_range.end);\n                Some((\n                    (runnable.buffer_id, row),\n                    RunnableTasks {\n                        templates: tasks,\n                        offset: MultiBufferOffset(runnable.run_range.start),\n                        context_range,\n                        column: point.column,\n                        extra_variables: runnable.extra_captures,\n                    },\n                ))\n            })\n            .collect()\n    }\n\n    fn templates_with_tags(\n        project: &Entity<Project>,\n        runnable: &mut Runnable,\n        cx: &mut App,\n    ) -> Vec<(TaskSourceKind, TaskTemplate)> {\n        let (inventory, worktree_id, file) = project.read_with(cx, |project, cx| {\n            let (worktree_id, file) = project\n                .buffer_for_id(runnable.buffer, cx)\n                .and_then(|buffer| buffer.read(cx).file())\n                .map(|file| (file.worktree_id(cx), file.clone()))\n                .unzip();\n\n            (\n                project.task_store().read(cx).task_inventory().cloned(),\n                worktree_id,\n                file,\n            )\n        });\n\n        let tags = mem::take(&mut runnable.tags);\n        let mut tags: Vec<_> = tags\n            .into_iter()\n            .flat_map(|tag| {\n                let tag = tag.0.clone();\n                inventory\n                    .as_ref()\n                    .into_iter()\n                    .flat_map(|inventory| {\n                        inventory.read(cx).list_tasks(\n                            file.clone(),\n                            Some(runnable.language.clone()),\n                            worktree_id,\n                            cx,\n                        )\n                    })\n                    .filter(move |(_, template)| {\n                        template.tags.iter().any(|source_tag| source_tag == &tag)\n                    })\n            })\n            .sorted_by_key(|(kind, _)| kind.to_owned())\n            .collect();\n        if let Some((leading_tag_source, _)) = tags.first() {\n            // Strongest source wins; if we have worktree tag binding, prefer that to\n            // global and language bindings;\n            // if we have a global binding, prefer that to language binding.\n            let first_mismatch = tags\n                .iter()\n                .position(|(tag_source, _)| tag_source != leading_tag_source);\n            if let Some(index) = first_mismatch {\n                tags.truncate(index);\n            }\n        }\n\n        tags\n    }\n\n    pub fn move_to_enclosing_bracket(\n        &mut self,\n        _: &MoveToEnclosingBracket,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n            s.move_offsets_with(|snapshot, selection| {\n                let Some(enclosing_bracket_ranges) =\n                    snapshot.enclosing_bracket_ranges(selection.start..selection.end)\n                else {\n                    return;\n                };\n\n                let mut best_length = usize::MAX;\n                let mut best_inside = false;\n                let mut best_in_bracket_range = false;\n                let mut best_destination = None;\n                for (open, close) in enclosing_bracket_ranges {\n                    let close = close.to_inclusive();\n                    let length = close.end() - open.start;\n                    let inside = selection.start >= open.end && selection.end <= *close.start();\n                    let in_bracket_range = open.to_inclusive().contains(&selection.head())\n                        || close.contains(&selection.head());\n\n                    // If best is next to a bracket and current isn't, skip\n                    if !in_bracket_range && best_in_bracket_range {\n                        continue;\n                    }\n\n                    // Prefer smaller lengths unless best is inside and current isn't\n                    if length > best_length && (best_inside || !inside) {\n                        continue;\n                    }\n\n                    best_length = length;\n                    best_inside = inside;\n                    best_in_bracket_range = in_bracket_range;\n                    best_destination = Some(\n                        if close.contains(&selection.start) && close.contains(&selection.end) {\n                            if inside {\n                                open.end\n                            } else {\n                                open.start\n                            }\n                        } else if inside {\n                            *close.start()\n                        } else {\n                            *close.end()\n                        },\n                    );\n                }\n\n                if let Some(destination) = best_destination {\n                    selection.collapse_to(destination, SelectionGoal::None);\n                }\n            })\n        });\n    }\n\n    pub fn undo_selection(\n        &mut self,\n        _: &UndoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.end_selection(window, cx);\n        self.selection_history.mode = SelectionHistoryMode::Undoing;\n        if let Some(entry) = self.selection_history.undo_stack.pop_back() {\n            self.change_selections(None, window, cx, |s| {\n                s.select_anchors(entry.selections.to_vec())\n            });\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n            self.request_autoscroll(Autoscroll::newest(), cx);\n        }\n        self.selection_history.mode = SelectionHistoryMode::Normal;\n    }\n\n    pub fn redo_selection(\n        &mut self,\n        _: &RedoSelection,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.end_selection(window, cx);\n        self.selection_history.mode = SelectionHistoryMode::Redoing;\n        if let Some(entry) = self.selection_history.redo_stack.pop_back() {\n            self.change_selections(None, window, cx, |s| {\n                s.select_anchors(entry.selections.to_vec())\n            });\n            self.select_next_state = entry.select_next_state;\n            self.select_prev_state = entry.select_prev_state;\n            self.add_selections_state = entry.add_selections_state;\n            self.request_autoscroll(Autoscroll::newest(), cx);\n        }\n        self.selection_history.mode = SelectionHistoryMode::Normal;\n    }\n\n    pub fn expand_excerpts(\n        &mut self,\n        action: &ExpandExcerpts,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::UpAndDown, cx)\n    }\n\n    pub fn expand_excerpts_down(\n        &mut self,\n        action: &ExpandExcerptsDown,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Down, cx)\n    }\n\n    pub fn expand_excerpts_up(\n        &mut self,\n        action: &ExpandExcerptsUp,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.expand_excerpts_for_direction(action.lines, ExpandExcerptDirection::Up, cx)\n    }\n\n    pub fn expand_excerpts_for_direction(\n        &mut self,\n        lines: u32,\n        direction: ExpandExcerptDirection,\n\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.disjoint_anchors();\n\n        let lines = if lines == 0 {\n            EditorSettings::get_global(cx).expand_excerpt_lines\n        } else {\n            lines\n        };\n\n        self.buffer.update(cx, |buffer, cx| {\n            let snapshot = buffer.snapshot(cx);\n            let mut excerpt_ids = selections\n                .iter()\n                .flat_map(|selection| snapshot.excerpt_ids_for_range(selection.range()))\n                .collect::<Vec<_>>();\n            excerpt_ids.sort();\n            excerpt_ids.dedup();\n            buffer.expand_excerpts(excerpt_ids, lines, direction, cx)\n        })\n    }\n\n    pub fn expand_excerpt(\n        &mut self,\n        excerpt: ExcerptId,\n        direction: ExpandExcerptDirection,\n        cx: &mut Context<Self>,\n    ) {\n        let lines = EditorSettings::get_global(cx).expand_excerpt_lines;\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_excerpts([excerpt], lines, direction, cx)\n        })\n    }\n\n    pub fn go_to_singleton_buffer_point(\n        &mut self,\n        point: Point,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_singleton_buffer_range(point..point, window, cx);\n    }\n\n    pub fn go_to_singleton_buffer_range(\n        &mut self,\n        range: Range<Point>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer().read(cx);\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n        let Some(start) = multibuffer.buffer_point_to_anchor(&buffer, range.start, cx) else {\n            return;\n        };\n        let Some(end) = multibuffer.buffer_point_to_anchor(&buffer, range.end, cx) else {\n            return;\n        };\n        self.change_selections(Some(Autoscroll::center()), window, cx, |s| {\n            s.select_anchor_ranges([start..end])\n        });\n    }\n\n    fn go_to_diagnostic(\n        &mut self,\n        _: &GoToDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_diagnostic_impl(Direction::Next, window, cx)\n    }\n\n    fn go_to_prev_diagnostic(\n        &mut self,\n        _: &GoToPrevDiagnostic,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.go_to_diagnostic_impl(Direction::Prev, window, cx)\n    }\n\n    pub fn go_to_diagnostic_impl(\n        &mut self,\n        direction: Direction,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let buffer = self.buffer.read(cx).snapshot(cx);\n        let selection = self.selections.newest::<usize>(cx);\n\n        // If there is an active Diagnostic Popover jump to its diagnostic instead.\n        if direction == Direction::Next {\n            if let Some(popover) = self.hover_state.diagnostic_popover.as_ref() {\n                let Some(buffer_id) = popover.local_diagnostic.range.start.buffer_id else {\n                    return;\n                };\n                self.activate_diagnostics(\n                    buffer_id,\n                    popover.local_diagnostic.diagnostic.group_id,\n                    window,\n                    cx,\n                );\n                if let Some(active_diagnostics) = self.active_diagnostics.as_ref() {\n                    let primary_range_start = active_diagnostics.primary_range.start;\n                    self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                        let mut new_selection = s.newest_anchor().clone();\n                        new_selection.collapse_to(primary_range_start, SelectionGoal::None);\n                        s.select_anchors(vec![new_selection.clone()]);\n                    });\n                    self.refresh_inline_completion(false, true, window, cx);\n                }\n                return;\n            }\n        }\n\n        let active_group_id = self\n            .active_diagnostics\n            .as_ref()\n            .map(|active_group| active_group.group_id);\n        let active_primary_range = self.active_diagnostics.as_ref().map(|active_diagnostics| {\n            active_diagnostics\n                .primary_range\n                .to_offset(&buffer)\n                .to_inclusive()\n        });\n        let search_start = if let Some(active_primary_range) = active_primary_range.as_ref() {\n            if active_primary_range.contains(&selection.head()) {\n                *active_primary_range.start()\n            } else {\n                selection.head()\n            }\n        } else {\n            selection.head()\n        };\n\n        let snapshot = self.snapshot(window, cx);\n        let primary_diagnostics_before = buffer\n            .diagnostics_in_range::<usize>(0..search_start)\n            .filter(|entry| entry.diagnostic.is_primary)\n            .filter(|entry| entry.range.start != entry.range.end)\n            .filter(|entry| entry.diagnostic.severity <= DiagnosticSeverity::WARNING)\n            .filter(|entry| !snapshot.intersects_fold(entry.range.start))\n            .collect::<Vec<_>>();\n        let last_same_group_diagnostic_before = active_group_id.and_then(|active_group_id| {\n            primary_diagnostics_before\n                .iter()\n                .position(|entry| entry.diagnostic.group_id == active_group_id)\n        });\n\n        let primary_diagnostics_after = buffer\n            .diagnostics_in_range::<usize>(search_start..buffer.len())\n            .filter(|entry| entry.diagnostic.is_primary)\n            .filter(|entry| entry.range.start != entry.range.end)\n            .filter(|entry| entry.diagnostic.severity <= DiagnosticSeverity::WARNING)\n            .filter(|diagnostic| !snapshot.intersects_fold(diagnostic.range.start))\n            .collect::<Vec<_>>();\n        let last_same_group_diagnostic_after = active_group_id.and_then(|active_group_id| {\n            primary_diagnostics_after\n                .iter()\n                .enumerate()\n                .rev()\n                .find_map(|(i, entry)| {\n                    if entry.diagnostic.group_id == active_group_id {\n                        Some(i)\n                    } else {\n                        None\n                    }\n                })\n        });\n\n        let next_primary_diagnostic = match direction {\n            Direction::Prev => primary_diagnostics_before\n                .iter()\n                .take(last_same_group_diagnostic_before.unwrap_or(usize::MAX))\n                .rev()\n                .next(),\n            Direction::Next => primary_diagnostics_after\n                .iter()\n                .skip(\n                    last_same_group_diagnostic_after\n                        .map(|index| index + 1)\n                        .unwrap_or(0),\n                )\n                .next(),\n        };\n\n        // Cycle around to the start of the buffer, potentially moving back to the start of\n        // the currently active diagnostic.\n        let cycle_around = || match direction {\n            Direction::Prev => primary_diagnostics_after\n                .iter()\n                .rev()\n                .chain(primary_diagnostics_before.iter().rev())\n                .next(),\n            Direction::Next => primary_diagnostics_before\n                .iter()\n                .chain(primary_diagnostics_after.iter())\n                .next(),\n        };\n\n        if let Some((primary_range, group_id)) = next_primary_diagnostic\n            .or_else(cycle_around)\n            .map(|entry| (&entry.range, entry.diagnostic.group_id))\n        {\n            let Some(buffer_id) = buffer.anchor_after(primary_range.start).buffer_id else {\n                return;\n            };\n            self.activate_diagnostics(buffer_id, group_id, window, cx);\n            if self.active_diagnostics.is_some() {\n                self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                    s.select(vec![Selection {\n                        id: selection.id,\n                        start: primary_range.start,\n                        end: primary_range.start,\n                        reversed: false,\n                        goal: SelectionGoal::None,\n                    }]);\n                });\n                self.refresh_inline_completion(false, true, window, cx);\n            }\n        }\n    }\n\n    fn go_to_next_hunk(&mut self, _: &GoToHunk, window: &mut Window, cx: &mut Context<Self>) {\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(cx);\n        self.go_to_hunk_after_position(&snapshot, selection.head(), window, cx);\n    }\n\n    fn go_to_hunk_after_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<MultiBufferDiffHunk> {\n        let mut hunk = snapshot\n            .buffer_snapshot\n            .diff_hunks_in_range(position..snapshot.buffer_snapshot.max_point())\n            .find(|hunk| hunk.row_range.start.0 > position.row);\n        if hunk.is_none() {\n            hunk = snapshot\n                .buffer_snapshot\n                .diff_hunks_in_range(Point::zero()..position)\n                .find(|hunk| hunk.row_range.end.0 < position.row)\n        }\n        if let Some(hunk) = &hunk {\n            let destination = Point::new(hunk.row_range.start.0, 0);\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select_ranges(vec![destination..destination]);\n            });\n        }\n\n        hunk\n    }\n\n    fn go_to_prev_hunk(&mut self, _: &GoToPrevHunk, window: &mut Window, cx: &mut Context<Self>) {\n        let snapshot = self.snapshot(window, cx);\n        let selection = self.selections.newest::<Point>(cx);\n        self.go_to_hunk_before_position(&snapshot, selection.head(), window, cx);\n    }\n\n    fn go_to_hunk_before_position(\n        &mut self,\n        snapshot: &EditorSnapshot,\n        position: Point,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Option<MultiBufferDiffHunk> {\n        let mut hunk = snapshot.buffer_snapshot.diff_hunk_before(position);\n        if hunk.is_none() {\n            hunk = snapshot.buffer_snapshot.diff_hunk_before(Point::MAX);\n        }\n        if let Some(hunk) = &hunk {\n            let destination = Point::new(hunk.row_range.start.0, 0);\n            self.unfold_ranges(&[destination..destination], false, false, cx);\n            self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                s.select_ranges(vec![destination..destination]);\n            });\n        }\n\n        hunk\n    }\n\n    pub fn go_to_definition(\n        &mut self,\n        _: &GoToDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let definition =\n            self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, false, window, cx);\n        cx.spawn_in(window, |editor, mut cx| async move {\n            if definition.await? == Navigated::Yes {\n                return Ok(Navigated::Yes);\n            }\n            match editor.update_in(&mut cx, |editor, window, cx| {\n                editor.find_all_references(&FindAllReferences, window, cx)\n            })? {\n                Some(references) => references.await,\n                None => Ok(Navigated::No),\n            }\n        })\n    }\n\n    pub fn go_to_declaration(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, false, window, cx)\n    }\n\n    pub fn go_to_declaration_split(\n        &mut self,\n        _: &GoToDeclaration,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Declaration, true, window, cx)\n    }\n\n    pub fn go_to_implementation(\n        &mut self,\n        _: &GoToImplementation,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, false, window, cx)\n    }\n\n    pub fn go_to_implementation_split(\n        &mut self,\n        _: &GoToImplementationSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Implementation, true, window, cx)\n    }\n\n    pub fn go_to_type_definition(\n        &mut self,\n        _: &GoToTypeDefinition,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, false, window, cx)\n    }\n\n    pub fn go_to_definition_split(\n        &mut self,\n        _: &GoToDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Symbol, true, window, cx)\n    }\n\n    pub fn go_to_type_definition_split(\n        &mut self,\n        _: &GoToTypeDefinitionSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        self.go_to_definition_of_kind(GotoDefinitionKind::Type, true, window, cx)\n    }\n\n    fn go_to_definition_of_kind(\n        &mut self,\n        kind: GotoDefinitionKind,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Navigated>> {\n        let Some(provider) = self.semantics_provider.clone() else {\n            return Task::ready(Ok(Navigated::No));\n        };\n        let head = self.selections.newest::<usize>(cx).head();\n        let buffer = self.buffer.read(cx);\n        let (buffer, head) = if let Some(text_anchor) = buffer.text_anchor_for_position(head, cx) {\n            text_anchor\n        } else {\n            return Task::ready(Ok(Navigated::No));\n        };\n\n        let Some(definitions) = provider.definitions(&buffer, head, kind, cx) else {\n            return Task::ready(Ok(Navigated::No));\n        };\n\n        cx.spawn_in(window, |editor, mut cx| async move {\n            let definitions = definitions.await?;\n            let navigated = editor\n                .update_in(&mut cx, |editor, window, cx| {\n                    editor.navigate_to_hover_links(\n                        Some(kind),\n                        definitions\n                            .into_iter()\n                            .filter(|location| {\n                                hover_links::exclude_link_to_position(&buffer, &head, location, cx)\n                            })\n                            .map(HoverLink::Text)\n                            .collect::<Vec<_>>(),\n                        split,\n                        window,\n                        cx,\n                    )\n                })?\n                .await?;\n            anyhow::Ok(navigated)\n        })\n    }\n\n    pub fn open_url(&mut self, _: &OpenUrl, window: &mut Window, cx: &mut Context<Self>) {\n        let selection = self.selections.newest_anchor();\n        let head = selection.head();\n        let tail = selection.tail();\n\n        let Some((buffer, start_position)) =\n            self.buffer.read(cx).text_anchor_for_position(head, cx)\n        else {\n            return;\n        };\n\n        let end_position = if head != tail {\n            let Some((_, pos)) = self.buffer.read(cx).text_anchor_for_position(tail, cx) else {\n                return;\n            };\n            Some(pos)\n        } else {\n            None\n        };\n\n        let url_finder = cx.spawn_in(window, |editor, mut cx| async move {\n            let url = if let Some(end_pos) = end_position {\n                find_url_from_range(&buffer, start_position..end_pos, cx.clone())\n            } else {\n                find_url(&buffer, start_position, cx.clone()).map(|(_, url)| url)\n            };\n\n            if let Some(url) = url {\n                editor.update(&mut cx, |_, cx| {\n                    cx.open_url(&url);\n                })\n            } else {\n                Ok(())\n            }\n        });\n\n        url_finder.detach();\n    }\n\n    pub fn open_selected_filename(\n        &mut self,\n        _: &OpenSelectedFilename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let position = self.selections.newest_anchor().head();\n\n        let Some((buffer, buffer_position)) =\n            self.buffer.read(cx).text_anchor_for_position(position, cx)\n        else {\n            return;\n        };\n\n        let project = self.project.clone();\n\n        cx.spawn_in(window, |_, mut cx| async move {\n            let result = find_file(&buffer, project, buffer_position, &mut cx).await;\n\n            if let Some((_, path)) = result {\n                workspace\n                    .update_in(&mut cx, |workspace, window, cx| {\n                        workspace.open_resolved_path(path, window, cx)\n                    })?\n                    .await?;\n            }\n            anyhow::Ok(())\n        })\n        .detach();\n    }\n\n    pub(crate) fn navigate_to_hover_links(\n        &mut self,\n        kind: Option<GotoDefinitionKind>,\n        mut definitions: Vec<HoverLink>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Navigated>> {\n        // If there is one definition, just open it directly\n        if definitions.len() == 1 {\n            let definition = definitions.pop().unwrap();\n\n            enum TargetTaskResult {\n                Location(Option<Location>),\n                AlreadyNavigated,\n            }\n\n            let target_task = match definition {\n                HoverLink::Text(link) => {\n                    Task::ready(anyhow::Ok(TargetTaskResult::Location(Some(link.target))))\n                }\n                HoverLink::InlayHint(lsp_location, server_id) => {\n                    let computation =\n                        self.compute_target_location(lsp_location, server_id, window, cx);\n                    cx.background_executor().spawn(async move {\n                        let location = computation.await?;\n                        Ok(TargetTaskResult::Location(location))\n                    })\n                }\n                HoverLink::Url(url) => {\n                    cx.open_url(&url);\n                    Task::ready(Ok(TargetTaskResult::AlreadyNavigated))\n                }\n                HoverLink::File(path) => {\n                    if let Some(workspace) = self.workspace() {\n                        cx.spawn_in(window, |_, mut cx| async move {\n                            workspace\n                                .update_in(&mut cx, |workspace, window, cx| {\n                                    workspace.open_resolved_path(path, window, cx)\n                                })?\n                                .await\n                                .map(|_| TargetTaskResult::AlreadyNavigated)\n                        })\n                    } else {\n                        Task::ready(Ok(TargetTaskResult::Location(None)))\n                    }\n                }\n            };\n            cx.spawn_in(window, |editor, mut cx| async move {\n                let target = match target_task.await.context(\"target resolution task\")? {\n                    TargetTaskResult::AlreadyNavigated => return Ok(Navigated::Yes),\n                    TargetTaskResult::Location(None) => return Ok(Navigated::No),\n                    TargetTaskResult::Location(Some(target)) => target,\n                };\n\n                editor.update_in(&mut cx, |editor, window, cx| {\n                    let Some(workspace) = editor.workspace() else {\n                        return Navigated::No;\n                    };\n                    let pane = workspace.read(cx).active_pane().clone();\n\n                    let range = target.range.to_point(target.buffer.read(cx));\n                    let range = editor.range_for_match(&range);\n                    let range = collapse_multiline_range(range);\n\n                    if Some(&target.buffer) == editor.buffer.read(cx).as_singleton().as_ref() {\n                        editor.go_to_singleton_buffer_range(range.clone(), window, cx);\n                    } else {\n                        window.defer(cx, move |window, cx| {\n                            let target_editor: Entity<Self> =\n                                workspace.update(cx, |workspace, cx| {\n                                    let pane = if split {\n                                        workspace.adjacent_pane(window, cx)\n                                    } else {\n                                        workspace.active_pane().clone()\n                                    };\n\n                                    workspace.open_project_item(\n                                        pane,\n                                        target.buffer.clone(),\n                                        true,\n                                        true,\n                                        window,\n                                        cx,\n                                    )\n                                });\n                            target_editor.update(cx, |target_editor, cx| {\n                                // When selecting a definition in a different buffer, disable the nav history\n                                // to avoid creating a history entry at the previous cursor location.\n                                pane.update(cx, |pane, _| pane.disable_history());\n                                target_editor.go_to_singleton_buffer_range(range, window, cx);\n                                pane.update(cx, |pane, _| pane.enable_history());\n                            });\n                        });\n                    }\n                    Navigated::Yes\n                })\n            })\n        } else if !definitions.is_empty() {\n            cx.spawn_in(window, |editor, mut cx| async move {\n                let (title, location_tasks, workspace) = editor\n                    .update_in(&mut cx, |editor, window, cx| {\n                        let tab_kind = match kind {\n                            Some(GotoDefinitionKind::Implementation) => \"Implementations\",\n                            _ => \"Definitions\",\n                        };\n                        let title = definitions\n                            .iter()\n                            .find_map(|definition| match definition {\n                                HoverLink::Text(link) => link.origin.as_ref().map(|origin| {\n                                    let buffer = origin.buffer.read(cx);\n                                    format!(\n                                        \"{} for {}\",\n                                        tab_kind,\n                                        buffer\n                                            .text_for_range(origin.range.clone())\n                                            .collect::<String>()\n                                    )\n                                }),\n                                HoverLink::InlayHint(_, _) => None,\n                                HoverLink::Url(_) => None,\n                                HoverLink::File(_) => None,\n                            })\n                            .unwrap_or(tab_kind.to_string());\n                        let location_tasks = definitions\n                            .into_iter()\n                            .map(|definition| match definition {\n                                HoverLink::Text(link) => Task::ready(Ok(Some(link.target))),\n                                HoverLink::InlayHint(lsp_location, server_id) => editor\n                                    .compute_target_location(lsp_location, server_id, window, cx),\n                                HoverLink::Url(_) => Task::ready(Ok(None)),\n                                HoverLink::File(_) => Task::ready(Ok(None)),\n                            })\n                            .collect::<Vec<_>>();\n                        (title, location_tasks, editor.workspace().clone())\n                    })\n                    .context(\"location tasks preparation\")?;\n\n                let locations = future::join_all(location_tasks)\n                    .await\n                    .into_iter()\n                    .filter_map(|location| location.transpose())\n                    .collect::<Result<_>>()\n                    .context(\"location tasks\")?;\n\n                let Some(workspace) = workspace else {\n                    return Ok(Navigated::No);\n                };\n                let opened = workspace\n                    .update_in(&mut cx, |workspace, window, cx| {\n                        Self::open_locations_in_multibuffer(\n                            workspace,\n                            locations,\n                            title,\n                            split,\n                            MultibufferSelectionMode::First,\n                            window,\n                            cx,\n                        )\n                    })\n                    .ok();\n\n                anyhow::Ok(Navigated::from_bool(opened.is_some()))\n            })\n        } else {\n            Task::ready(Ok(Navigated::No))\n        }\n    }\n\n    fn compute_target_location(\n        &self,\n        lsp_location: lsp::Location,\n        server_id: LanguageServerId,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Option<Location>>> {\n        let Some(project) = self.project.clone() else {\n            return Task::ready(Ok(None));\n        };\n\n        cx.spawn_in(window, move |editor, mut cx| async move {\n            let location_task = editor.update(&mut cx, |_, cx| {\n                project.update(cx, |project, cx| {\n                    let language_server_name = project\n                        .language_server_statuses(cx)\n                        .find(|(id, _)| server_id == *id)\n                        .map(|(_, status)| LanguageServerName::from(status.name.as_str()));\n                    language_server_name.map(|language_server_name| {\n                        project.open_local_buffer_via_lsp(\n                            lsp_location.uri.clone(),\n                            server_id,\n                            language_server_name,\n                            cx,\n                        )\n                    })\n                })\n            })?;\n            let location = match location_task {\n                Some(task) => Some({\n                    let target_buffer_handle = task.await.context(\"open local buffer\")?;\n                    let range = target_buffer_handle.update(&mut cx, |target_buffer, _| {\n                        let target_start = target_buffer\n                            .clip_point_utf16(point_from_lsp(lsp_location.range.start), Bias::Left);\n                        let target_end = target_buffer\n                            .clip_point_utf16(point_from_lsp(lsp_location.range.end), Bias::Left);\n                        target_buffer.anchor_after(target_start)\n                            ..target_buffer.anchor_before(target_end)\n                    })?;\n                    Location {\n                        buffer: target_buffer_handle,\n                        range,\n                    }\n                }),\n                None => None,\n            };\n            Ok(location)\n        })\n    }\n\n    pub fn find_all_references(\n        &mut self,\n        _: &FindAllReferences,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<Navigated>>> {\n        let selection = self.selections.newest::<usize>(cx);\n        let multi_buffer = self.buffer.read(cx);\n        let head = selection.head();\n\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let head_anchor = multi_buffer_snapshot.anchor_at(\n            head,\n            if head < selection.tail() {\n                Bias::Right\n            } else {\n                Bias::Left\n            },\n        );\n\n        match self\n            .find_all_references_task_sources\n            .binary_search_by(|anchor| anchor.cmp(&head_anchor, &multi_buffer_snapshot))\n        {\n            Ok(_) => {\n                log::info!(\n                    \"Ignoring repeated FindAllReferences invocation with the position of already running task\"\n                );\n                return None;\n            }\n            Err(i) => {\n                self.find_all_references_task_sources.insert(i, head_anchor);\n            }\n        }\n\n        let (buffer, head) = multi_buffer.text_anchor_for_position(head, cx)?;\n        let workspace = self.workspace()?;\n        let project = workspace.read(cx).project().clone();\n        let references = project.update(cx, |project, cx| project.references(&buffer, head, cx));\n        Some(cx.spawn_in(window, |editor, mut cx| async move {\n            let _cleanup = defer({\n                let mut cx = cx.clone();\n                move || {\n                    let _ = editor.update(&mut cx, |editor, _| {\n                        if let Ok(i) =\n                            editor\n                                .find_all_references_task_sources\n                                .binary_search_by(|anchor| {\n                                    anchor.cmp(&head_anchor, &multi_buffer_snapshot)\n                                })\n                        {\n                            editor.find_all_references_task_sources.remove(i);\n                        }\n                    });\n                }\n            });\n\n            let locations = references.await?;\n            if locations.is_empty() {\n                return anyhow::Ok(Navigated::No);\n            }\n\n            workspace.update_in(&mut cx, |workspace, window, cx| {\n                let title = locations\n                    .first()\n                    .as_ref()\n                    .map(|location| {\n                        let buffer = location.buffer.read(cx);\n                        format!(\n                            \"References to `{}`\",\n                            buffer\n                                .text_for_range(location.range.clone())\n                                .collect::<String>()\n                        )\n                    })\n                    .unwrap();\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    title,\n                    false,\n                    MultibufferSelectionMode::First,\n                    window,\n                    cx,\n                );\n                Navigated::Yes\n            })\n        }))\n    }\n\n    /// Opens a multibuffer with the given project locations in it\n    pub fn open_locations_in_multibuffer(\n        workspace: &mut Workspace,\n        mut locations: Vec<Location>,\n        title: String,\n        split: bool,\n        multibuffer_selection_mode: MultibufferSelectionMode,\n        window: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        // If there are multiple definitions, open them in a multibuffer\n        locations.sort_by_key(|location| location.buffer.read(cx).remote_id());\n        let mut locations = locations.into_iter().peekable();\n        let mut ranges = Vec::new();\n        let capability = workspace.project().read(cx).capability();\n\n        let excerpt_buffer = cx.new(|cx| {\n            let mut multibuffer = MultiBuffer::new(capability);\n            while let Some(location) = locations.next() {\n                let buffer = location.buffer.read(cx);\n                let mut ranges_for_buffer = Vec::new();\n                let range = location.range.to_offset(buffer);\n                ranges_for_buffer.push(range.clone());\n\n                while let Some(next_location) = locations.peek() {\n                    if next_location.buffer == location.buffer {\n                        ranges_for_buffer.push(next_location.range.to_offset(buffer));\n                        locations.next();\n                    } else {\n                        break;\n                    }\n                }\n\n                ranges_for_buffer.sort_by_key(|range| (range.start, Reverse(range.end)));\n                ranges.extend(multibuffer.push_excerpts_with_context_lines(\n                    location.buffer.clone(),\n                    ranges_for_buffer,\n                    DEFAULT_MULTIBUFFER_CONTEXT,\n                    cx,\n                ))\n            }\n\n            multibuffer.with_title(title)\n        });\n\n        let editor = cx.new(|cx| {\n            Editor::for_multibuffer(\n                excerpt_buffer,\n                Some(workspace.project().clone()),\n                true,\n                window,\n                cx,\n            )\n        });\n        editor.update(cx, |editor, cx| {\n            match multibuffer_selection_mode {\n                MultibufferSelectionMode::First => {\n                    if let Some(first_range) = ranges.first() {\n                        editor.change_selections(None, window, cx, |selections| {\n                            selections.clear_disjoint();\n                            selections.select_anchor_ranges(std::iter::once(first_range.clone()));\n                        });\n                    }\n                    editor.highlight_background::<Self>(\n                        &ranges,\n                        |theme| theme.editor_highlighted_line_background,\n                        cx,\n                    );\n                }\n                MultibufferSelectionMode::All => {\n                    editor.change_selections(None, window, cx, |selections| {\n                        selections.clear_disjoint();\n                        selections.select_anchor_ranges(ranges);\n                    });\n                }\n            }\n            editor.register_buffers_with_language_servers(cx);\n        });\n\n        let item = Box::new(editor);\n        let item_id = item.item_id();\n\n        if split {\n            workspace.split_item(SplitDirection::Right, item.clone(), window, cx);\n        } else {\n            let destination_index = workspace.active_pane().update(cx, |pane, cx| {\n                if PreviewTabsSettings::get_global(cx).enable_preview_from_code_navigation {\n                    pane.close_current_preview_item(window, cx)\n                } else {\n                    None\n                }\n            });\n            workspace.add_item_to_active_pane(item.clone(), destination_index, true, window, cx);\n        }\n        workspace.active_pane().update(cx, |pane, cx| {\n            pane.set_preview_item_id(Some(item_id), cx);\n        });\n    }\n\n    pub fn rename(\n        &mut self,\n        _: &Rename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        use language::ToOffset as _;\n\n        let provider = self.semantics_provider.clone()?;\n        let selection = self.selections.newest_anchor().clone();\n        let (cursor_buffer, cursor_buffer_position) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.head(), cx)?;\n        let (tail_buffer, cursor_buffer_position_end) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(selection.tail(), cx)?;\n        if tail_buffer != cursor_buffer {\n            return None;\n        }\n\n        let snapshot = cursor_buffer.read(cx).snapshot();\n        let cursor_buffer_offset = cursor_buffer_position.to_offset(&snapshot);\n        let cursor_buffer_offset_end = cursor_buffer_position_end.to_offset(&snapshot);\n        let prepare_rename = provider\n            .range_for_rename(&cursor_buffer, cursor_buffer_position, cx)\n            .unwrap_or_else(|| Task::ready(Ok(None)));\n        drop(snapshot);\n\n        Some(cx.spawn_in(window, |this, mut cx| async move {\n            let rename_range = if let Some(range) = prepare_rename.await? {\n                Some(range)\n            } else {\n                this.update(&mut cx, |this, cx| {\n                    let buffer = this.buffer.read(cx).snapshot(cx);\n                    let mut buffer_highlights = this\n                        .document_highlights_for_position(selection.head(), &buffer)\n                        .filter(|highlight| {\n                            highlight.start.excerpt_id == selection.head().excerpt_id\n                                && highlight.end.excerpt_id == selection.head().excerpt_id\n                        });\n                    buffer_highlights\n                        .next()\n                        .map(|highlight| highlight.start.text_anchor..highlight.end.text_anchor)\n                })?\n            };\n            if let Some(rename_range) = rename_range {\n                this.update_in(&mut cx, |this, window, cx| {\n                    let snapshot = cursor_buffer.read(cx).snapshot();\n                    let rename_buffer_range = rename_range.to_offset(&snapshot);\n                    let cursor_offset_in_rename_range =\n                        cursor_buffer_offset.saturating_sub(rename_buffer_range.start);\n                    let cursor_offset_in_rename_range_end =\n                        cursor_buffer_offset_end.saturating_sub(rename_buffer_range.start);\n\n                    this.take_rename(false, window, cx);\n                    let buffer = this.buffer.read(cx).read(cx);\n                    let cursor_offset = selection.head().to_offset(&buffer);\n                    let rename_start = cursor_offset.saturating_sub(cursor_offset_in_rename_range);\n                    let rename_end = rename_start + rename_buffer_range.len();\n                    let range = buffer.anchor_before(rename_start)..buffer.anchor_after(rename_end);\n                    let mut old_highlight_id = None;\n                    let old_name: Arc<str> = buffer\n                        .chunks(rename_start..rename_end, true)\n                        .map(|chunk| {\n                            if old_highlight_id.is_none() {\n                                old_highlight_id = chunk.syntax_highlight_id;\n                            }\n                            chunk.text\n                        })\n                        .collect::<String>()\n                        .into();\n\n                    drop(buffer);\n\n                    // Position the selection in the rename editor so that it matches the current selection.\n                    this.show_local_selections = false;\n                    let rename_editor = cx.new(|cx| {\n                        let mut editor = Editor::single_line(window, cx);\n                        editor.buffer.update(cx, |buffer, cx| {\n                            buffer.edit([(0..0, old_name.clone())], None, cx)\n                        });\n                        let rename_selection_range = match cursor_offset_in_rename_range\n                            .cmp(&cursor_offset_in_rename_range_end)\n                        {\n                            Ordering::Equal => {\n                                editor.select_all(&SelectAll, window, cx);\n                                return editor;\n                            }\n                            Ordering::Less => {\n                                cursor_offset_in_rename_range..cursor_offset_in_rename_range_end\n                            }\n                            Ordering::Greater => {\n                                cursor_offset_in_rename_range_end..cursor_offset_in_rename_range\n                            }\n                        };\n                        if rename_selection_range.end > old_name.len() {\n                            editor.select_all(&SelectAll, window, cx);\n                        } else {\n                            editor.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n                                s.select_ranges([rename_selection_range]);\n                            });\n                        }\n                        editor\n                    });\n                    cx.subscribe(&rename_editor, |_, _, e: &EditorEvent, cx| {\n                        if e == &EditorEvent::Focused {\n                            cx.emit(EditorEvent::FocusedIn)\n                        }\n                    })\n                    .detach();\n\n                    let write_highlights =\n                        this.clear_background_highlights::<DocumentHighlightWrite>(cx);\n                    let read_highlights =\n                        this.clear_background_highlights::<DocumentHighlightRead>(cx);\n                    let ranges = write_highlights\n                        .iter()\n                        .flat_map(|(_, ranges)| ranges.iter())\n                        .chain(read_highlights.iter().flat_map(|(_, ranges)| ranges.iter()))\n                        .cloned()\n                        .collect();\n\n                    this.highlight_text::<Rename>(\n                        ranges,\n                        HighlightStyle {\n                            fade_out: Some(0.6),\n                            ..Default::default()\n                        },\n                        cx,\n                    );\n                    let rename_focus_handle = rename_editor.focus_handle(cx);\n                    window.focus(&rename_focus_handle);\n                    let block_id = this.insert_blocks(\n                        [BlockProperties {\n                            style: BlockStyle::Flex,\n                            placement: BlockPlacement::Below(range.start),\n                            height: 1,\n                            render: Arc::new({\n                                let rename_editor = rename_editor.clone();\n                                move |cx: &mut BlockContext| {\n                                    let mut text_style = cx.editor_style.text.clone();\n                                    if let Some(highlight_style) = old_highlight_id\n                                        .and_then(|h| h.style(&cx.editor_style.syntax))\n                                    {\n                                        text_style = text_style.highlight(highlight_style);\n                                    }\n                                    div()\n                                        .block_mouse_down()\n                                        .pl(cx.anchor_x)\n                                        .child(EditorElement::new(\n                                            &rename_editor,\n                                            EditorStyle {\n                                                background: cx.theme().system().transparent,\n                                                local_player: cx.editor_style.local_player,\n                                                text: text_style,\n                                                scrollbar_width: cx.editor_style.scrollbar_width,\n                                                syntax: cx.editor_style.syntax.clone(),\n                                                status: cx.editor_style.status.clone(),\n                                                inlay_hints_style: HighlightStyle {\n                                                    font_weight: Some(FontWeight::BOLD),\n                                                    ..make_inlay_hints_style(cx.app)\n                                                },\n                                                inline_completion_styles: make_suggestion_styles(\n                                                    cx.app,\n                                                ),\n                                                ..EditorStyle::default()\n                                            },\n                                        ))\n                                        .into_any_element()\n                                }\n                            }),\n                            priority: 0,\n                        }],\n                        Some(Autoscroll::fit()),\n                        cx,\n                    )[0];\n                    this.pending_rename = Some(RenameState {\n                        range,\n                        old_name,\n                        editor: rename_editor,\n                        block_id,\n                    });\n                })?;\n            }\n\n            Ok(())\n        }))\n    }\n\n    pub fn confirm_rename(\n        &mut self,\n        _: &ConfirmRename,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let rename = self.take_rename(false, window, cx)?;\n        let workspace = self.workspace()?.downgrade();\n        let (buffer, start) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.start, cx)?;\n        let (end_buffer, _) = self\n            .buffer\n            .read(cx)\n            .text_anchor_for_position(rename.range.end, cx)?;\n        if buffer != end_buffer {\n            return None;\n        }\n\n        let old_name = rename.old_name;\n        let new_name = rename.editor.read(cx).text(cx);\n\n        let rename = self.semantics_provider.as_ref()?.perform_rename(\n            &buffer,\n            start,\n            new_name.clone(),\n            cx,\n        )?;\n\n        Some(cx.spawn_in(window, |editor, mut cx| async move {\n            let project_transaction = rename.await?;\n            Self::open_project_transaction(\n                &editor,\n                workspace,\n                project_transaction,\n                format!(\"Rename: {} → {}\", old_name, new_name),\n                cx.clone(),\n            )\n            .await?;\n\n            editor.update(&mut cx, |editor, cx| {\n                editor.refresh_document_highlights(cx);\n            })?;\n            Ok(())\n        }))\n    }\n\n    fn take_rename(\n        &mut self,\n        moving_cursor: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<RenameState> {\n        let rename = self.pending_rename.take()?;\n        if rename.editor.focus_handle(cx).is_focused(window) {\n            window.focus(&self.focus_handle);\n        }\n\n        self.remove_blocks(\n            [rename.block_id].into_iter().collect(),\n            Some(Autoscroll::fit()),\n            cx,\n        );\n        self.clear_highlights::<Rename>(cx);\n        self.show_local_selections = true;\n\n        if moving_cursor {\n            let cursor_in_rename_editor = rename.editor.update(cx, |editor, cx| {\n                editor.selections.newest::<usize>(cx).head()\n            });\n\n            // Update the selection to match the position of the selection inside\n            // the rename editor.\n            let snapshot = self.buffer.read(cx).read(cx);\n            let rename_range = rename.range.to_offset(&snapshot);\n            let cursor_in_editor = snapshot\n                .clip_offset(rename_range.start + cursor_in_rename_editor, Bias::Left)\n                .min(rename_range.end);\n            drop(snapshot);\n\n            self.change_selections(None, window, cx, |s| {\n                s.select_ranges(vec![cursor_in_editor..cursor_in_editor])\n            });\n        } else {\n            self.refresh_document_highlights(cx);\n        }\n\n        Some(rename)\n    }\n\n    pub fn pending_rename(&self) -> Option<&RenameState> {\n        self.pending_rename.as_ref()\n    }\n\n    fn format(\n        &mut self,\n        _: &Format,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Buffers,\n            window,\n            cx,\n        ))\n    }\n\n    fn format_selections(\n        &mut self,\n        _: &FormatSelections,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let project = match &self.project {\n            Some(project) => project.clone(),\n            None => return None,\n        };\n\n        let ranges = self\n            .selections\n            .all_adjusted(cx)\n            .into_iter()\n            .map(|selection| selection.range())\n            .collect_vec();\n\n        Some(self.perform_format(\n            project,\n            FormatTrigger::Manual,\n            FormatTarget::Ranges(ranges),\n            window,\n            cx,\n        ))\n    }\n\n    fn perform_format(\n        &mut self,\n        project: Entity<Project>,\n        trigger: FormatTrigger,\n        target: FormatTarget,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        let buffer = self.buffer.clone();\n        let (buffers, target) = match target {\n            FormatTarget::Buffers => {\n                let mut buffers = buffer.read(cx).all_buffers();\n                if trigger == FormatTrigger::Save {\n                    buffers.retain(|buffer| buffer.read(cx).is_dirty());\n                }\n                (buffers, LspFormatTarget::Buffers)\n            }\n            FormatTarget::Ranges(selection_ranges) => {\n                let multi_buffer = buffer.read(cx);\n                let snapshot = multi_buffer.read(cx);\n                let mut buffers = HashSet::default();\n                let mut buffer_id_to_ranges: BTreeMap<BufferId, Vec<Range<text::Anchor>>> =\n                    BTreeMap::new();\n                for selection_range in selection_ranges {\n                    for (buffer, buffer_range, _) in\n                        snapshot.range_to_buffer_ranges(selection_range)\n                    {\n                        let buffer_id = buffer.remote_id();\n                        let start = buffer.anchor_before(buffer_range.start);\n                        let end = buffer.anchor_after(buffer_range.end);\n                        buffers.insert(multi_buffer.buffer(buffer_id).unwrap());\n                        buffer_id_to_ranges\n                            .entry(buffer_id)\n                            .and_modify(|buffer_ranges| buffer_ranges.push(start..end))\n                            .or_insert_with(|| vec![start..end]);\n                    }\n                }\n                (buffers, LspFormatTarget::Ranges(buffer_id_to_ranges))\n            }\n        };\n\n        let mut timeout = cx.background_executor().timer(FORMAT_TIMEOUT).fuse();\n        let format = project.update(cx, |project, cx| {\n            project.format(buffers, target, true, trigger, cx)\n        });\n\n        cx.spawn_in(window, |_, mut cx| async move {\n            let transaction = futures::select_biased! {\n                () = timeout => {\n                    log::warn!(\"timed out waiting for formatting\");\n                    None\n                }\n                transaction = format.log_err().fuse() => transaction,\n            };\n\n            buffer\n                .update(&mut cx, |buffer, cx| {\n                    if let Some(transaction) = transaction {\n                        if !buffer.is_singleton() {\n                            buffer.push_transaction(&transaction.0, cx);\n                        }\n                    }\n\n                    cx.notify();\n                })\n                .ok();\n\n            Ok(())\n        })\n    }\n\n    fn restart_language_server(\n        &mut self,\n        _: &RestartLanguageServer,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.clone() {\n            self.buffer.update(cx, |multi_buffer, cx| {\n                project.update(cx, |project, cx| {\n                    project.restart_language_servers_for_buffers(multi_buffer.all_buffers(), cx);\n                });\n            })\n        }\n    }\n\n    fn cancel_language_server_work(\n        workspace: &mut Workspace,\n        _: &actions::CancelLanguageServerWork,\n        _: &mut Window,\n        cx: &mut Context<Workspace>,\n    ) {\n        let project = workspace.project();\n        let buffers = workspace\n            .active_item(cx)\n            .and_then(|item| item.act_as::<Editor>(cx))\n            .map_or(HashSet::default(), |editor| {\n                editor.read(cx).buffer.read(cx).all_buffers()\n            });\n        project.update(cx, |project, cx| {\n            project.cancel_language_server_work_for_buffers(buffers, cx);\n        });\n    }\n\n    fn show_character_palette(\n        &mut self,\n        _: &ShowCharacterPalette,\n        window: &mut Window,\n        _: &mut Context<Self>,\n    ) {\n        window.show_character_palette();\n    }\n\n    fn refresh_active_diagnostics(&mut self, cx: &mut Context<Editor>) {\n        if let Some(active_diagnostics) = self.active_diagnostics.as_mut() {\n            let buffer = self.buffer.read(cx).snapshot(cx);\n            let primary_range_start = active_diagnostics.primary_range.start.to_offset(&buffer);\n            let primary_range_end = active_diagnostics.primary_range.end.to_offset(&buffer);\n            let is_valid = buffer\n                .diagnostics_in_range::<usize>(primary_range_start..primary_range_end)\n                .any(|entry| {\n                    entry.diagnostic.is_primary\n                        && !entry.range.is_empty()\n                        && entry.range.start == primary_range_start\n                        && entry.diagnostic.message == active_diagnostics.primary_message\n                });\n\n            if is_valid != active_diagnostics.is_valid {\n                active_diagnostics.is_valid = is_valid;\n                let mut new_styles = HashMap::default();\n                for (block_id, diagnostic) in &active_diagnostics.blocks {\n                    new_styles.insert(\n                        *block_id,\n                        diagnostic_block_renderer(diagnostic.clone(), None, true, is_valid),\n                    );\n                }\n                self.display_map.update(cx, |display_map, _cx| {\n                    display_map.replace_blocks(new_styles)\n                });\n            }\n        }\n    }\n\n    fn activate_diagnostics(\n        &mut self,\n        buffer_id: BufferId,\n        group_id: usize,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.dismiss_diagnostics(cx);\n        let snapshot = self.snapshot(window, cx);\n        self.active_diagnostics = self.display_map.update(cx, |display_map, cx| {\n            let buffer = self.buffer.read(cx).snapshot(cx);\n\n            let mut primary_range = None;\n            let mut primary_message = None;\n            let diagnostic_group = buffer\n                .diagnostic_group(buffer_id, group_id)\n                .filter_map(|entry| {\n                    let start = entry.range.start;\n                    let end = entry.range.end;\n                    if snapshot.is_line_folded(MultiBufferRow(start.row))\n                        && (start.row == end.row\n                            || snapshot.is_line_folded(MultiBufferRow(end.row)))\n                    {\n                        return None;\n                    }\n                    if entry.diagnostic.is_primary {\n                        primary_range = Some(entry.range.clone());\n                        primary_message = Some(entry.diagnostic.message.clone());\n                    }\n                    Some(entry)\n                })\n                .collect::<Vec<_>>();\n            let primary_range = primary_range?;\n            let primary_message = primary_message?;\n\n            let blocks = display_map\n                .insert_blocks(\n                    diagnostic_group.iter().map(|entry| {\n                        let diagnostic = entry.diagnostic.clone();\n                        let message_height = diagnostic.message.matches('\\n').count() as u32 + 1;\n                        BlockProperties {\n                            style: BlockStyle::Fixed,\n                            placement: BlockPlacement::Below(\n                                buffer.anchor_after(entry.range.start),\n                            ),\n                            height: message_height,\n                            render: diagnostic_block_renderer(diagnostic, None, true, true),\n                            priority: 0,\n                        }\n                    }),\n                    cx,\n                )\n                .into_iter()\n                .zip(diagnostic_group.into_iter().map(|entry| entry.diagnostic))\n                .collect();\n\n            Some(ActiveDiagnosticGroup {\n                primary_range: buffer.anchor_before(primary_range.start)\n                    ..buffer.anchor_after(primary_range.end),\n                primary_message,\n                group_id,\n                blocks,\n                is_valid: true,\n            })\n        });\n    }\n\n    fn dismiss_diagnostics(&mut self, cx: &mut Context<Self>) {\n        if let Some(active_diagnostic_group) = self.active_diagnostics.take() {\n            self.display_map.update(cx, |display_map, cx| {\n                display_map.remove_blocks(active_diagnostic_group.blocks.into_keys().collect(), cx);\n            });\n            cx.notify();\n        }\n    }\n\n    pub fn set_selections_from_remote(\n        &mut self,\n        selections: Vec<Selection<Anchor>>,\n        pending_selection: Option<Selection<Anchor>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let old_cursor_position = self.selections.newest_anchor().head();\n        self.selections.change_with(cx, |s| {\n            s.select_anchors(selections);\n            if let Some(pending_selection) = pending_selection {\n                s.set_pending(pending_selection, SelectMode::Character);\n            } else {\n                s.clear_pending();\n            }\n        });\n        self.selections_did_change(false, &old_cursor_position, true, window, cx);\n    }\n\n    fn push_to_selection_history(&mut self) {\n        self.selection_history.push(SelectionHistoryEntry {\n            selections: self.selections.disjoint_anchors(),\n            select_next_state: self.select_next_state.clone(),\n            select_prev_state: self.select_prev_state.clone(),\n            add_selections_state: self.add_selections_state.clone(),\n        });\n    }\n\n    pub fn transact(\n        &mut self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut Self, &mut Window, &mut Context<Self>),\n    ) -> Option<TransactionId> {\n        self.start_transaction_at(Instant::now(), window, cx);\n        update(self, window, cx);\n        self.end_transaction_at(Instant::now(), cx)\n    }\n\n    pub fn start_transaction_at(\n        &mut self,\n        now: Instant,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.end_selection(window, cx);\n        if let Some(tx_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.start_transaction_at(now, cx))\n        {\n            self.selection_history\n                .insert_transaction(tx_id, self.selections.disjoint_anchors());\n            cx.emit(EditorEvent::TransactionBegun {\n                transaction_id: tx_id,\n            })\n        }\n    }\n\n    pub fn end_transaction_at(\n        &mut self,\n        now: Instant,\n        cx: &mut Context<Self>,\n    ) -> Option<TransactionId> {\n        if let Some(transaction_id) = self\n            .buffer\n            .update(cx, |buffer, cx| buffer.end_transaction_at(now, cx))\n        {\n            if let Some((_, end_selections)) =\n                self.selection_history.transaction_mut(transaction_id)\n            {\n                *end_selections = Some(self.selections.disjoint_anchors());\n            } else {\n                log::error!(\"unexpectedly ended a transaction that wasn't started by this editor\");\n            }\n\n            cx.emit(EditorEvent::Edited { transaction_id });\n            Some(transaction_id)\n        } else {\n            None\n        }\n    }\n\n    pub fn set_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n        if self.selection_mark_mode {\n            self.change_selections(None, window, cx, |s| {\n                s.move_with(|_, sel| {\n                    sel.collapse_to(sel.head(), SelectionGoal::None);\n                });\n            })\n        }\n        self.selection_mark_mode = true;\n        cx.notify();\n    }\n\n    pub fn swap_selection_ends(\n        &mut self,\n        _: &actions::SwapSelectionEnds,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.change_selections(None, window, cx, |s| {\n            s.move_with(|_, sel| {\n                if sel.start != sel.end {\n                    sel.reversed = !sel.reversed\n                }\n            });\n        });\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        cx.notify();\n    }\n\n    pub fn toggle_fold(\n        &mut self,\n        _: &actions::ToggleFold,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.is_singleton(cx) {\n            let selection = self.selections.newest::<Point>(cx);\n\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let range = if selection.is_empty() {\n                let point = selection.head().to_display_point(&display_map);\n                let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n                let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                    .to_point(&display_map);\n                start..end\n            } else {\n                selection.range()\n            };\n            if display_map.folds_in_range(range).next().is_some() {\n                self.unfold_lines(&Default::default(), window, cx)\n            } else {\n                self.fold(&Default::default(), window, cx)\n            }\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids: HashSet<_> = multi_buffer_snapshot\n                .ranges_to_buffer_ranges(self.selections.disjoint_anchor_ranges())\n                .map(|(snapshot, _, _)| snapshot.remote_id())\n                .collect();\n\n            for buffer_id in buffer_ids {\n                if self.is_buffer_folded(buffer_id, cx) {\n                    self.unfold_buffer(buffer_id, cx);\n                } else {\n                    self.fold_buffer(buffer_id, cx);\n                }\n            }\n        }\n    }\n\n    pub fn toggle_fold_recursive(\n        &mut self,\n        _: &actions::ToggleFoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self.selections.newest::<Point>(cx);\n\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let range = if selection.is_empty() {\n            let point = selection.head().to_display_point(&display_map);\n            let start = DisplayPoint::new(point.row(), 0).to_point(&display_map);\n            let end = DisplayPoint::new(point.row(), display_map.line_len(point.row()))\n                .to_point(&display_map);\n            start..end\n        } else {\n            selection.range()\n        };\n        if display_map.folds_in_range(range).next().is_some() {\n            self.unfold_recursive(&Default::default(), window, cx)\n        } else {\n            self.fold_recursive(&Default::default(), window, cx)\n        }\n    }\n\n    pub fn fold(&mut self, _: &actions::Fold, window: &mut Window, cx: &mut Context<Self>) {\n        if self.is_singleton(cx) {\n            let mut to_fold = Vec::new();\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let selections = self.selections.all_adjusted(cx);\n\n            for selection in selections {\n                let range = selection.range().sorted();\n                let buffer_start_row = range.start.row;\n\n                if range.start.row != range.end.row {\n                    let mut found = false;\n                    let mut row = range.start.row;\n                    while row <= range.end.row {\n                        if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row))\n                        {\n                            found = true;\n                            row = crease.range().end.row + 1;\n                            to_fold.push(crease);\n                        } else {\n                            row += 1\n                        }\n                    }\n                    if found {\n                        continue;\n                    }\n                }\n\n                for row in (0..=range.start.row).rev() {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                        if crease.range().end.row >= buffer_start_row {\n                            to_fold.push(crease);\n                            if row <= range.start.row {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            self.fold_creases(to_fold, true, window, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n\n            let buffer_ids: HashSet<_> = multi_buffer_snapshot\n                .ranges_to_buffer_ranges(self.selections.disjoint_anchor_ranges())\n                .map(|(snapshot, _, _)| snapshot.remote_id())\n                .collect();\n            for buffer_id in buffer_ids {\n                self.fold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    fn fold_at_level(\n        &mut self,\n        fold_at: &FoldAtLevel,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.buffer.read(cx).is_singleton() {\n            return;\n        }\n\n        let fold_at_level = fold_at.0;\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let mut to_fold = Vec::new();\n        let mut stack = vec![(0, snapshot.max_row().0, 1)];\n\n        while let Some((mut start_row, end_row, current_level)) = stack.pop() {\n            while start_row < end_row {\n                match self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(start_row))\n                {\n                    Some(crease) => {\n                        let nested_start_row = crease.range().start.row + 1;\n                        let nested_end_row = crease.range().end.row;\n\n                        if current_level < fold_at_level {\n                            stack.push((nested_start_row, nested_end_row, current_level + 1));\n                        } else if current_level == fold_at_level {\n                            to_fold.push(crease);\n                        }\n\n                        start_row = nested_end_row + 1;\n                    }\n                    None => start_row += 1,\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_all(&mut self, _: &actions::FoldAll, window: &mut Window, cx: &mut Context<Self>) {\n        if self.buffer.read(cx).is_singleton() {\n            let mut fold_ranges = Vec::new();\n            let snapshot = self.buffer.read(cx).snapshot(cx);\n\n            for row in 0..snapshot.max_row().0 {\n                if let Some(foldable_range) = self\n                    .snapshot(window, cx)\n                    .crease_for_buffer_row(MultiBufferRow(row))\n                {\n                    fold_ranges.push(foldable_range);\n                }\n            }\n\n            self.fold_creases(fold_ranges, true, window, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn_in(window, |editor, mut cx| async move {\n                editor\n                    .update_in(&mut cx, |editor, _, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.fold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_function_bodies(\n        &mut self,\n        _: &actions::FoldFunctionBodies,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n\n        let ranges = snapshot\n            .text_object_ranges(0..snapshot.len(), TreeSitterOptions::default())\n            .filter_map(|(range, obj)| (obj == TextObject::InsideFunction).then_some(range))\n            .collect::<Vec<_>>();\n\n        let creases = ranges\n            .into_iter()\n            .map(|range| Crease::simple(range, self.display_map.read(cx).fold_placeholder.clone()))\n            .collect();\n\n        self.fold_creases(creases, true, window, cx);\n    }\n\n    pub fn fold_recursive(\n        &mut self,\n        _: &actions::FoldRecursive,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut to_fold = Vec::new();\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all_adjusted(cx);\n\n        for selection in selections {\n            let range = selection.range().sorted();\n            let buffer_start_row = range.start.row;\n\n            if range.start.row != range.end.row {\n                let mut found = false;\n                for row in range.start.row..=range.end.row {\n                    if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                        found = true;\n                        to_fold.push(crease);\n                    }\n                }\n                if found {\n                    continue;\n                }\n            }\n\n            for row in (0..=range.start.row).rev() {\n                if let Some(crease) = display_map.crease_for_buffer_row(MultiBufferRow(row)) {\n                    if crease.range().end.row >= buffer_start_row {\n                        to_fold.push(crease);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        self.fold_creases(to_fold, true, window, cx);\n    }\n\n    pub fn fold_at(&mut self, fold_at: &FoldAt, window: &mut Window, cx: &mut Context<Self>) {\n        let buffer_row = fold_at.buffer_row;\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        if let Some(crease) = display_map.crease_for_buffer_row(buffer_row) {\n            let autoscroll = self\n                .selections\n                .all::<Point>(cx)\n                .iter()\n                .any(|selection| crease.range().overlaps(&selection.range()));\n\n            self.fold_creases(vec![crease], autoscroll, window, cx);\n        }\n    }\n\n    pub fn unfold_lines(&mut self, _: &UnfoldLines, _window: &mut Window, cx: &mut Context<Self>) {\n        if self.is_singleton(cx) {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            let buffer = &display_map.buffer_snapshot;\n            let selections = self.selections.all::<Point>(cx);\n            let ranges = selections\n                .iter()\n                .map(|s| {\n                    let range = s.display_range(&display_map).sorted();\n                    let mut start = range.start.to_point(&display_map);\n                    let mut end = range.end.to_point(&display_map);\n                    start.column = 0;\n                    end.column = buffer.line_len(MultiBufferRow(end.row));\n                    start..end\n                })\n                .collect::<Vec<_>>();\n\n            self.unfold_ranges(&ranges, true, true, cx);\n        } else {\n            let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n            let buffer_ids: HashSet<_> = multi_buffer_snapshot\n                .ranges_to_buffer_ranges(self.selections.disjoint_anchor_ranges())\n                .map(|(snapshot, _, _)| snapshot.remote_id())\n                .collect();\n            for buffer_id in buffer_ids {\n                self.unfold_buffer(buffer_id, cx);\n            }\n        }\n    }\n\n    pub fn unfold_recursive(\n        &mut self,\n        _: &UnfoldRecursive,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let selections = self.selections.all::<Point>(cx);\n        let ranges = selections\n            .iter()\n            .map(|s| {\n                let mut range = s.display_range(&display_map).sorted();\n                *range.start.column_mut() = 0;\n                *range.end.column_mut() = display_map.line_len(range.end.row());\n                let start = range.start.to_point(&display_map);\n                let end = range.end.to_point(&display_map);\n                start..end\n            })\n            .collect::<Vec<_>>();\n\n        self.unfold_ranges(&ranges, true, true, cx);\n    }\n\n    pub fn unfold_at(\n        &mut self,\n        unfold_at: &UnfoldAt,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n\n        let intersection_range = Point::new(unfold_at.buffer_row.0, 0)\n            ..Point::new(\n                unfold_at.buffer_row.0,\n                display_map.buffer_snapshot.line_len(unfold_at.buffer_row),\n            );\n\n        let autoscroll = self\n            .selections\n            .all::<Point>(cx)\n            .iter()\n            .any(|selection| RangeExt::overlaps(&selection.range(), &intersection_range));\n\n        self.unfold_ranges(&[intersection_range], true, autoscroll, cx);\n    }\n\n    pub fn unfold_all(\n        &mut self,\n        _: &actions::UnfoldAll,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.buffer.read(cx).is_singleton() {\n            let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n            self.unfold_ranges(&[0..display_map.buffer_snapshot.len()], true, true, cx);\n        } else {\n            self.toggle_fold_multiple_buffers = cx.spawn(|editor, mut cx| async move {\n                editor\n                    .update(&mut cx, |editor, cx| {\n                        for buffer_id in editor.buffer.read(cx).excerpt_buffer_ids() {\n                            editor.unfold_buffer(buffer_id, cx);\n                        }\n                    })\n                    .ok();\n            });\n        }\n    }\n\n    pub fn fold_selected_ranges(\n        &mut self,\n        _: &FoldSelectedRanges,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selections = self.selections.all::<Point>(cx);\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let line_mode = self.selections.line_mode;\n        let ranges = selections\n            .into_iter()\n            .map(|s| {\n                if line_mode {\n                    let start = Point::new(s.start.row, 0);\n                    let end = Point::new(\n                        s.end.row,\n                        display_map\n                            .buffer_snapshot\n                            .line_len(MultiBufferRow(s.end.row)),\n                    );\n                    Crease::simple(start..end, display_map.fold_placeholder.clone())\n                } else {\n                    Crease::simple(s.start..s.end, display_map.fold_placeholder.clone())\n                }\n            })\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, true, window, cx);\n    }\n\n    pub fn fold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: Vec<Range<T>>,\n        auto_scroll: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n        let ranges = ranges\n            .into_iter()\n            .map(|r| Crease::simple(r, display_map.fold_placeholder.clone()))\n            .collect::<Vec<_>>();\n        self.fold_creases(ranges, auto_scroll, window, cx);\n    }\n\n    pub fn fold_creases<T: ToOffset + Clone>(\n        &mut self,\n        creases: Vec<Crease<T>>,\n        auto_scroll: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if creases.is_empty() {\n            return;\n        }\n\n        let mut buffers_affected = HashSet::default();\n        let multi_buffer = self.buffer().read(cx);\n        for crease in &creases {\n            if let Some((_, buffer, _)) =\n                multi_buffer.excerpt_containing(crease.range().start.clone(), cx)\n            {\n                buffers_affected.insert(buffer.read(cx).remote_id());\n            };\n        }\n\n        self.display_map.update(cx, |map, cx| map.fold(creases, cx));\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n\n        if let Some(active_diagnostics) = self.active_diagnostics.take() {\n            // Clear diagnostics block when folding a range that contains it.\n            let snapshot = self.snapshot(window, cx);\n            if snapshot.intersects_fold(active_diagnostics.primary_range.start) {\n                drop(snapshot);\n                self.active_diagnostics = Some(active_diagnostics);\n                self.dismiss_diagnostics(cx);\n            } else {\n                self.active_diagnostics = Some(active_diagnostics);\n            }\n        }\n\n        self.scrollbar_marker_state.dirty = true;\n    }\n\n    /// Removes any folds whose ranges intersect any of the given ranges.\n    pub fn unfold_ranges<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        inclusive: bool,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.unfold_intersecting(ranges.iter().cloned(), inclusive, cx)\n        });\n    }\n\n    pub fn fold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n        let folded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map\n            .update(cx, |display_map, cx| display_map.fold_buffer(buffer_id, cx));\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: folded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: true,\n        });\n        cx.notify();\n    }\n\n    pub fn unfold_buffer(&mut self, buffer_id: BufferId, cx: &mut Context<Self>) {\n        if self.buffer().read(cx).is_singleton() || !self.is_buffer_folded(buffer_id, cx) {\n            return;\n        }\n        let unfolded_excerpts = self.buffer().read(cx).excerpts_for_buffer(buffer_id, cx);\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.unfold_buffer(buffer_id, cx);\n        });\n        cx.emit(EditorEvent::BufferFoldToggled {\n            ids: unfolded_excerpts.iter().map(|&(id, _)| id).collect(),\n            folded: false,\n        });\n        cx.notify();\n    }\n\n    pub fn is_buffer_folded(&self, buffer: BufferId, cx: &App) -> bool {\n        self.display_map.read(cx).is_buffer_folded(buffer)\n    }\n\n    pub fn folded_buffers<'a>(&self, cx: &'a App) -> &'a HashSet<BufferId> {\n        self.display_map.read(cx).folded_buffers()\n    }\n\n    /// Removes any folds with the given ranges.\n    pub fn remove_folds_with_type<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        type_id: TypeId,\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.remove_folds_with(ranges, auto_scroll, cx, |map, cx| {\n            map.remove_folds_with_type(ranges.iter().cloned(), type_id, cx)\n        });\n    }\n\n    fn remove_folds_with<T: ToOffset + Clone>(\n        &mut self,\n        ranges: &[Range<T>],\n        auto_scroll: bool,\n        cx: &mut Context<Self>,\n        update: impl FnOnce(&mut DisplayMap, &mut Context<DisplayMap>),\n    ) {\n        if ranges.is_empty() {\n            return;\n        }\n\n        let mut buffers_affected = HashSet::default();\n        let multi_buffer = self.buffer().read(cx);\n        for range in ranges {\n            if let Some((_, buffer, _)) = multi_buffer.excerpt_containing(range.start.clone(), cx) {\n                buffers_affected.insert(buffer.read(cx).remote_id());\n            };\n        }\n\n        self.display_map.update(cx, update);\n\n        if auto_scroll {\n            self.request_autoscroll(Autoscroll::fit(), cx);\n        }\n\n        cx.notify();\n        self.scrollbar_marker_state.dirty = true;\n        self.active_indent_guides_state.dirty = true;\n    }\n\n    pub fn default_fold_placeholder(&self, cx: &App) -> FoldPlaceholder {\n        self.display_map.read(cx).fold_placeholder.clone()\n    }\n\n    pub fn set_expand_all_diff_hunks(&mut self, cx: &mut App) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.set_all_diff_hunks_expanded(cx);\n        });\n    }\n\n    pub fn set_distinguish_unstaged_diff_hunks(&mut self) {\n        self.distinguish_unstaged_diff_hunks = true;\n    }\n\n    pub fn expand_all_diff_hunks(\n        &mut self,\n        _: &ExpandAllHunkDiffs,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            buffer.expand_diff_hunks(vec![Anchor::min()..Anchor::max()], cx)\n        });\n    }\n\n    pub fn toggle_selected_diff_hunks(\n        &mut self,\n        _: &ToggleSelectedDiffHunks,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let ranges: Vec<_> = self.selections.disjoint.iter().map(|s| s.range()).collect();\n        self.toggle_diff_hunks_in_ranges(ranges, cx);\n    }\n\n    pub fn expand_selected_diff_hunks(&mut self, cx: &mut Context<Self>) {\n        let ranges: Vec<_> = self.selections.disjoint.iter().map(|s| s.range()).collect();\n        self.buffer\n            .update(cx, |buffer, cx| buffer.expand_diff_hunks(ranges, cx))\n    }\n\n    pub fn clear_expanded_diff_hunks(&mut self, cx: &mut Context<Self>) -> bool {\n        self.buffer.update(cx, |buffer, cx| {\n            let ranges = vec![Anchor::min()..Anchor::max()];\n            if !buffer.all_diff_hunks_expanded()\n                && buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx)\n            {\n                buffer.collapse_diff_hunks(ranges, cx);\n                true\n            } else {\n                false\n            }\n        })\n    }\n\n    fn toggle_diff_hunks_in_ranges(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<'_, Editor>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            let expand = !buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx);\n            buffer.expand_or_collapse_diff_hunks(ranges, expand, cx);\n        })\n    }\n\n    fn toggle_diff_hunks_in_ranges_narrow(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        cx: &mut Context<'_, Editor>,\n    ) {\n        self.buffer.update(cx, |buffer, cx| {\n            let expand = !buffer.has_expanded_diff_hunks_in_ranges(&ranges, cx);\n            buffer.expand_or_collapse_diff_hunks_narrow(ranges, expand, cx);\n        })\n    }\n\n    pub(crate) fn apply_all_diff_hunks(\n        &mut self,\n        _: &ApplyAllDiffHunks,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let buffers = self.buffer.read(cx).all_buffers();\n        for branch_buffer in buffers {\n            branch_buffer.update(cx, |branch_buffer, cx| {\n                branch_buffer.merge_into_base(Vec::new(), cx);\n            });\n        }\n\n        if let Some(project) = self.project.clone() {\n            self.save(true, project, window, cx).detach_and_log_err(cx);\n        }\n    }\n\n    pub(crate) fn apply_selected_diff_hunks(\n        &mut self,\n        _: &ApplyDiffHunk,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.snapshot(window, cx);\n        let hunks = snapshot.hunks_for_ranges(self.selections.ranges(cx).into_iter());\n        let mut ranges_by_buffer = HashMap::default();\n        self.transact(window, cx, |editor, _window, cx| {\n            for hunk in hunks {\n                if let Some(buffer) = editor.buffer.read(cx).buffer(hunk.buffer_id) {\n                    ranges_by_buffer\n                        .entry(buffer.clone())\n                        .or_insert_with(Vec::new)\n                        .push(hunk.buffer_range.to_offset(buffer.read(cx)));\n                }\n            }\n\n            for (buffer, ranges) in ranges_by_buffer {\n                buffer.update(cx, |buffer, cx| {\n                    buffer.merge_into_base(ranges, cx);\n                });\n            }\n        });\n\n        if let Some(project) = self.project.clone() {\n            self.save(true, project, window, cx).detach_and_log_err(cx);\n        }\n    }\n\n    pub fn set_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n        if hovered != self.gutter_hovered {\n            self.gutter_hovered = hovered;\n            cx.notify();\n        }\n    }\n\n    pub fn insert_blocks(\n        &mut self,\n        blocks: impl IntoIterator<Item = BlockProperties<Anchor>>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CustomBlockId> {\n        let blocks = self\n            .display_map\n            .update(cx, |display_map, cx| display_map.insert_blocks(blocks, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n        blocks\n    }\n\n    pub fn resize_blocks(\n        &mut self,\n        heights: HashMap<CustomBlockId, u32>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, cx| display_map.resize_blocks(heights, cx));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn replace_blocks(\n        &mut self,\n        renderers: HashMap<CustomBlockId, RenderBlock>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |display_map, _cx| display_map.replace_blocks(renderers));\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn remove_blocks(\n        &mut self,\n        block_ids: HashSet<CustomBlockId>,\n        autoscroll: Option<Autoscroll>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |display_map, cx| {\n            display_map.remove_blocks(block_ids, cx)\n        });\n        if let Some(autoscroll) = autoscroll {\n            self.request_autoscroll(autoscroll, cx);\n        }\n        cx.notify();\n    }\n\n    pub fn row_for_block(\n        &self,\n        block_id: CustomBlockId,\n        cx: &mut Context<Self>,\n    ) -> Option<DisplayRow> {\n        self.display_map\n            .update(cx, |map, cx| map.row_for_block(block_id, cx))\n    }\n\n    pub(crate) fn set_focused_block(&mut self, focused_block: FocusedBlock) {\n        self.focused_block = Some(focused_block);\n    }\n\n    pub(crate) fn take_focused_block(&mut self) -> Option<FocusedBlock> {\n        self.focused_block.take()\n    }\n\n    pub fn insert_creases(\n        &mut self,\n        creases: impl IntoIterator<Item = Crease<Anchor>>,\n        cx: &mut Context<Self>,\n    ) -> Vec<CreaseId> {\n        self.display_map\n            .update(cx, |map, cx| map.insert_creases(creases, cx))\n    }\n\n    pub fn remove_creases(\n        &mut self,\n        ids: impl IntoIterator<Item = CreaseId>,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map\n            .update(cx, |map, cx| map.remove_creases(ids, cx));\n    }\n\n    pub fn longest_row(&self, cx: &mut App) -> DisplayRow {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .longest_row()\n    }\n\n    pub fn max_point(&self, cx: &mut App) -> DisplayPoint {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .max_point()\n    }\n\n    pub fn text(&self, cx: &App) -> String {\n        self.buffer.read(cx).read(cx).text()\n    }\n\n    pub fn is_empty(&self, cx: &App) -> bool {\n        self.buffer.read(cx).read(cx).is_empty()\n    }\n\n    pub fn text_option(&self, cx: &App) -> Option<String> {\n        let text = self.text(cx);\n        let text = text.trim();\n\n        if text.is_empty() {\n            return None;\n        }\n\n        Some(text.to_string())\n    }\n\n    pub fn set_text(\n        &mut self,\n        text: impl Into<Arc<str>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.transact(window, cx, |this, _, cx| {\n            this.buffer\n                .read(cx)\n                .as_singleton()\n                .expect(\"you can only call set_text on editors for singleton buffers\")\n                .update(cx, |buffer, cx| buffer.set_text(text, cx));\n        });\n    }\n\n    pub fn display_text(&self, cx: &mut App) -> String {\n        self.display_map\n            .update(cx, |map, cx| map.snapshot(cx))\n            .text()\n    }\n\n    pub fn wrap_guides(&self, cx: &App) -> SmallVec<[(usize, bool); 2]> {\n        let mut wrap_guides = smallvec::smallvec![];\n\n        if self.show_wrap_guides == Some(false) {\n            return wrap_guides;\n        }\n\n        let settings = self.buffer.read(cx).settings_at(0, cx);\n        if settings.show_wrap_guides {\n            if let SoftWrap::Column(soft_wrap) = self.soft_wrap_mode(cx) {\n                wrap_guides.push((soft_wrap as usize, true));\n            } else if let SoftWrap::Bounded(soft_wrap) = self.soft_wrap_mode(cx) {\n                wrap_guides.push((soft_wrap as usize, true));\n            }\n            wrap_guides.extend(settings.wrap_guides.iter().map(|guide| (*guide, false)))\n        }\n\n        wrap_guides\n    }\n\n    pub fn soft_wrap_mode(&self, cx: &App) -> SoftWrap {\n        let settings = self.buffer.read(cx).settings_at(0, cx);\n        let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n        match mode {\n            language_settings::SoftWrap::PreferLine | language_settings::SoftWrap::None => {\n                SoftWrap::None\n            }\n            language_settings::SoftWrap::EditorWidth => SoftWrap::EditorWidth,\n            language_settings::SoftWrap::PreferredLineLength => {\n                SoftWrap::Column(settings.preferred_line_length)\n            }\n            language_settings::SoftWrap::Bounded => {\n                SoftWrap::Bounded(settings.preferred_line_length)\n            }\n        }\n    }\n\n    pub fn set_soft_wrap_mode(\n        &mut self,\n        mode: language_settings::SoftWrap,\n\n        cx: &mut Context<Self>,\n    ) {\n        self.soft_wrap_mode_override = Some(mode);\n        cx.notify();\n    }\n\n    pub fn set_text_style_refinement(&mut self, style: TextStyleRefinement) {\n        self.text_style_refinement = Some(style);\n    }\n\n    /// called by the Element so we know what style we were most recently rendered with.\n    pub(crate) fn set_style(\n        &mut self,\n        style: EditorStyle,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let rem_size = window.rem_size();\n        self.display_map.update(cx, |map, cx| {\n            map.set_font(\n                style.text.font(),\n                style.text.font_size.to_pixels(rem_size),\n                cx,\n            )\n        });\n        self.style = Some(style);\n    }\n\n    pub fn style(&self) -> Option<&EditorStyle> {\n        self.style.as_ref()\n    }\n\n    // Called by the element. This method is not designed to be called outside of the editor\n    // element's layout code because it does not notify when rewrapping is computed synchronously.\n    pub(crate) fn set_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n        self.display_map\n            .update(cx, |map, cx| map.set_wrap_width(width, cx))\n    }\n\n    pub fn set_soft_wrap(&mut self) {\n        self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n    }\n\n    pub fn toggle_soft_wrap(&mut self, _: &ToggleSoftWrap, _: &mut Window, cx: &mut Context<Self>) {\n        if self.soft_wrap_mode_override.is_some() {\n            self.soft_wrap_mode_override.take();\n        } else {\n            let soft_wrap = match self.soft_wrap_mode(cx) {\n                SoftWrap::GitDiff => return,\n                SoftWrap::None => language_settings::SoftWrap::EditorWidth,\n                SoftWrap::EditorWidth | SoftWrap::Column(_) | SoftWrap::Bounded(_) => {\n                    language_settings::SoftWrap::None\n                }\n            };\n            self.soft_wrap_mode_override = Some(soft_wrap);\n        }\n        cx.notify();\n    }\n\n    pub fn toggle_tab_bar(&mut self, _: &ToggleTabBar, _: &mut Window, cx: &mut Context<Self>) {\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n        let fs = workspace.read(cx).app_state().fs.clone();\n        let current_show = TabBarSettings::get_global(cx).show;\n        update_settings_file::<TabBarSettings>(fs, cx, move |setting, _| {\n            setting.show = Some(!current_show);\n        });\n    }\n\n    pub fn toggle_indent_guides(\n        &mut self,\n        _: &ToggleIndentGuides,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let currently_enabled = self.should_show_indent_guides().unwrap_or_else(|| {\n            self.buffer\n                .read(cx)\n                .settings_at(0, cx)\n                .indent_guides\n                .enabled\n        });\n        self.show_indent_guides = Some(!currently_enabled);\n        cx.notify();\n    }\n\n    fn should_show_indent_guides(&self) -> Option<bool> {\n        self.show_indent_guides\n    }\n\n    pub fn toggle_line_numbers(\n        &mut self,\n        _: &ToggleLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let mut editor_settings = EditorSettings::get_global(cx).clone();\n        editor_settings.gutter.line_numbers = !editor_settings.gutter.line_numbers;\n        EditorSettings::override_global(editor_settings, cx);\n    }\n\n    pub fn should_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n        self.use_relative_line_numbers\n            .unwrap_or(EditorSettings::get_global(cx).relative_line_numbers)\n    }\n\n    pub fn toggle_relative_line_numbers(\n        &mut self,\n        _: &ToggleRelativeLineNumbers,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let is_relative = self.should_use_relative_line_numbers(cx);\n        self.set_relative_line_number(Some(!is_relative), cx)\n    }\n\n    pub fn set_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n        self.use_relative_line_numbers = is_relative;\n        cx.notify();\n    }\n\n    pub fn set_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n        self.show_gutter = show_gutter;\n        cx.notify();\n    }\n\n    pub fn set_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n        self.show_scrollbars = show_scrollbars;\n        cx.notify();\n    }\n\n    pub fn set_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n        self.show_line_numbers = Some(show_line_numbers);\n        cx.notify();\n    }\n\n    pub fn set_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n        self.show_git_diff_gutter = Some(show_git_diff_gutter);\n        cx.notify();\n    }\n\n    pub fn set_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n        self.show_code_actions = Some(show_code_actions);\n        cx.notify();\n    }\n\n    pub fn set_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n        self.show_runnables = Some(show_runnables);\n        cx.notify();\n    }\n\n    pub fn set_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n        if self.display_map.read(cx).masked != masked {\n            self.display_map.update(cx, |map, _| map.masked = masked);\n        }\n        cx.notify()\n    }\n\n    pub fn set_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n        self.show_wrap_guides = Some(show_wrap_guides);\n        cx.notify();\n    }\n\n    pub fn set_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n        self.show_indent_guides = Some(show_indent_guides);\n        cx.notify();\n    }\n\n    pub fn working_directory(&self, cx: &App) -> Option<PathBuf> {\n        if let Some(buffer) = self.buffer().read(cx).as_singleton() {\n            if let Some(file) = buffer.read(cx).file().and_then(|f| f.as_local()) {\n                if let Some(dir) = file.abs_path(cx).parent() {\n                    return Some(dir.to_owned());\n                }\n            }\n\n            if let Some(project_path) = buffer.read(cx).project_path(cx) {\n                return Some(project_path.path.to_path_buf());\n            }\n        }\n\n        None\n    }\n\n    fn target_file<'a>(&self, cx: &'a App) -> Option<&'a dyn language::LocalFile> {\n        self.active_excerpt(cx)?\n            .1\n            .read(cx)\n            .file()\n            .and_then(|f| f.as_local())\n    }\n\n    pub fn target_file_abs_path(&self, cx: &mut Context<Self>) -> Option<PathBuf> {\n        self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let buffer = buffer.read(cx);\n            if let Some(project_path) = buffer.project_path(cx) {\n                let project = self.project.as_ref()?.read(cx);\n                project.absolute_path(&project_path, cx)\n            } else {\n                buffer\n                    .file()\n                    .and_then(|file| file.as_local().map(|file| file.abs_path(cx)))\n            }\n        })\n    }\n\n    fn target_file_path(&self, cx: &mut Context<Self>) -> Option<PathBuf> {\n        self.active_excerpt(cx).and_then(|(_, buffer, _)| {\n            let project_path = buffer.read(cx).project_path(cx)?;\n            let project = self.project.as_ref()?.read(cx);\n            let entry = project.entry_for_path(&project_path, cx)?;\n            let path = entry.path.to_path_buf();\n            Some(path)\n        })\n    }\n\n    pub fn reveal_in_finder(\n        &mut self,\n        _: &RevealInFileManager,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(target) = self.target_file(cx) {\n            cx.reveal_path(&target.abs_path(cx));\n        }\n    }\n\n    pub fn copy_path(&mut self, _: &CopyPath, _window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(path) = self.target_file_abs_path(cx) {\n            if let Some(path) = path.to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n            }\n        }\n    }\n\n    pub fn copy_relative_path(\n        &mut self,\n        _: &CopyRelativePath,\n        _window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(path) = self.target_file_path(cx) {\n            if let Some(path) = path.to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(path.to_string()));\n            }\n        }\n    }\n\n    pub fn copy_file_name_without_extension(\n        &mut self,\n        _: &CopyFileNameWithoutExtension,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(file) = self.target_file(cx) {\n            if let Some(file_stem) = file.path().file_stem() {\n                if let Some(name) = file_stem.to_str() {\n                    cx.write_to_clipboard(ClipboardItem::new_string(name.to_string()));\n                }\n            }\n        }\n    }\n\n    pub fn copy_file_name(&mut self, _: &CopyFileName, _: &mut Window, cx: &mut Context<Self>) {\n        if let Some(file) = self.target_file(cx) {\n            if let Some(file_name) = file.path().file_name() {\n                if let Some(name) = file_name.to_str() {\n                    cx.write_to_clipboard(ClipboardItem::new_string(name.to_string()));\n                }\n            }\n        }\n    }\n\n    pub fn toggle_git_blame(\n        &mut self,\n        _: &ToggleGitBlame,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_git_blame_gutter = !self.show_git_blame_gutter;\n\n        if self.show_git_blame_gutter && !self.has_blame_entries(cx) {\n            self.start_git_blame(true, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    pub fn toggle_git_blame_inline(\n        &mut self,\n        _: &ToggleGitBlameInline,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.toggle_git_blame_inline_internal(true, window, cx);\n        cx.notify();\n    }\n\n    pub fn git_blame_inline_enabled(&self) -> bool {\n        self.git_blame_inline_enabled\n    }\n\n    pub fn toggle_selection_menu(\n        &mut self,\n        _: &ToggleSelectionMenu,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.show_selection_menu = self\n            .show_selection_menu\n            .map(|show_selections_menu| !show_selections_menu)\n            .or_else(|| Some(!EditorSettings::get_global(cx).toolbar.selections_menu));\n\n        cx.notify();\n    }\n\n    pub fn selection_menu_enabled(&self, cx: &App) -> bool {\n        self.show_selection_menu\n            .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n    }\n\n    fn start_git_blame(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if let Some(project) = self.project.as_ref() {\n            let Some(buffer) = self.buffer().read(cx).as_singleton() else {\n                return;\n            };\n\n            if buffer.read(cx).file().is_none() {\n                return;\n            }\n\n            let focused = self.focus_handle(cx).contains_focused(window, cx);\n\n            let project = project.clone();\n            let blame = cx.new(|cx| GitBlame::new(buffer, project, user_triggered, focused, cx));\n            self.blame_subscription =\n                Some(cx.observe_in(&blame, window, |_, _, _, cx| cx.notify()));\n            self.blame = Some(blame);\n        }\n    }\n\n    fn toggle_git_blame_inline_internal(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if self.git_blame_inline_enabled {\n            self.git_blame_inline_enabled = false;\n            self.show_git_blame_inline = false;\n            self.show_git_blame_inline_delay_task.take();\n        } else {\n            self.git_blame_inline_enabled = true;\n            self.start_git_blame_inline(user_triggered, window, cx);\n        }\n\n        cx.notify();\n    }\n\n    fn start_git_blame_inline(\n        &mut self,\n        user_triggered: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.start_git_blame(user_triggered, window, cx);\n\n        if ProjectSettings::get_global(cx)\n            .git\n            .inline_blame_delay()\n            .is_some()\n        {\n            self.start_inline_blame_timer(window, cx);\n        } else {\n            self.show_git_blame_inline = true\n        }\n    }\n\n    pub fn blame(&self) -> Option<&Entity<GitBlame>> {\n        self.blame.as_ref()\n    }\n\n    pub fn show_git_blame_gutter(&self) -> bool {\n        self.show_git_blame_gutter\n    }\n\n    pub fn render_git_blame_gutter(&self, cx: &App) -> bool {\n        self.show_git_blame_gutter && self.has_blame_entries(cx)\n    }\n\n    pub fn render_git_blame_inline(&self, window: &Window, cx: &App) -> bool {\n        self.show_git_blame_inline\n            && self.focus_handle.is_focused(window)\n            && !self.newest_selection_head_on_empty_line(cx)\n            && self.has_blame_entries(cx)\n    }\n\n    fn has_blame_entries(&self, cx: &App) -> bool {\n        self.blame()\n            .map_or(false, |blame| blame.read(cx).has_generated_entries())\n    }\n\n    fn newest_selection_head_on_empty_line(&self, cx: &App) -> bool {\n        let cursor_anchor = self.selections.newest_anchor().head();\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let buffer_row = MultiBufferRow(cursor_anchor.to_point(&snapshot).row);\n\n        snapshot.line_len(buffer_row) == 0\n    }\n\n    fn get_permalink_to_line(&self, cx: &mut Context<Self>) -> Task<Result<url::Url>> {\n        let buffer_and_selection = maybe!({\n            let selection = self.selections.newest::<Point>(cx);\n            let selection_range = selection.range();\n\n            let multi_buffer = self.buffer().read(cx);\n            let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n            let buffer_ranges = multi_buffer_snapshot.range_to_buffer_ranges(selection_range);\n\n            let (buffer, range, _) = if selection.reversed {\n                buffer_ranges.first()\n            } else {\n                buffer_ranges.last()\n            }?;\n\n            let selection = text::ToPoint::to_point(&range.start, &buffer).row\n                ..text::ToPoint::to_point(&range.end, &buffer).row;\n            Some((\n                multi_buffer.buffer(buffer.remote_id()).unwrap().clone(),\n                selection,\n            ))\n        });\n\n        let Some((buffer, selection)) = buffer_and_selection else {\n            return Task::ready(Err(anyhow!(\"failed to determine buffer and selection\")));\n        };\n\n        let Some(project) = self.project.as_ref() else {\n            return Task::ready(Err(anyhow!(\"editor does not have project\")));\n        };\n\n        project.update(cx, |project, cx| {\n            project.get_permalink_to_line(&buffer, selection, cx)\n        })\n    }\n\n    pub fn copy_permalink_to_line(\n        &mut self,\n        _: &CopyPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, |_, mut cx| async move {\n            match permalink_task.await {\n                Ok(permalink) => {\n                    cx.update(|_, cx| {\n                        cx.write_to_clipboard(ClipboardItem::new_string(permalink.to_string()));\n                    })\n                    .ok();\n                }\n                Err(err) => {\n                    let message = format!(\"Failed to copy permalink: {err}\");\n\n                    Err::<(), anyhow::Error>(err).log_err();\n\n                    if let Some(workspace) = workspace {\n                        workspace\n                            .update_in(&mut cx, |workspace, _, cx| {\n                                struct CopyPermalinkToLine;\n\n                                workspace.show_toast(\n                                    Toast::new(\n                                        NotificationId::unique::<CopyPermalinkToLine>(),\n                                        message,\n                                    ),\n                                    cx,\n                                )\n                            })\n                            .ok();\n                    }\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn copy_file_location(\n        &mut self,\n        _: &CopyFileLocation,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let selection = self.selections.newest::<Point>(cx).start.row + 1;\n        if let Some(file) = self.target_file(cx) {\n            if let Some(path) = file.path().to_str() {\n                cx.write_to_clipboard(ClipboardItem::new_string(format!(\"{path}:{selection}\")));\n            }\n        }\n    }\n\n    pub fn open_permalink_to_line(\n        &mut self,\n        _: &OpenPermalinkToLine,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let permalink_task = self.get_permalink_to_line(cx);\n        let workspace = self.workspace();\n\n        cx.spawn_in(window, |_, mut cx| async move {\n            match permalink_task.await {\n                Ok(permalink) => {\n                    cx.update(|_, cx| {\n                        cx.open_url(permalink.as_ref());\n                    })\n                    .ok();\n                }\n                Err(err) => {\n                    let message = format!(\"Failed to open permalink: {err}\");\n\n                    Err::<(), anyhow::Error>(err).log_err();\n\n                    if let Some(workspace) = workspace {\n                        workspace\n                            .update(&mut cx, |workspace, cx| {\n                                struct OpenPermalinkToLine;\n\n                                workspace.show_toast(\n                                    Toast::new(\n                                        NotificationId::unique::<OpenPermalinkToLine>(),\n                                        message,\n                                    ),\n                                    cx,\n                                )\n                            })\n                            .ok();\n                    }\n                }\n            }\n        })\n        .detach();\n    }\n\n    pub fn insert_uuid_v4(\n        &mut self,\n        _: &InsertUuidV4,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V4, window, cx);\n    }\n\n    pub fn insert_uuid_v7(\n        &mut self,\n        _: &InsertUuidV7,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.insert_uuid(UuidVersion::V7, window, cx);\n    }\n\n    fn insert_uuid(&mut self, version: UuidVersion, window: &mut Window, cx: &mut Context<Self>) {\n        self.transact(window, cx, |this, window, cx| {\n            let edits = this\n                .selections\n                .all::<Point>(cx)\n                .into_iter()\n                .map(|selection| {\n                    let uuid = match version {\n                        UuidVersion::V4 => uuid::Uuid::new_v4(),\n                        UuidVersion::V7 => uuid::Uuid::now_v7(),\n                    };\n\n                    (selection.range(), uuid.to_string())\n                });\n            this.edit(edits, cx);\n            this.refresh_inline_completion(true, false, window, cx);\n        });\n    }\n\n    pub fn open_selections_in_multibuffer(\n        &mut self,\n        _: &OpenSelectionsInMultibuffer,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let multibuffer = self.buffer.read(cx);\n\n        let Some(buffer) = multibuffer.as_singleton() else {\n            return;\n        };\n\n        let Some(workspace) = self.workspace() else {\n            return;\n        };\n\n        let locations = self\n            .selections\n            .disjoint_anchors()\n            .iter()\n            .map(|range| Location {\n                buffer: buffer.clone(),\n                range: range.start.text_anchor..range.end.text_anchor,\n            })\n            .collect::<Vec<_>>();\n\n        let title = multibuffer.title(cx).to_string();\n\n        cx.spawn_in(window, |_, mut cx| async move {\n            workspace.update_in(&mut cx, |workspace, window, cx| {\n                Self::open_locations_in_multibuffer(\n                    workspace,\n                    locations,\n                    format!(\"Selections for '{title}'\"),\n                    false,\n                    MultibufferSelectionMode::All,\n                    window,\n                    cx,\n                );\n            })\n        })\n        .detach();\n    }\n\n    /// Adds a row highlight for the given range. If a row has multiple highlights, the\n    /// last highlight added will be used.\n    ///\n    /// If the range ends at the beginning of a line, then that line will not be highlighted.\n    pub fn highlight_rows<T: 'static>(\n        &mut self,\n        range: Range<Anchor>,\n        color: Hsla,\n        should_autoscroll: bool,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let ix = row_highlights.binary_search_by(|highlight| {\n            Ordering::Equal\n                .then_with(|| highlight.range.start.cmp(&range.start, &snapshot))\n                .then_with(|| highlight.range.end.cmp(&range.end, &snapshot))\n        });\n\n        if let Err(mut ix) = ix {\n            let index = post_inc(&mut self.highlight_order);\n\n            // If this range intersects with the preceding highlight, then merge it with\n            // the preceding highlight. Otherwise insert a new highlight.\n            let mut merged = false;\n            if ix > 0 {\n                let prev_highlight = &mut row_highlights[ix - 1];\n                if prev_highlight\n                    .range\n                    .end\n                    .cmp(&range.start, &snapshot)\n                    .is_ge()\n                {\n                    ix -= 1;\n                    if prev_highlight.range.end.cmp(&range.end, &snapshot).is_lt() {\n                        prev_highlight.range.end = range.end;\n                    }\n                    merged = true;\n                    prev_highlight.index = index;\n                    prev_highlight.color = color;\n                    prev_highlight.should_autoscroll = should_autoscroll;\n                }\n            }\n\n            if !merged {\n                row_highlights.insert(\n                    ix,\n                    RowHighlight {\n                        range: range.clone(),\n                        index,\n                        color,\n                        should_autoscroll,\n                    },\n                );\n            }\n\n            // If any of the following highlights intersect with this one, merge them.\n            while let Some(next_highlight) = row_highlights.get(ix + 1) {\n                let highlight = &row_highlights[ix];\n                if next_highlight\n                    .range\n                    .start\n                    .cmp(&highlight.range.end, &snapshot)\n                    .is_le()\n                {\n                    if next_highlight\n                        .range\n                        .end\n                        .cmp(&highlight.range.end, &snapshot)\n                        .is_gt()\n                    {\n                        row_highlights[ix].range.end = next_highlight.range.end;\n                    }\n                    row_highlights.remove(ix + 1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Remove any highlighted row ranges of the given type that intersect the\n    /// given ranges.\n    pub fn remove_highlighted_rows<T: 'static>(\n        &mut self,\n        ranges_to_remove: Vec<Range<Anchor>>,\n        cx: &mut Context<Self>,\n    ) {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n        let row_highlights = self.highlighted_rows.entry(TypeId::of::<T>()).or_default();\n        let mut ranges_to_remove = ranges_to_remove.iter().peekable();\n        row_highlights.retain(|highlight| {\n            while let Some(range_to_remove) = ranges_to_remove.peek() {\n                match range_to_remove.end.cmp(&highlight.range.start, &snapshot) {\n                    Ordering::Less | Ordering::Equal => {\n                        ranges_to_remove.next();\n                    }\n                    Ordering::Greater => {\n                        match range_to_remove.start.cmp(&highlight.range.end, &snapshot) {\n                            Ordering::Less | Ordering::Equal => {\n                                return false;\n                            }\n                            Ordering::Greater => break,\n                        }\n                    }\n                }\n            }\n\n            true\n        })\n    }\n\n    /// Clear all anchor ranges for a certain highlight context type, so no corresponding rows will be highlighted.\n    pub fn clear_row_highlights<T: 'static>(&mut self) {\n        self.highlighted_rows.remove(&TypeId::of::<T>());\n    }\n\n    /// For a highlight given context type, gets all anchor ranges that will be used for row highlighting.\n    pub fn highlighted_rows<T: 'static>(&self) -> impl '_ + Iterator<Item = (Range<Anchor>, Hsla)> {\n        self.highlighted_rows\n            .get(&TypeId::of::<T>())\n            .map_or(&[] as &[_], |vec| vec.as_slice())\n            .iter()\n            .map(|highlight| (highlight.range.clone(), highlight.color))\n    }\n\n    /// Merges all anchor ranges for all context types ever set, picking the last highlight added in case of a row conflict.\n    /// Returns a map of display rows that are highlighted and their corresponding highlight color.\n    /// Allows to ignore certain kinds of highlights.\n    pub fn highlighted_display_rows(\n        &self,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> BTreeMap<DisplayRow, Background> {\n        let snapshot = self.snapshot(window, cx);\n        let mut used_highlight_orders = HashMap::default();\n        self.highlighted_rows\n            .iter()\n            .flat_map(|(_, highlighted_rows)| highlighted_rows.iter())\n            .fold(\n                BTreeMap::<DisplayRow, Background>::new(),\n                |mut unique_rows, highlight| {\n                    let start = highlight.range.start.to_display_point(&snapshot);\n                    let end = highlight.range.end.to_display_point(&snapshot);\n                    let start_row = start.row().0;\n                    let end_row = if highlight.range.end.text_anchor != text::Anchor::MAX\n                        && end.column() == 0\n                    {\n                        end.row().0.saturating_sub(1)\n                    } else {\n                        end.row().0\n                    };\n                    for row in start_row..=end_row {\n                        let used_index =\n                            used_highlight_orders.entry(row).or_insert(highlight.index);\n                        if highlight.index >= *used_index {\n                            *used_index = highlight.index;\n                            unique_rows.insert(DisplayRow(row), highlight.color.into());\n                        }\n                    }\n                    unique_rows\n                },\n            )\n    }\n\n    pub fn highlighted_display_row_for_autoscroll(\n        &self,\n        snapshot: &DisplaySnapshot,\n    ) -> Option<DisplayRow> {\n        self.highlighted_rows\n            .values()\n            .flat_map(|highlighted_rows| highlighted_rows.iter())\n            .filter_map(|highlight| {\n                if highlight.should_autoscroll {\n                    Some(highlight.range.start.to_display_point(snapshot).row())\n                } else {\n                    None\n                }\n            })\n            .min()\n    }\n\n    pub fn set_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n        self.highlight_background::<SearchWithinRange>(\n            ranges,\n            |colors| colors.editor_document_highlight_read_background,\n            cx,\n        )\n    }\n\n    pub fn set_breadcrumb_header(&mut self, new_header: String) {\n        self.breadcrumb_header = Some(new_header);\n    }\n\n    pub fn clear_search_within_ranges(&mut self, cx: &mut Context<Self>) {\n        self.clear_background_highlights::<SearchWithinRange>(cx);\n    }\n\n    pub fn highlight_background<T: 'static>(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        color_fetcher: fn(&ThemeColors) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.background_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, Arc::from(ranges)));\n        self.scrollbar_marker_state.dirty = true;\n        cx.notify();\n    }\n\n    pub fn clear_background_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<BackgroundHighlight> {\n        let text_highlights = self.background_highlights.remove(&TypeId::of::<T>())?;\n        if !text_highlights.1.is_empty() {\n            self.scrollbar_marker_state.dirty = true;\n            cx.notify();\n        }\n        Some(text_highlights)\n    }\n\n    pub fn highlight_gutter<T: 'static>(\n        &mut self,\n        ranges: &[Range<Anchor>],\n        color_fetcher: fn(&App) -> Hsla,\n        cx: &mut Context<Self>,\n    ) {\n        self.gutter_highlights\n            .insert(TypeId::of::<T>(), (color_fetcher, Arc::from(ranges)));\n        cx.notify();\n    }\n\n    pub fn clear_gutter_highlights<T: 'static>(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> Option<GutterHighlight> {\n        cx.notify();\n        self.gutter_highlights.remove(&TypeId::of::<T>())\n    }\n\n    #[cfg(feature = \"test-support\")]\n    pub fn all_text_background_highlights(\n        &self,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let snapshot = self.snapshot(window, cx);\n        let buffer = &snapshot.buffer_snapshot;\n        let start = buffer.anchor_before(0);\n        let end = buffer.anchor_after(buffer.len());\n        let theme = cx.theme().colors();\n        self.background_highlights_in_range(start..end, &snapshot, theme)\n    }\n\n    #[cfg(feature = \"test-support\")]\n    pub fn search_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n        let snapshot = self.buffer().read(cx).snapshot(cx);\n\n        let highlights = self\n            .background_highlights\n            .get(&TypeId::of::<items::BufferSearchHighlights>());\n\n        if let Some((_color, ranges)) = highlights {\n            ranges\n                .iter()\n                .map(|range| range.start.to_point(&snapshot)..range.end.to_point(&snapshot))\n                .collect_vec()\n        } else {\n            vec![]\n        }\n    }\n\n    fn document_highlights_for_position<'a>(\n        &'a self,\n        position: Anchor,\n        buffer: &'a MultiBufferSnapshot,\n    ) -> impl 'a + Iterator<Item = &'a Range<Anchor>> {\n        let read_highlights = self\n            .background_highlights\n            .get(&TypeId::of::<DocumentHighlightRead>())\n            .map(|h| &h.1);\n        let write_highlights = self\n            .background_highlights\n            .get(&TypeId::of::<DocumentHighlightWrite>())\n            .map(|h| &h.1);\n        let left_position = position.bias_left(buffer);\n        let right_position = position.bias_right(buffer);\n        read_highlights\n            .into_iter()\n            .chain(write_highlights)\n            .flat_map(move |ranges| {\n                let start_ix = match ranges.binary_search_by(|probe| {\n                    let cmp = probe.end.cmp(&left_position, buffer);\n                    if cmp.is_ge() {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Less\n                    }\n                }) {\n                    Ok(i) | Err(i) => i,\n                };\n\n                ranges[start_ix..]\n                    .iter()\n                    .take_while(move |range| range.start.cmp(&right_position, buffer).is_le())\n            })\n    }\n\n    pub fn has_background_highlights<T: 'static>(&self) -> bool {\n        self.background_highlights\n            .get(&TypeId::of::<T>())\n            .map_or(false, |(_, highlights)| !highlights.is_empty())\n    }\n\n    pub fn background_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        theme: &ThemeColors,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.background_highlights.values() {\n            let color = color_fetcher(theme);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    pub fn background_highlight_row_ranges<T: 'static>(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        count: usize,\n    ) -> Vec<RangeInclusive<DisplayPoint>> {\n        let mut results = Vec::new();\n        let Some((_, ranges)) = self.background_highlights.get(&TypeId::of::<T>()) else {\n            return vec![];\n        };\n\n        let start_ix = match ranges.binary_search_by(|probe| {\n            let cmp = probe\n                .end\n                .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n            if cmp.is_gt() {\n                Ordering::Greater\n            } else {\n                Ordering::Less\n            }\n        }) {\n            Ok(i) | Err(i) => i,\n        };\n        let mut push_region = |start: Option<Point>, end: Option<Point>| {\n            if let (Some(start_display), Some(end_display)) = (start, end) {\n                results.push(\n                    start_display.to_display_point(display_snapshot)\n                        ..=end_display.to_display_point(display_snapshot),\n                );\n            }\n        };\n        let mut start_row: Option<Point> = None;\n        let mut end_row: Option<Point> = None;\n        if ranges.len() > count {\n            return Vec::new();\n        }\n        for range in &ranges[start_ix..] {\n            if range\n                .start\n                .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                .is_ge()\n            {\n                break;\n            }\n            let end = range.end.to_point(&display_snapshot.buffer_snapshot);\n            if let Some(current_row) = &end_row {\n                if end.row == current_row.row {\n                    continue;\n                }\n            }\n            let start = range.start.to_point(&display_snapshot.buffer_snapshot);\n            if start_row.is_none() {\n                assert_eq!(end_row, None);\n                start_row = Some(start);\n                end_row = Some(end);\n                continue;\n            }\n            if let Some(current_end) = end_row.as_mut() {\n                if start.row > current_end.row + 1 {\n                    push_region(start_row, end_row);\n                    start_row = Some(start);\n                    end_row = Some(end);\n                } else {\n                    // Merge two hunks.\n                    *current_end = end;\n                }\n            } else {\n                unreachable!();\n            }\n        }\n        // We might still have a hunk that was not rendered (if there was a search hit on the last line)\n        push_region(start_row, end_row);\n        results\n    }\n\n    pub fn gutter_highlights_in_range(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<(Range<DisplayPoint>, Hsla)> {\n        let mut results = Vec::new();\n        for (color_fetcher, ranges) in self.gutter_highlights.values() {\n            let color = color_fetcher(cx);\n            let start_ix = match ranges.binary_search_by(|probe| {\n                let cmp = probe\n                    .end\n                    .cmp(&search_range.start, &display_snapshot.buffer_snapshot);\n                if cmp.is_gt() {\n                    Ordering::Greater\n                } else {\n                    Ordering::Less\n                }\n            }) {\n                Ok(i) | Err(i) => i,\n            };\n            for range in &ranges[start_ix..] {\n                if range\n                    .start\n                    .cmp(&search_range.end, &display_snapshot.buffer_snapshot)\n                    .is_ge()\n                {\n                    break;\n                }\n\n                let start = range.start.to_display_point(display_snapshot);\n                let end = range.end.to_display_point(display_snapshot);\n                results.push((start..end, color))\n            }\n        }\n        results\n    }\n\n    /// Get the text ranges corresponding to the redaction query\n    pub fn redacted_ranges(\n        &self,\n        search_range: Range<Anchor>,\n        display_snapshot: &DisplaySnapshot,\n        cx: &App,\n    ) -> Vec<Range<DisplayPoint>> {\n        display_snapshot\n            .buffer_snapshot\n            .redacted_ranges(search_range, |file| {\n                if let Some(file) = file {\n                    file.is_private()\n                        && EditorSettings::get(\n                            Some(SettingsLocation {\n                                worktree_id: file.worktree_id(cx),\n                                path: file.path().as_ref(),\n                            }),\n                            cx,\n                        )\n                        .redact_private_values\n                } else {\n                    false\n                }\n            })\n            .map(|range| {\n                range.start.to_display_point(display_snapshot)\n                    ..range.end.to_display_point(display_snapshot)\n            })\n            .collect()\n    }\n\n    pub fn highlight_text<T: 'static>(\n        &mut self,\n        ranges: Vec<Range<Anchor>>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_text(TypeId::of::<T>(), ranges, style)\n        });\n        cx.notify();\n    }\n\n    pub(crate) fn highlight_inlays<T: 'static>(\n        &mut self,\n        highlights: Vec<InlayHighlight>,\n        style: HighlightStyle,\n        cx: &mut Context<Self>,\n    ) {\n        self.display_map.update(cx, |map, _| {\n            map.highlight_inlays(TypeId::of::<T>(), highlights, style)\n        });\n        cx.notify();\n    }\n\n    pub fn text_highlights<'a, T: 'static>(\n        &'a self,\n        cx: &'a App,\n    ) -> Option<(HighlightStyle, &'a [Range<Anchor>])> {\n        self.display_map.read(cx).text_highlights(TypeId::of::<T>())\n    }\n\n    pub fn clear_highlights<T: 'static>(&mut self, cx: &mut Context<Self>) {\n        let cleared = self\n            .display_map\n            .update(cx, |map, _| map.clear_highlights(TypeId::of::<T>()));\n        if cleared {\n            cx.notify();\n        }\n    }\n\n    pub fn show_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n        (self.read_only(cx) || self.blink_manager.read(cx).visible())\n            && self.focus_handle.is_focused(window)\n    }\n\n    pub fn set_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n        self.show_cursor_when_unfocused = is_enabled;\n        cx.notify();\n    }\n\n    pub fn lsp_store(&self, cx: &App) -> Option<Entity<LspStore>> {\n        self.project\n            .as_ref()\n            .map(|project| project.read(cx).lsp_store())\n    }\n\n    fn on_buffer_changed(&mut self, _: Entity<MultiBuffer>, cx: &mut Context<Self>) {\n        cx.notify();\n    }\n\n    fn on_buffer_event(\n        &mut self,\n        multibuffer: &Entity<MultiBuffer>,\n        event: &multi_buffer::Event,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            multi_buffer::Event::Edited {\n                singleton_buffer_edited,\n                edited_buffer: buffer_edited,\n            } => {\n                self.scrollbar_marker_state.dirty = true;\n                self.active_indent_guides_state.dirty = true;\n                self.refresh_active_diagnostics(cx);\n                self.refresh_code_actions(window, cx);\n                if self.has_active_inline_completion() {\n                    self.update_visible_inline_completion(window, cx);\n                }\n                if let Some(buffer) = buffer_edited {\n                    let buffer_id = buffer.read(cx).remote_id();\n                    if !self.registered_buffers.contains_key(&buffer_id) {\n                        if let Some(lsp_store) = self.lsp_store(cx) {\n                            lsp_store.update(cx, |lsp_store, cx| {\n                                self.registered_buffers.insert(\n                                    buffer_id,\n                                    lsp_store.register_buffer_with_language_servers(&buffer, cx),\n                                );\n                            })\n                        }\n                    }\n                }\n                cx.emit(EditorEvent::BufferEdited);\n                cx.emit(SearchEvent::MatchesInvalidated);\n                if *singleton_buffer_edited {\n                    if let Some(project) = &self.project {\n                        let project = project.read(cx);\n                        #[allow(clippy::mutable_key_type)]\n                        let languages_affected = multibuffer\n                            .read(cx)\n                            .all_buffers()\n                            .into_iter()\n                            .filter_map(|buffer| {\n                                let buffer = buffer.read(cx);\n                                let language = buffer.language()?;\n                                if project.is_local()\n                                    && project\n                                        .language_servers_for_local_buffer(buffer, cx)\n                                        .count()\n                                        == 0\n                                {\n                                    None\n                                } else {\n                                    Some(language)\n                                }\n                            })\n                            .cloned()\n                            .collect::<HashSet<_>>();\n                        if !languages_affected.is_empty() {\n                            self.refresh_inlay_hints(\n                                InlayHintRefreshReason::BufferEdited(languages_affected),\n                                cx,\n                            );\n                        }\n                    }\n                }\n\n                let Some(project) = &self.project else { return };\n                let (telemetry, is_via_ssh) = {\n                    let project = project.read(cx);\n                    let telemetry = project.client().telemetry().clone();\n                    let is_via_ssh = project.is_via_ssh();\n                    (telemetry, is_via_ssh)\n                };\n                refresh_linked_ranges(self, window, cx);\n                telemetry.log_edit_event(\"editor\", is_via_ssh);\n            }\n            multi_buffer::Event::ExcerptsAdded {\n                buffer,\n                predecessor,\n                excerpts,\n            } => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n                let buffer_id = buffer.read(cx).remote_id();\n                if self.buffer.read(cx).diff_for(buffer_id).is_none() {\n                    if let Some(project) = &self.project {\n                        get_uncommitted_diff_for_buffer(\n                            project,\n                            [buffer.clone()],\n                            self.buffer.clone(),\n                            cx,\n                        );\n                    }\n                }\n                cx.emit(EditorEvent::ExcerptsAdded {\n                    buffer: buffer.clone(),\n                    predecessor: *predecessor,\n                    excerpts: excerpts.clone(),\n                });\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n            }\n            multi_buffer::Event::ExcerptsRemoved { ids } => {\n                self.refresh_inlay_hints(InlayHintRefreshReason::ExcerptsRemoved(ids.clone()), cx);\n                let buffer = self.buffer.read(cx);\n                self.registered_buffers\n                    .retain(|buffer_id, _| buffer.buffer(*buffer_id).is_some());\n                cx.emit(EditorEvent::ExcerptsRemoved { ids: ids.clone() })\n            }\n            multi_buffer::Event::ExcerptsEdited { ids } => {\n                cx.emit(EditorEvent::ExcerptsEdited { ids: ids.clone() })\n            }\n            multi_buffer::Event::ExcerptsExpanded { ids } => {\n                self.refresh_inlay_hints(InlayHintRefreshReason::NewLinesShown, cx);\n                cx.emit(EditorEvent::ExcerptsExpanded { ids: ids.clone() })\n            }\n            multi_buffer::Event::Reparsed(buffer_id) => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n            }\n            multi_buffer::Event::DiffHunksToggled => {\n                self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n            }\n            multi_buffer::Event::LanguageChanged(buffer_id) => {\n                linked_editing_ranges::refresh_linked_ranges(self, window, cx);\n                cx.emit(EditorEvent::Reparsed(*buffer_id));\n                cx.notify();\n            }\n            multi_buffer::Event::DirtyChanged => cx.emit(EditorEvent::DirtyChanged),\n            multi_buffer::Event::Saved => cx.emit(EditorEvent::Saved),\n            multi_buffer::Event::FileHandleChanged | multi_buffer::Event::Reloaded => {\n                cx.emit(EditorEvent::TitleChanged)\n            }\n            // multi_buffer::Event::DiffBaseChanged => {\n            //     self.scrollbar_marker_state.dirty = true;\n            //     cx.emit(EditorEvent::DiffBaseChanged);\n            //     cx.notify();\n            // }\n            multi_buffer::Event::Closed => cx.emit(EditorEvent::Closed),\n            multi_buffer::Event::DiagnosticsUpdated => {\n                self.refresh_active_diagnostics(cx);\n                self.scrollbar_marker_state.dirty = true;\n                cx.notify();\n            }\n            _ => {}\n        };\n    }\n\n    fn on_display_map_changed(\n        &mut self,\n        _: Entity<DisplayMap>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        cx.notify();\n    }\n\n    fn settings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n        self.refresh_inline_completion(true, false, window, cx);\n        self.refresh_inlay_hints(\n            InlayHintRefreshReason::SettingsChange(inlay_hint_settings(\n                self.selections.newest_anchor().head(),\n                &self.buffer.read(cx).snapshot(cx),\n                cx,\n            )),\n            cx,\n        );\n\n        let old_cursor_shape = self.cursor_shape;\n\n        {\n            let editor_settings = EditorSettings::get_global(cx);\n            self.scroll_manager.vertical_scroll_margin = editor_settings.vertical_scroll_margin;\n            self.show_breadcrumbs = editor_settings.toolbar.breadcrumbs;\n            self.cursor_shape = editor_settings.cursor_shape.unwrap_or_default();\n        }\n\n        if old_cursor_shape != self.cursor_shape {\n            cx.emit(EditorEvent::CursorShapeChanged);\n        }\n\n        let project_settings = ProjectSettings::get_global(cx);\n        self.serialize_dirty_buffers = project_settings.session.restore_unsaved_buffers;\n\n        if self.mode == EditorMode::Full {\n            let inline_blame_enabled = project_settings.git.inline_blame_enabled();\n            if self.git_blame_inline_enabled != inline_blame_enabled {\n                self.toggle_git_blame_inline_internal(false, window, cx);\n            }\n        }\n\n        cx.notify();\n    }\n\n    pub fn set_searchable(&mut self, searchable: bool) {\n        self.searchable = searchable;\n    }\n\n    pub fn searchable(&self) -> bool {\n        self.searchable\n    }\n\n    fn open_proposed_changes_editor(\n        &mut self,\n        _: &OpenProposedChangesEditor,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            cx.propagate();\n            return;\n        };\n\n        let selections = self.selections.all::<usize>(cx);\n        let multi_buffer = self.buffer.read(cx);\n        let multi_buffer_snapshot = multi_buffer.snapshot(cx);\n        let mut new_selections_by_buffer = HashMap::default();\n        for selection in selections {\n            for (buffer, range, _) in\n                multi_buffer_snapshot.range_to_buffer_ranges(selection.start..selection.end)\n            {\n                let mut range = range.to_point(buffer);\n                range.start.column = 0;\n                range.end.column = buffer.line_len(range.end.row);\n                new_selections_by_buffer\n                    .entry(multi_buffer.buffer(buffer.remote_id()).unwrap())\n                    .or_insert(Vec::new())\n                    .push(range)\n            }\n        }\n\n        let proposed_changes_buffers = new_selections_by_buffer\n            .into_iter()\n            .map(|(buffer, ranges)| ProposedChangeLocation { buffer, ranges })\n            .collect::<Vec<_>>();\n        let proposed_changes_editor = cx.new(|cx| {\n            ProposedChangesEditor::new(\n                \"Proposed changes\",\n                proposed_changes_buffers,\n                self.project.clone(),\n                window,\n                cx,\n            )\n        });\n\n        window.defer(cx, move |window, cx| {\n            workspace.update(cx, |workspace, cx| {\n                workspace.active_pane().update(cx, |pane, cx| {\n                    pane.add_item(\n                        Box::new(proposed_changes_editor),\n                        true,\n                        true,\n                        None,\n                        window,\n                        cx,\n                    );\n                });\n            });\n        });\n    }\n\n    pub fn open_excerpts_in_split(\n        &mut self,\n        _: &OpenExcerptsSplit,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.open_excerpts_common(None, true, window, cx)\n    }\n\n    pub fn open_excerpts(&mut self, _: &OpenExcerpts, window: &mut Window, cx: &mut Context<Self>) {\n        self.open_excerpts_common(None, false, window, cx)\n    }\n\n    fn open_excerpts_common(\n        &mut self,\n        jump_data: Option<JumpData>,\n        split: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Some(workspace) = self.workspace() else {\n            cx.propagate();\n            return;\n        };\n\n        if self.buffer.read(cx).is_singleton() {\n            cx.propagate();\n            return;\n        }\n\n        let mut new_selections_by_buffer = HashMap::default();\n        match &jump_data {\n            Some(JumpData::MultiBufferPoint {\n                excerpt_id,\n                position,\n                anchor,\n                line_offset_from_top,\n            }) => {\n                let multi_buffer_snapshot = self.buffer.read(cx).snapshot(cx);\n                if let Some(buffer) = multi_buffer_snapshot\n                    .buffer_id_for_excerpt(*excerpt_id)\n                    .and_then(|buffer_id| self.buffer.read(cx).buffer(buffer_id))\n                {\n                    let buffer_snapshot = buffer.read(cx).snapshot();\n                    let jump_to_point = if buffer_snapshot.can_resolve(anchor) {\n                        language::ToPoint::to_point(anchor, &buffer_snapshot)\n                    } else {\n                        buffer_snapshot.clip_point(*position, Bias::Left)\n                    };\n                    let jump_to_offset = buffer_snapshot.point_to_offset(jump_to_point);\n                    new_selections_by_buffer.insert(\n                        buffer,\n                        (\n                            vec![jump_to_offset..jump_to_offset],\n                            Some(*line_offset_from_top),\n                        ),\n                    );\n                }\n            }\n            Some(JumpData::MultiBufferRow {\n                row,\n                line_offset_from_top,\n            }) => {\n                let point = MultiBufferPoint::new(row.0, 0);\n                if let Some((buffer, buffer_point, _)) =\n                    self.buffer.read(cx).point_to_buffer_point(point, cx)\n                {\n                    let buffer_offset = buffer.read(cx).point_to_offset(buffer_point);\n                    new_selections_by_buffer\n                        .entry(buffer)\n                        .or_insert((Vec::new(), Some(*line_offset_from_top)))\n                        .0\n                        .push(buffer_offset..buffer_offset)\n                }\n            }\n            None => {\n                let selections = self.selections.all::<usize>(cx);\n                let multi_buffer = self.buffer.read(cx);\n                for selection in selections {\n                    for (buffer, mut range, _) in multi_buffer\n                        .snapshot(cx)\n                        .range_to_buffer_ranges(selection.range())\n                    {\n                        // When editing branch buffers, jump to the corresponding location\n                        // in their base buffer.\n                        let mut buffer_handle = multi_buffer.buffer(buffer.remote_id()).unwrap();\n                        let buffer = buffer_handle.read(cx);\n                        if let Some(base_buffer) = buffer.base_buffer() {\n                            range = buffer.range_to_version(range, &base_buffer.read(cx).version());\n                            buffer_handle = base_buffer;\n                        }\n\n                        if selection.reversed {\n                            mem::swap(&mut range.start, &mut range.end);\n                        }\n                        new_selections_by_buffer\n                            .entry(buffer_handle)\n                            .or_insert((Vec::new(), None))\n                            .0\n                            .push(range)\n                    }\n                }\n            }\n        }\n\n        if new_selections_by_buffer.is_empty() {\n            return;\n        }\n\n        // We defer the pane interaction because we ourselves are a workspace item\n        // and activating a new item causes the pane to call a method on us reentrantly,\n        // which panics if we're on the stack.\n        window.defer(cx, move |window, cx| {\n            workspace.update(cx, |workspace, cx| {\n                let pane = if split {\n                    workspace.adjacent_pane(window, cx)\n                } else {\n                    workspace.active_pane().clone()\n                };\n\n                for (buffer, (ranges, scroll_offset)) in new_selections_by_buffer {\n                    let editor = buffer\n                        .read(cx)\n                        .file()\n                        .is_none()\n                        .then(|| {\n                            // Handle file-less buffers separately: those are not really the project items, so won't have a project path or entity id,\n                            // so `workspace.open_project_item` will never find them, always opening a new editor.\n                            // Instead, we try to activate the existing editor in the pane first.\n                            let (editor, pane_item_index) =\n                                pane.read(cx).items().enumerate().find_map(|(i, item)| {\n                                    let editor = item.downcast::<Editor>()?;\n                                    let singleton_buffer =\n                                        editor.read(cx).buffer().read(cx).as_singleton()?;\n                                    if singleton_buffer == buffer {\n                                        Some((editor, i))\n                                    } else {\n                                        None\n                                    }\n                                })?;\n                            pane.update(cx, |pane, cx| {\n                                pane.activate_item(pane_item_index, true, true, window, cx)\n                            });\n                            Some(editor)\n                        })\n                        .flatten()\n                        .unwrap_or_else(|| {\n                            workspace.open_project_item::<Self>(\n                                pane.clone(),\n                                buffer,\n                                true,\n                                true,\n                                window,\n                                cx,\n                            )\n                        });\n\n                    editor.update(cx, |editor, cx| {\n                        let autoscroll = match scroll_offset {\n                            Some(scroll_offset) => Autoscroll::top_relative(scroll_offset as usize),\n                            None => Autoscroll::newest(),\n                        };\n                        let nav_history = editor.nav_history.take();\n                        editor.change_selections(Some(autoscroll), window, cx, |s| {\n                            s.select_ranges(ranges);\n                        });\n                        editor.nav_history = nav_history;\n                    });\n                }\n            })\n        });\n    }\n\n    fn marked_text_ranges(&self, cx: &App) -> Option<Vec<Range<OffsetUtf16>>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let (_, ranges) = self.text_highlights::<InputComposition>(cx)?;\n        Some(\n            ranges\n                .iter()\n                .map(move |range| {\n                    range.start.to_offset_utf16(&snapshot)..range.end.to_offset_utf16(&snapshot)\n                })\n                .collect(),\n        )\n    }\n\n    fn selection_replacement_ranges(\n        &self,\n        range: Range<OffsetUtf16>,\n        cx: &mut App,\n    ) -> Vec<Range<OffsetUtf16>> {\n        let selections = self.selections.all::<OffsetUtf16>(cx);\n        let newest_selection = selections\n            .iter()\n            .max_by_key(|selection| selection.id)\n            .unwrap();\n        let start_delta = range.start.0 as isize - newest_selection.start.0 as isize;\n        let end_delta = range.end.0 as isize - newest_selection.end.0 as isize;\n        let snapshot = self.buffer.read(cx).read(cx);\n        selections\n            .into_iter()\n            .map(|mut selection| {\n                selection.start.0 =\n                    (selection.start.0 as isize).saturating_add(start_delta) as usize;\n                selection.end.0 = (selection.end.0 as isize).saturating_add(end_delta) as usize;\n                snapshot.clip_offset_utf16(selection.start, Bias::Left)\n                    ..snapshot.clip_offset_utf16(selection.end, Bias::Right)\n            })\n            .collect()\n    }\n\n    fn report_editor_event(\n        &self,\n        event_type: &'static str,\n        file_extension: Option<String>,\n        cx: &App,\n    ) {\n        if cfg!(any(test, feature = \"test-support\")) {\n            return;\n        }\n\n        let Some(project) = &self.project else { return };\n\n        // If None, we are in a file without an extension\n        let file = self\n            .buffer\n            .read(cx)\n            .as_singleton()\n            .and_then(|b| b.read(cx).file());\n        let file_extension = file_extension.or(file\n            .as_ref()\n            .and_then(|file| Path::new(file.file_name(cx)).extension())\n            .and_then(|e| e.to_str())\n            .map(|a| a.to_string()));\n\n        let vim_mode = cx\n            .global::<SettingsStore>()\n            .raw_user_settings()\n            .get(\"vim_mode\")\n            == Some(&serde_json::Value::Bool(true));\n\n        let edit_predictions_provider = all_language_settings(file, cx).edit_predictions.provider;\n        let copilot_enabled = edit_predictions_provider\n            == language::language_settings::EditPredictionProvider::Copilot;\n        let copilot_enabled_for_language = self\n            .buffer\n            .read(cx)\n            .settings_at(0, cx)\n            .show_edit_predictions;\n\n        let project = project.read(cx);\n        telemetry::event!(\n            event_type,\n            file_extension,\n            vim_mode,\n            copilot_enabled,\n            copilot_enabled_for_language,\n            edit_predictions_provider,\n            is_via_ssh = project.is_via_ssh(),\n        );\n    }\n\n    /// Copy the highlighted chunks to the clipboard as JSON. The format is an array of lines,\n    /// with each line being an array of {text, highlight} objects.\n    fn copy_highlight_json(\n        &mut self,\n        _: &CopyHighlightJson,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        #[derive(Serialize)]\n        struct Chunk<'a> {\n            text: String,\n            highlight: Option<&'a str>,\n        }\n\n        let snapshot = self.buffer.read(cx).snapshot(cx);\n        let range = self\n            .selected_text_range(false, window, cx)\n            .and_then(|selection| {\n                if selection.range.is_empty() {\n                    None\n                } else {\n                    Some(selection.range)\n                }\n            })\n            .unwrap_or_else(|| 0..snapshot.len());\n\n        let chunks = snapshot.chunks(range, true);\n        let mut lines = Vec::new();\n        let mut line: VecDeque<Chunk> = VecDeque::new();\n\n        let Some(style) = self.style.as_ref() else {\n            return;\n        };\n\n        for chunk in chunks {\n            let highlight = chunk\n                .syntax_highlight_id\n                .and_then(|id| id.name(&style.syntax));\n            let mut chunk_lines = chunk.text.split('\\n').peekable();\n            while let Some(text) = chunk_lines.next() {\n                let mut merged_with_last_token = false;\n                if let Some(last_token) = line.back_mut() {\n                    if last_token.highlight == highlight {\n                        last_token.text.push_str(text);\n                        merged_with_last_token = true;\n                    }\n                }\n\n                if !merged_with_last_token {\n                    line.push_back(Chunk {\n                        text: text.into(),\n                        highlight,\n                    });\n                }\n\n                if chunk_lines.peek().is_some() {\n                    if line.len() > 1 && line.front().unwrap().text.is_empty() {\n                        line.pop_front();\n                    }\n                    if line.len() > 1 && line.back().unwrap().text.is_empty() {\n                        line.pop_back();\n                    }\n\n                    lines.push(mem::take(&mut line));\n                }\n            }\n        }\n\n        let Some(lines) = serde_json::to_string_pretty(&lines).log_err() else {\n            return;\n        };\n        cx.write_to_clipboard(ClipboardItem::new_string(lines));\n    }\n\n    pub fn open_context_menu(\n        &mut self,\n        _: &OpenContextMenu,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.request_autoscroll(Autoscroll::newest(), cx);\n        let position = self.selections.newest_display(cx).start;\n        mouse_context_menu::deploy_context_menu(self, None, position, window, cx);\n    }\n\n    pub fn inlay_hint_cache(&self) -> &InlayHintCache {\n        &self.inlay_hint_cache\n    }\n\n    pub fn replay_insert_event(\n        &mut self,\n        text: &str,\n        relative_utf16_range: Option<Range<isize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n        if let Some(relative_utf16_range) = relative_utf16_range {\n            let selections = self.selections.all::<OffsetUtf16>(cx);\n            self.change_selections(None, window, cx, |s| {\n                let new_ranges = selections.into_iter().map(|range| {\n                    let start = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.start),\n                    );\n                    let end = OffsetUtf16(\n                        range\n                            .head()\n                            .0\n                            .saturating_add_signed(relative_utf16_range.end),\n                    );\n                    start..end\n                });\n                s.select_ranges(new_ranges);\n            });\n        }\n\n        self.handle_input(text, window, cx);\n    }\n\n    pub fn supports_inlay_hints(&self, cx: &App) -> bool {\n        let Some(provider) = self.semantics_provider.as_ref() else {\n            return false;\n        };\n\n        let mut supports = false;\n        self.buffer().read(cx).for_each_buffer(|buffer| {\n            supports |= provider.supports_inlay_hints(buffer, cx);\n        });\n        supports\n    }\n\n    pub fn is_focused(&self, window: &Window) -> bool {\n        self.focus_handle.is_focused(window)\n    }\n\n    fn handle_focus(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::Focused);\n\n        if let Some(descendant) = self\n            .last_focused_descendant\n            .take()\n            .and_then(|descendant| descendant.upgrade())\n        {\n            window.focus(&descendant);\n        } else {\n            if let Some(blame) = self.blame.as_ref() {\n                blame.update(cx, GitBlame::focus)\n            }\n\n            self.blink_manager.update(cx, BlinkManager::enable);\n            self.show_cursor_names(window, cx);\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.finalize_last_transaction(cx);\n                if self.leader_peer_id.is_none() {\n                    buffer.set_active_selections(\n                        &self.selections.disjoint_anchors(),\n                        self.selections.line_mode,\n                        self.cursor_shape,\n                        cx,\n                    );\n                }\n            });\n        }\n    }\n\n    fn handle_focus_in(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        cx.emit(EditorEvent::FocusedIn)\n    }\n\n    fn handle_focus_out(\n        &mut self,\n        event: FocusOutEvent,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) {\n        if event.blurred != self.focus_handle {\n            self.last_focused_descendant = Some(event.blurred);\n        }\n    }\n\n    pub fn handle_blur(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        self.blink_manager.update(cx, BlinkManager::disable);\n        self.buffer\n            .update(cx, |buffer, cx| buffer.remove_active_selections(cx));\n\n        if let Some(blame) = self.blame.as_ref() {\n            blame.update(cx, GitBlame::blur)\n        }\n        if !self.hover_state.focused(window, cx) {\n            hide_hover(self, cx);\n        }\n\n        self.hide_context_menu(window, cx);\n        cx.emit(EditorEvent::Blurred);\n        cx.notify();\n    }\n\n    pub fn register_action<A: Action>(\n        &mut self,\n        listener: impl Fn(&A, &mut Window, &mut App) + 'static,\n    ) -> Subscription {\n        let id = self.next_editor_action_id.post_inc();\n        let listener = Arc::new(listener);\n        self.editor_actions.borrow_mut().insert(\n            id,\n            Box::new(move |window, _| {\n                let listener = listener.clone();\n                window.on_action(TypeId::of::<A>(), move |action, phase, window, cx| {\n                    let action = action.downcast_ref().unwrap();\n                    if phase == DispatchPhase::Bubble {\n                        listener(action, window, cx)\n                    }\n                })\n            }),\n        );\n\n        let editor_actions = self.editor_actions.clone();\n        Subscription::new(move || {\n            editor_actions.borrow_mut().remove(&id);\n        })\n    }\n\n    pub fn file_header_size(&self) -> u32 {\n        FILE_HEADER_HEIGHT\n    }\n\n    pub fn revert(\n        &mut self,\n        revert_changes: HashMap<BufferId, Vec<(Range<text::Anchor>, Rope)>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffer().update(cx, |multi_buffer, cx| {\n            for (buffer_id, changes) in revert_changes {\n                if let Some(buffer) = multi_buffer.buffer(buffer_id) {\n                    buffer.update(cx, |buffer, cx| {\n                        buffer.edit(\n                            changes.into_iter().map(|(range, text)| {\n                                (range, text.to_string().map(Arc::<str>::from))\n                            }),\n                            None,\n                            cx,\n                        );\n                    });\n                }\n            }\n        });\n        self.change_selections(None, window, cx, |selections| selections.refresh());\n    }\n\n    pub fn to_pixel_point(\n        &self,\n        source: multi_buffer::Anchor,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let source_point = source.to_display_point(editor_snapshot);\n        self.display_to_pixel_point(source_point, editor_snapshot, window)\n    }\n\n    pub fn display_to_pixel_point(\n        &self,\n        source: DisplayPoint,\n        editor_snapshot: &EditorSnapshot,\n        window: &mut Window,\n    ) -> Option<gpui::Point<Pixels>> {\n        let line_height = self.style()?.text.line_height_in_pixels(window.rem_size());\n        let text_layout_details = self.text_layout_details(window);\n        let scroll_top = text_layout_details\n            .scroll_anchor\n            .scroll_position(editor_snapshot)\n            .y;\n\n        if source.row().as_f32() < scroll_top.floor() {\n            return None;\n        }\n        let source_x = editor_snapshot.x_for_display_point(source, &text_layout_details);\n        let source_y = line_height * (source.row().as_f32() - scroll_top);\n        Some(gpui::Point::new(source_x, source_y))\n    }\n\n    pub fn has_visible_completions_menu(&self) -> bool {\n        !self.edit_prediction_preview_is_active()\n            && self.context_menu.borrow().as_ref().map_or(false, |menu| {\n                menu.visible() && matches!(menu, CodeContextMenu::Completions(_))\n            })\n    }\n\n    pub fn register_addon<T: Addon>(&mut self, instance: T) {\n        self.addons\n            .insert(std::any::TypeId::of::<T>(), Box::new(instance));\n    }\n\n    pub fn unregister_addon<T: Addon>(&mut self) {\n        self.addons.remove(&std::any::TypeId::of::<T>());\n    }\n\n    pub fn addon<T: Addon>(&self) -> Option<&T> {\n        let type_id = std::any::TypeId::of::<T>();\n        self.addons\n            .get(&type_id)\n            .and_then(|item| item.to_any().downcast_ref::<T>())\n    }\n\n    fn character_size(&self, window: &mut Window) -> gpui::Size<Pixels> {\n        let text_layout_details = self.text_layout_details(window);\n        let style = &text_layout_details.editor_style;\n        let font_id = window.text_system().resolve_font(&style.text.font());\n        let font_size = style.text.font_size.to_pixels(window.rem_size());\n        let line_height = style.text.line_height_in_pixels(window.rem_size());\n        let em_width = window.text_system().em_width(font_id, font_size).unwrap();\n\n        gpui::Size::new(em_width, line_height)\n    }\n}\n\nfn get_uncommitted_diff_for_buffer(\n    project: &Entity<Project>,\n    buffers: impl IntoIterator<Item = Entity<Buffer>>,\n    buffer: Entity<MultiBuffer>,\n    cx: &mut App,\n) {\n    let mut tasks = Vec::new();\n    project.update(cx, |project, cx| {\n        for buffer in buffers {\n            tasks.push(project.open_uncommitted_diff(buffer.clone(), cx))\n        }\n    });\n    cx.spawn(|mut cx| async move {\n        let diffs = futures::future::join_all(tasks).await;\n        buffer\n            .update(&mut cx, |buffer, cx| {\n                for diff in diffs.into_iter().flatten() {\n                    buffer.add_diff(diff, cx);\n                }\n            })\n            .ok();\n    })\n    .detach();\n}\n\nfn char_len_with_expanded_tabs(offset: usize, text: &str, tab_size: NonZeroU32) -> usize {\n    let tab_size = tab_size.get() as usize;\n    let mut width = offset;\n\n    for ch in text.chars() {\n        width += if ch == '\\t' {\n            tab_size - (width % tab_size)\n        } else {\n            1\n        };\n    }\n\n    width - offset\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_string_size_with_expanded_tabs() {\n        let nz = |val| NonZeroU32::new(val).unwrap();\n        assert_eq!(char_len_with_expanded_tabs(0, \"\", nz(4)), 0);\n        assert_eq!(char_len_with_expanded_tabs(0, \"hello\", nz(4)), 5);\n        assert_eq!(char_len_with_expanded_tabs(0, \"\\thello\", nz(4)), 9);\n        assert_eq!(char_len_with_expanded_tabs(0, \"abc\\tab\", nz(4)), 6);\n        assert_eq!(char_len_with_expanded_tabs(0, \"hello\\t\", nz(4)), 8);\n        assert_eq!(char_len_with_expanded_tabs(0, \"\\t\\t\", nz(8)), 16);\n        assert_eq!(char_len_with_expanded_tabs(0, \"x\\t\", nz(8)), 8);\n        assert_eq!(char_len_with_expanded_tabs(7, \"x\\t\", nz(8)), 9);\n    }\n}\n\n/// Tokenizes a string into runs of text that should stick together, or that is whitespace.\nstruct WordBreakingTokenizer<'a> {\n    input: &'a str,\n}\n\nimpl<'a> WordBreakingTokenizer<'a> {\n    fn new(input: &'a str) -> Self {\n        Self { input }\n    }\n}\n\nfn is_char_ideographic(ch: char) -> bool {\n    use unicode_script::Script::*;\n    use unicode_script::UnicodeScript;\n    matches!(ch.script(), Han | Tangut | Yi)\n}\n\nfn is_grapheme_ideographic(text: &str) -> bool {\n    text.chars().any(is_char_ideographic)\n}\n\nfn is_grapheme_whitespace(text: &str) -> bool {\n    text.chars().any(|x| x.is_whitespace())\n}\n\nfn should_stay_with_preceding_ideograph(text: &str) -> bool {\n    text.chars().next().map_or(false, |ch| {\n        matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…')\n    })\n}\n\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\nstruct WordBreakToken<'a> {\n    token: &'a str,\n    grapheme_len: usize,\n    is_whitespace: bool,\n}\n\nimpl<'a> Iterator for WordBreakingTokenizer<'a> {\n    /// Yields a span, the count of graphemes in the token, and whether it was\n    /// whitespace. Note that it also breaks at word boundaries.\n    type Item = WordBreakToken<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use unicode_segmentation::UnicodeSegmentation;\n        if self.input.is_empty() {\n            return None;\n        }\n\n        let mut iter = self.input.graphemes(true).peekable();\n        let mut offset = 0;\n        let mut graphemes = 0;\n        if let Some(first_grapheme) = iter.next() {\n            let is_whitespace = is_grapheme_whitespace(first_grapheme);\n            offset += first_grapheme.len();\n            graphemes += 1;\n            if is_grapheme_ideographic(first_grapheme) && !is_whitespace {\n                if let Some(grapheme) = iter.peek().copied() {\n                    if should_stay_with_preceding_ideograph(grapheme) {\n                        offset += grapheme.len();\n                        graphemes += 1;\n                    }\n                }\n            } else {\n                let mut words = self.input[offset..].split_word_bound_indices().peekable();\n                let mut next_word_bound = words.peek().copied();\n                if next_word_bound.map_or(false, |(i, _)| i == 0) {\n                    next_word_bound = words.next();\n                }\n                while let Some(grapheme) = iter.peek().copied() {\n                    if next_word_bound.map_or(false, |(i, _)| i == offset) {\n                        break;\n                    };\n                    if is_grapheme_whitespace(grapheme) != is_whitespace {\n                        break;\n                    };\n                    offset += grapheme.len();\n                    graphemes += 1;\n                    iter.next();\n                }\n            }\n            let token = &self.input[..offset];\n            self.input = &self.input[offset..];\n            if is_whitespace {\n                Some(WordBreakToken {\n                    token: \" \",\n                    grapheme_len: 1,\n                    is_whitespace: true,\n                })\n            } else {\n                Some(WordBreakToken {\n                    token,\n                    grapheme_len: graphemes,\n                    is_whitespace: false,\n                })\n            }\n        } else {\n            None\n        }\n    }\n}\n\n#[test]\nfn test_word_breaking_tokenizer() {\n    let tests: &[(&str, &[(&str, usize, bool)])] = &[\n        (\"\", &[]),\n        (\"  \", &[(\" \", 1, true)]),\n        (\"Ʒ\", &[(\"Ʒ\", 1, false)]),\n        (\"Ǽ\", &[(\"Ǽ\", 1, false)]),\n        (\"⋑\", &[(\"⋑\", 1, false)]),\n        (\"⋑⋑\", &[(\"⋑⋑\", 2, false)]),\n        (\n            \"原理，进而\",\n            &[\n                (\"原\", 1, false),\n                (\"理，\", 2, false),\n                (\"进\", 1, false),\n                (\"而\", 1, false),\n            ],\n        ),\n        (\n            \"hello world\",\n            &[(\"hello\", 5, false), (\" \", 1, true), (\"world\", 5, false)],\n        ),\n        (\n            \"hello, world\",\n            &[(\"hello,\", 6, false), (\" \", 1, true), (\"world\", 5, false)],\n        ),\n        (\n            \"  hello world\",\n            &[\n                (\" \", 1, true),\n                (\"hello\", 5, false),\n                (\" \", 1, true),\n                (\"world\", 5, false),\n            ],\n        ),\n        (\n            \"这是什么 \\n 钢笔\",\n            &[\n                (\"这\", 1, false),\n                (\"是\", 1, false),\n                (\"什\", 1, false),\n                (\"么\", 1, false),\n                (\" \", 1, true),\n                (\"钢\", 1, false),\n                (\"笔\", 1, false),\n            ],\n        ),\n        (\" mutton\", &[(\" \", 1, true), (\"mutton\", 6, false)]),\n    ];\n\n    for (input, result) in tests {\n        assert_eq!(\n            WordBreakingTokenizer::new(input).collect::<Vec<_>>(),\n            result\n                .iter()\n                .copied()\n                .map(|(token, grapheme_len, is_whitespace)| WordBreakToken {\n                    token,\n                    grapheme_len,\n                    is_whitespace,\n                })\n                .collect::<Vec<_>>()\n        );\n    }\n}\n\nfn wrap_with_prefix(\n    line_prefix: String,\n    unwrapped_text: String,\n    wrap_column: usize,\n    tab_size: NonZeroU32,\n) -> String {\n    let line_prefix_len = char_len_with_expanded_tabs(0, &line_prefix, tab_size);\n    let mut wrapped_text = String::new();\n    let mut current_line = line_prefix.clone();\n\n    let tokenizer = WordBreakingTokenizer::new(&unwrapped_text);\n    let mut current_line_len = line_prefix_len;\n    for WordBreakToken {\n        token,\n        grapheme_len,\n        is_whitespace,\n    } in tokenizer\n    {\n        if current_line_len + grapheme_len > wrap_column && current_line_len != line_prefix_len {\n            wrapped_text.push_str(current_line.trim_end());\n            wrapped_text.push('\\n');\n            current_line.truncate(line_prefix.len());\n            current_line_len = line_prefix_len;\n            if !is_whitespace {\n                current_line.push_str(token);\n                current_line_len += grapheme_len;\n            }\n        } else if !is_whitespace {\n            current_line.push_str(token);\n            current_line_len += grapheme_len;\n        } else if current_line_len != line_prefix_len {\n            current_line.push(' ');\n            current_line_len += 1;\n        }\n    }\n\n    if !current_line.is_empty() {\n        wrapped_text.push_str(&current_line);\n    }\n    wrapped_text\n}\n\n#[test]\nfn test_wrap_with_prefix() {\n    assert_eq!(\n        wrap_with_prefix(\n            \"# \".to_string(),\n            \"abcdefg\".to_string(),\n            4,\n            NonZeroU32::new(4).unwrap()\n        ),\n        \"# abcdefg\"\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            \"\".to_string(),\n            \"\\thello world\".to_string(),\n            8,\n            NonZeroU32::new(4).unwrap()\n        ),\n        \"hello\\nworld\"\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            \"// \".to_string(),\n            \"xx \\nyy zz aa bb cc\".to_string(),\n            12,\n            NonZeroU32::new(4).unwrap()\n        ),\n        \"// xx yy zz\\n// aa bb cc\"\n    );\n    assert_eq!(\n        wrap_with_prefix(\n            String::new(),\n            \"这是什么 \\n 钢笔\".to_string(),\n            3,\n            NonZeroU32::new(4).unwrap()\n        ),\n        \"这是什\\n么 钢\\n笔\"\n    );\n}\n\npub trait CollaborationHub {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator>;\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex>;\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString>;\n}\n\nimpl CollaborationHub for Entity<Project> {\n    fn collaborators<'a>(&self, cx: &'a App) -> &'a HashMap<PeerId, Collaborator> {\n        self.read(cx).collaborators()\n    }\n\n    fn user_participant_indices<'a>(&self, cx: &'a App) -> &'a HashMap<u64, ParticipantIndex> {\n        self.read(cx).user_store().read(cx).participant_indices()\n    }\n\n    fn user_names(&self, cx: &App) -> HashMap<u64, SharedString> {\n        let this = self.read(cx);\n        let user_ids = this.collaborators().values().map(|c| c.user_id);\n        this.user_store().read_with(cx, |user_store, cx| {\n            user_store.participant_names(user_ids, cx)\n        })\n    }\n}\n\npub trait SemanticsProvider {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Vec<project::Hover>>>;\n\n    fn inlay_hints(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>>;\n\n    fn resolve_inlay_hint(\n        &self,\n        hint: InlayHint,\n        buffer_handle: Entity<Buffer>,\n        server_id: LanguageServerId,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<InlayHint>>>;\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>>;\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<LocationLink>>>>;\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>>;\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>>;\n}\n\npub trait CompletionProvider {\n    fn completions(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        trigger: CompletionContext,\n        window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<Completion>>>;\n\n    fn resolve_completions(\n        &self,\n        buffer: Entity<Buffer>,\n        completion_indices: Vec<usize>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>>;\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        _buffer: Entity<Buffer>,\n        _completions: Rc<RefCell<Box<[Completion]>>>,\n        _completion_index: usize,\n        _push_to_history: bool,\n        _cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        Task::ready(Ok(None))\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool;\n\n    fn sort_completions(&self) -> bool {\n        true\n    }\n}\n\npub trait CodeActionProvider {\n    fn id(&self) -> Arc<str>;\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>>;\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        excerpt_id: ExcerptId,\n        push_to_history: bool,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>>;\n}\n\nimpl CodeActionProvider for Entity<Project> {\n    fn id(&self) -> Arc<str> {\n        \"project\".into()\n    }\n\n    fn code_actions(\n        &self,\n        buffer: &Entity<Buffer>,\n        range: Range<text::Anchor>,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<Vec<CodeAction>>> {\n        self.update(cx, |project, cx| {\n            project.code_actions(buffer, range, None, cx)\n        })\n    }\n\n    fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        _excerpt_id: ExcerptId,\n        push_to_history: bool,\n        _window: &mut Window,\n        cx: &mut App,\n    ) -> Task<Result<ProjectTransaction>> {\n        self.update(cx, |project, cx| {\n            project.apply_code_action(buffer_handle, action, push_to_history, cx)\n        })\n    }\n}\n\nfn snippet_completions(\n    project: &Project,\n    buffer: &Entity<Buffer>,\n    buffer_position: text::Anchor,\n    cx: &mut App,\n) -> Task<Result<Vec<Completion>>> {\n    let language = buffer.read(cx).language_at(buffer_position);\n    let language_name = language.as_ref().map(|language| language.lsp_id());\n    let snippet_store = project.snippets().read(cx);\n    let snippets = snippet_store.snippets_for(language_name, cx);\n\n    if snippets.is_empty() {\n        return Task::ready(Ok(vec![]));\n    }\n    let snapshot = buffer.read(cx).text_snapshot();\n    let chars: String = snapshot\n        .reversed_chars_for_range(text::Anchor::MIN..buffer_position)\n        .collect();\n\n    let scope = language.map(|language| language.default_scope());\n    let executor = cx.background_executor().clone();\n\n    cx.background_executor().spawn(async move {\n        let classifier = CharClassifier::new(scope).for_completion(true);\n        let mut last_word = chars\n            .chars()\n            .take_while(|c| classifier.is_word(*c))\n            .collect::<String>();\n        last_word = last_word.chars().rev().collect();\n\n        if last_word.is_empty() {\n            return Ok(vec![]);\n        }\n\n        let as_offset = text::ToOffset::to_offset(&buffer_position, &snapshot);\n        let to_lsp = |point: &text::Anchor| {\n            let end = text::ToPointUtf16::to_point_utf16(point, &snapshot);\n            point_to_lsp(end)\n        };\n        let lsp_end = to_lsp(&buffer_position);\n\n        let candidates = snippets\n            .iter()\n            .enumerate()\n            .flat_map(|(ix, snippet)| {\n                snippet\n                    .prefix\n                    .iter()\n                    .map(move |prefix| StringMatchCandidate::new(ix, &prefix))\n            })\n            .collect::<Vec<StringMatchCandidate>>();\n\n        let mut matches = fuzzy::match_strings(\n            &candidates,\n            &last_word,\n            last_word.chars().any(|c| c.is_uppercase()),\n            100,\n            &Default::default(),\n            executor,\n        )\n        .await;\n\n        // Remove all candidates where the query's start does not match the start of any word in the candidate\n        if let Some(query_start) = last_word.chars().next() {\n            matches.retain(|string_match| {\n                split_words(&string_match.string).any(|word| {\n                    // Check that the first codepoint of the word as lowercase matches the first\n                    // codepoint of the query as lowercase\n                    word.chars()\n                        .flat_map(|codepoint| codepoint.to_lowercase())\n                        .zip(query_start.to_lowercase())\n                        .all(|(word_cp, query_cp)| word_cp == query_cp)\n                })\n            });\n        }\n\n        let matched_strings = matches\n            .into_iter()\n            .map(|m| m.string)\n            .collect::<HashSet<_>>();\n\n        let result: Vec<Completion> = snippets\n            .into_iter()\n            .filter_map(|snippet| {\n                let matching_prefix = snippet\n                    .prefix\n                    .iter()\n                    .find(|prefix| matched_strings.contains(*prefix))?;\n                let start = as_offset - last_word.len();\n                let start = snapshot.anchor_before(start);\n                let range = start..buffer_position;\n                let lsp_start = to_lsp(&start);\n                let lsp_range = lsp::Range {\n                    start: lsp_start,\n                    end: lsp_end,\n                };\n                Some(Completion {\n                    old_range: range,\n                    new_text: snippet.body.clone(),\n                    resolved: false,\n                    label: CodeLabel {\n                        text: matching_prefix.clone(),\n                        runs: vec![],\n                        filter_range: 0..matching_prefix.len(),\n                    },\n                    server_id: LanguageServerId(usize::MAX),\n                    documentation: snippet\n                        .description\n                        .clone()\n                        .map(CompletionDocumentation::SingleLine),\n                    lsp_completion: lsp::CompletionItem {\n                        label: snippet.prefix.first().unwrap().clone(),\n                        kind: Some(CompletionItemKind::SNIPPET),\n                        label_details: snippet.description.as_ref().map(|description| {\n                            lsp::CompletionItemLabelDetails {\n                                detail: Some(description.clone()),\n                                description: None,\n                            }\n                        }),\n                        insert_text_format: Some(InsertTextFormat::SNIPPET),\n                        text_edit: Some(lsp::CompletionTextEdit::InsertAndReplace(\n                            lsp::InsertReplaceEdit {\n                                new_text: snippet.body.clone(),\n                                insert: lsp_range,\n                                replace: lsp_range,\n                            },\n                        )),\n                        filter_text: Some(snippet.body.clone()),\n                        sort_text: Some(char::MAX.to_string()),\n                        ..Default::default()\n                    },\n                    confirm: None,\n                })\n            })\n            .collect();\n\n        Ok(result)\n    })\n}\n\nimpl CompletionProvider for Entity<Project> {\n    fn completions(\n        &self,\n        buffer: &Entity<Buffer>,\n        buffer_position: text::Anchor,\n        options: CompletionContext,\n        _window: &mut Window,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Vec<Completion>>> {\n        self.update(cx, |project, cx| {\n            let snippets = snippet_completions(project, buffer, buffer_position, cx);\n            let project_completions = project.completions(buffer, buffer_position, options, cx);\n            cx.background_executor().spawn(async move {\n                let mut completions = project_completions.await?;\n                let snippets_completions = snippets.await?;\n                completions.extend(snippets_completions);\n                Ok(completions)\n            })\n        })\n    }\n\n    fn resolve_completions(\n        &self,\n        buffer: Entity<Buffer>,\n        completion_indices: Vec<usize>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<bool>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.resolve_completions(buffer, completion_indices, completions, cx)\n            })\n        })\n    }\n\n    fn apply_additional_edits_for_completion(\n        &self,\n        buffer: Entity<Buffer>,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        push_to_history: bool,\n        cx: &mut Context<Editor>,\n    ) -> Task<Result<Option<language::Transaction>>> {\n        self.update(cx, |project, cx| {\n            project.lsp_store().update(cx, |lsp_store, cx| {\n                lsp_store.apply_additional_edits_for_completion(\n                    buffer,\n                    completions,\n                    completion_index,\n                    push_to_history,\n                    cx,\n                )\n            })\n        })\n    }\n\n    fn is_completion_trigger(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: language::Anchor,\n        text: &str,\n        trigger_in_words: bool,\n        cx: &mut Context<Editor>,\n    ) -> bool {\n        let mut chars = text.chars();\n        let char = if let Some(char) = chars.next() {\n            char\n        } else {\n            return false;\n        };\n        if chars.next().is_some() {\n            return false;\n        }\n\n        let buffer = buffer.read(cx);\n        let snapshot = buffer.snapshot();\n        if !snapshot.settings_at(position, cx).show_completions_on_input {\n            return false;\n        }\n        let classifier = snapshot.char_classifier_at(position).for_completion(true);\n        if trigger_in_words && classifier.is_word(char) {\n            return true;\n        }\n\n        buffer.completion_triggers().contains(text)\n    }\n}\n\nimpl SemanticsProvider for Entity<Project> {\n    fn hover(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Vec<project::Hover>>> {\n        Some(self.update(cx, |project, cx| project.hover(buffer, position, cx)))\n    }\n\n    fn document_highlights(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<DocumentHighlight>>>> {\n        Some(self.update(cx, |project, cx| {\n            project.document_highlights(buffer, position, cx)\n        }))\n    }\n\n    fn definitions(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        kind: GotoDefinitionKind,\n        cx: &mut App,\n    ) -> Option<Task<Result<Vec<LocationLink>>>> {\n        Some(self.update(cx, |project, cx| match kind {\n            GotoDefinitionKind::Symbol => project.definition(&buffer, position, cx),\n            GotoDefinitionKind::Declaration => project.declaration(&buffer, position, cx),\n            GotoDefinitionKind::Type => project.type_definition(&buffer, position, cx),\n            GotoDefinitionKind::Implementation => project.implementation(&buffer, position, cx),\n        }))\n    }\n\n    fn supports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n        // TODO: make this work for remote projects\n        self.read(cx)\n            .language_servers_for_local_buffer(buffer.read(cx), cx)\n            .any(\n                |(_, server)| match server.capabilities().inlay_hint_provider {\n                    Some(lsp::OneOf::Left(enabled)) => enabled,\n                    Some(lsp::OneOf::Right(_)) => true,\n                    None => false,\n                },\n            )\n    }\n\n    fn inlay_hints(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<text::Anchor>,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<Vec<InlayHint>>>> {\n        Some(self.update(cx, |project, cx| {\n            project.inlay_hints(buffer_handle, range, cx)\n        }))\n    }\n\n    fn resolve_inlay_hint(\n        &self,\n        hint: InlayHint,\n        buffer_handle: Entity<Buffer>,\n        server_id: LanguageServerId,\n        cx: &mut App,\n    ) -> Option<Task<anyhow::Result<InlayHint>>> {\n        Some(self.update(cx, |project, cx| {\n            project.resolve_inlay_hint(hint, buffer_handle, server_id, cx)\n        }))\n    }\n\n    fn range_for_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        cx: &mut App,\n    ) -> Option<Task<Result<Option<Range<text::Anchor>>>>> {\n        Some(self.update(cx, |project, cx| {\n            let buffer = buffer.clone();\n            let task = project.prepare_rename(buffer.clone(), position, cx);\n            cx.spawn(|_, mut cx| async move {\n                Ok(match task.await? {\n                    PrepareRenameResponse::Success(range) => Some(range),\n                    PrepareRenameResponse::InvalidPosition => None,\n                    PrepareRenameResponse::OnlyUnpreparedRenameSupported => {\n                        // Fallback on using TreeSitter info to determine identifier range\n                        buffer.update(&mut cx, |buffer, _| {\n                            let snapshot = buffer.snapshot();\n                            let (range, kind) = snapshot.surrounding_word(position);\n                            if kind != Some(CharKind::Word) {\n                                return None;\n                            }\n                            Some(\n                                snapshot.anchor_before(range.start)\n                                    ..snapshot.anchor_after(range.end),\n                            )\n                        })?\n                    }\n                })\n            })\n        }))\n    }\n\n    fn perform_rename(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: text::Anchor,\n        new_name: String,\n        cx: &mut App,\n    ) -> Option<Task<Result<ProjectTransaction>>> {\n        Some(self.update(cx, |project, cx| {\n            project.perform_rename(buffer.clone(), position, new_name, cx)\n        }))\n    }\n}\n\nfn inlay_hint_settings(\n    location: Anchor,\n    snapshot: &MultiBufferSnapshot,\n    cx: &mut Context<Editor>,\n) -> InlayHintSettings {\n    let file = snapshot.file_at(location);\n    let language = snapshot.language_at(location).map(|l| l.name());\n    language_settings(language, file, cx).inlay_hints\n}\n\nfn consume_contiguous_rows(\n    contiguous_row_selections: &mut Vec<Selection<Point>>,\n    selection: &Selection<Point>,\n    display_map: &DisplaySnapshot,\n    selections: &mut Peekable<std::slice::Iter<Selection<Point>>>,\n) -> (MultiBufferRow, MultiBufferRow) {\n    contiguous_row_selections.push(selection.clone());\n    let start_row = MultiBufferRow(selection.start.row);\n    let mut end_row = ending_row(selection, display_map);\n\n    while let Some(next_selection) = selections.peek() {\n        if next_selection.start.row <= end_row.0 {\n            end_row = ending_row(next_selection, display_map);\n            contiguous_row_selections.push(selections.next().unwrap().clone());\n        } else {\n            break;\n        }\n    }\n    (start_row, end_row)\n}\n\nfn ending_row(next_selection: &Selection<Point>, display_map: &DisplaySnapshot) -> MultiBufferRow {\n    if next_selection.end.column > 0 || next_selection.is_empty() {\n        MultiBufferRow(display_map.next_line_boundary(next_selection.end).0.row + 1)\n    } else {\n        MultiBufferRow(next_selection.end.row)\n    }\n}\n\nimpl EditorSnapshot {\n    pub fn remote_selections_in_range<'a>(\n        &'a self,\n        range: &'a Range<Anchor>,\n        collaboration_hub: &dyn CollaborationHub,\n        cx: &'a App,\n    ) -> impl 'a + Iterator<Item = RemoteSelection> {\n        let participant_names = collaboration_hub.user_names(cx);\n        let participant_indices = collaboration_hub.user_participant_indices(cx);\n        let collaborators_by_peer_id = collaboration_hub.collaborators(cx);\n        let collaborators_by_replica_id = collaborators_by_peer_id\n            .iter()\n            .map(|(_, collaborator)| (collaborator.replica_id, collaborator))\n            .collect::<HashMap<_, _>>();\n        self.buffer_snapshot\n            .selections_in_range(range, false)\n            .filter_map(move |(replica_id, line_mode, cursor_shape, selection)| {\n                let collaborator = collaborators_by_replica_id.get(&replica_id)?;\n                let participant_index = participant_indices.get(&collaborator.user_id).copied();\n                let user_name = participant_names.get(&collaborator.user_id).cloned();\n                Some(RemoteSelection {\n                    replica_id,\n                    selection,\n                    cursor_shape,\n                    line_mode,\n                    participant_index,\n                    peer_id: collaborator.peer_id,\n                    user_name,\n                })\n            })\n    }\n\n    pub fn hunks_for_ranges(\n        &self,\n        ranges: impl Iterator<Item = Range<Point>>,\n    ) -> Vec<MultiBufferDiffHunk> {\n        let mut hunks = Vec::new();\n        let mut processed_buffer_rows: HashMap<BufferId, HashSet<Range<text::Anchor>>> =\n            HashMap::default();\n        for query_range in ranges {\n            let query_rows =\n                MultiBufferRow(query_range.start.row)..MultiBufferRow(query_range.end.row + 1);\n            for hunk in self.buffer_snapshot.diff_hunks_in_range(\n                Point::new(query_rows.start.0, 0)..Point::new(query_rows.end.0, 0),\n            ) {\n                // Deleted hunk is an empty row range, no caret can be placed there and Zed allows to revert it\n                // when the caret is just above or just below the deleted hunk.\n                let allow_adjacent = hunk.status().is_removed();\n                let related_to_selection = if allow_adjacent {\n                    hunk.row_range.overlaps(&query_rows)\n                        || hunk.row_range.start == query_rows.end\n                        || hunk.row_range.end == query_rows.start\n                } else {\n                    hunk.row_range.overlaps(&query_rows)\n                };\n                if related_to_selection {\n                    if !processed_buffer_rows\n                        .entry(hunk.buffer_id)\n                        .or_default()\n                        .insert(hunk.buffer_range.start..hunk.buffer_range.end)\n                    {\n                        continue;\n                    }\n                    hunks.push(hunk);\n                }\n            }\n        }\n\n        hunks\n    }\n\n    pub fn language_at<T: ToOffset>(&self, position: T) -> Option<&Arc<Language>> {\n        self.display_snapshot.buffer_snapshot.language_at(position)\n    }\n\n    pub fn is_focused(&self) -> bool {\n        self.is_focused\n    }\n\n    pub fn placeholder_text(&self) -> Option<&Arc<str>> {\n        self.placeholder_text.as_ref()\n    }\n\n    pub fn scroll_position(&self) -> gpui::Point<f32> {\n        self.scroll_anchor.scroll_position(&self.display_snapshot)\n    }\n\n    fn gutter_dimensions(\n        &self,\n        font_id: FontId,\n        font_size: Pixels,\n        max_line_number_width: Pixels,\n        cx: &App,\n    ) -> Option<GutterDimensions> {\n        if !self.show_gutter {\n            return None;\n        }\n\n        let descent = cx.text_system().descent(font_id, font_size);\n        let em_width = cx.text_system().em_width(font_id, font_size).log_err()?;\n        let em_advance = cx.text_system().em_advance(font_id, font_size).log_err()?;\n\n        let show_git_gutter = self.show_git_diff_gutter.unwrap_or_else(|| {\n            matches!(\n                ProjectSettings::get_global(cx).git.git_gutter,\n                Some(GitGutterSetting::TrackedFiles)\n            )\n        });\n        let gutter_settings = EditorSettings::get_global(cx).gutter;\n        let show_line_numbers = self\n            .show_line_numbers\n            .unwrap_or(gutter_settings.line_numbers);\n        let line_gutter_width = if show_line_numbers {\n            // Avoid flicker-like gutter resizes when the line number gains another digit and only resize the gutter on files with N*10^5 lines.\n            let min_width_for_number_on_gutter = em_advance * 4.0;\n            max_line_number_width.max(min_width_for_number_on_gutter)\n        } else {\n            0.0.into()\n        };\n\n        let show_code_actions = self\n            .show_code_actions\n            .unwrap_or(gutter_settings.code_actions);\n\n        let show_runnables = self.show_runnables.unwrap_or(gutter_settings.runnables);\n\n        let git_blame_entries_width =\n            self.git_blame_gutter_max_author_length\n                .map(|max_author_length| {\n                    const MAX_RELATIVE_TIMESTAMP: &str = \"60 minutes ago\";\n\n                    /// The number of characters to dedicate to gaps and margins.\n                    const SPACING_WIDTH: usize = 4;\n\n                    let max_char_count = max_author_length\n                        .min(GIT_BLAME_MAX_AUTHOR_CHARS_DISPLAYED)\n                        + ::git::SHORT_SHA_LENGTH\n                        + MAX_RELATIVE_TIMESTAMP.len()\n                        + SPACING_WIDTH;\n\n                    em_advance * max_char_count\n                });\n\n        let mut left_padding = git_blame_entries_width.unwrap_or(Pixels::ZERO);\n        left_padding += if show_code_actions || show_runnables {\n            em_width * 3.0\n        } else if show_git_gutter && show_line_numbers {\n            em_width * 2.0\n        } else if show_git_gutter || show_line_numbers {\n            em_width\n        } else {\n            px(0.)\n        };\n\n        let right_padding = if gutter_settings.folds && show_line_numbers {\n            em_width * 4.0\n        } else if gutter_settings.folds {\n            em_width * 3.0\n        } else if show_line_numbers {\n            em_width\n        } else {\n            px(0.)\n        };\n\n        Some(GutterDimensions {\n            left_padding,\n            right_padding,\n            width: line_gutter_width + left_padding + right_padding,\n            margin: -descent,\n            git_blame_entries_width,\n        })\n    }\n\n    pub fn render_crease_toggle(\n        &self,\n        buffer_row: MultiBufferRow,\n        row_contains_cursor: bool,\n        editor: Entity<Editor>,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        let mut is_foldable = false;\n\n        if let Some(crease) = self\n            .crease_snapshot\n            .query_row(buffer_row, &self.buffer_snapshot)\n        {\n            is_foldable = true;\n            match crease {\n                Crease::Inline { render_toggle, .. } | Crease::Block { render_toggle, .. } => {\n                    if let Some(render_toggle) = render_toggle {\n                        let toggle_callback =\n                            Arc::new(move |folded, window: &mut Window, cx: &mut App| {\n                                if folded {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.fold_at(&crate::FoldAt { buffer_row }, window, cx)\n                                    });\n                                } else {\n                                    editor.update(cx, |editor, cx| {\n                                        editor.unfold_at(\n                                            &crate::UnfoldAt { buffer_row },\n                                            window,\n                                            cx,\n                                        )\n                                    });\n                                }\n                            });\n                        return Some((render_toggle)(\n                            buffer_row,\n                            folded,\n                            toggle_callback,\n                            window,\n                            cx,\n                        ));\n                    }\n                }\n            }\n        }\n\n        is_foldable |= self.starts_indent(buffer_row);\n\n        if folded || (is_foldable && (row_contains_cursor || self.gutter_hovered)) {\n            Some(\n                Disclosure::new((\"gutter_crease\", buffer_row.0), !folded)\n                    .toggle_state(folded)\n                    .on_click(window.listener_for(&editor, move |this, _e, window, cx| {\n                        if folded {\n                            this.unfold_at(&UnfoldAt { buffer_row }, window, cx);\n                        } else {\n                            this.fold_at(&FoldAt { buffer_row }, window, cx);\n                        }\n                    }))\n                    .into_any_element(),\n            )\n        } else {\n            None\n        }\n    }\n\n    pub fn render_crease_trailer(\n        &self,\n        buffer_row: MultiBufferRow,\n        window: &mut Window,\n        cx: &mut App,\n    ) -> Option<AnyElement> {\n        let folded = self.is_line_folded(buffer_row);\n        if let Crease::Inline { render_trailer, .. } = self\n            .crease_snapshot\n            .query_row(buffer_row, &self.buffer_snapshot)?\n        {\n            let render_trailer = render_trailer.as_ref()?;\n            Some(render_trailer(buffer_row, folded, window, cx))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Deref for EditorSnapshot {\n    type Target = DisplaySnapshot;\n\n    fn deref(&self) -> &Self::Target {\n        &self.display_snapshot\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum EditorEvent {\n    InputIgnored {\n        text: Arc<str>,\n    },\n    InputHandled {\n        utf16_range_to_replace: Option<Range<isize>>,\n        text: Arc<str>,\n    },\n    ExcerptsAdded {\n        buffer: Entity<Buffer>,\n        predecessor: ExcerptId,\n        excerpts: Vec<(ExcerptId, ExcerptRange<language::Anchor>)>,\n    },\n    ExcerptsRemoved {\n        ids: Vec<ExcerptId>,\n    },\n    BufferFoldToggled {\n        ids: Vec<ExcerptId>,\n        folded: bool,\n    },\n    ExcerptsEdited {\n        ids: Vec<ExcerptId>,\n    },\n    ExcerptsExpanded {\n        ids: Vec<ExcerptId>,\n    },\n    BufferEdited,\n    Edited {\n        transaction_id: clock::Lamport,\n    },\n    Reparsed(BufferId),\n    Focused,\n    FocusedIn,\n    Blurred,\n    DirtyChanged,\n    Saved,\n    TitleChanged,\n    DiffBaseChanged,\n    SelectionsChanged {\n        local: bool,\n    },\n    ScrollPositionChanged {\n        local: bool,\n        autoscroll: bool,\n    },\n    Closed,\n    TransactionUndone {\n        transaction_id: clock::Lamport,\n    },\n    TransactionBegun {\n        transaction_id: clock::Lamport,\n    },\n    Reloaded,\n    CursorShapeChanged,\n}\n\nimpl EventEmitter<EditorEvent> for Editor {}\n\nimpl Focusable for Editor {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl Render for Editor {\n    fn render<'a>(&mut self, _: &mut Window, cx: &mut Context<'a, Self>) -> impl IntoElement {\n        let settings = ThemeSettings::get_global(cx);\n\n        let mut text_style = match self.mode {\n            EditorMode::SingleLine { .. } | EditorMode::AutoHeight { .. } => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.ui_font.family.clone(),\n                font_features: settings.ui_font.features.clone(),\n                font_fallbacks: settings.ui_font.fallbacks.clone(),\n                font_size: rems(0.875).into(),\n                font_weight: settings.ui_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n            EditorMode::Full => TextStyle {\n                color: cx.theme().colors().editor_foreground,\n                font_family: settings.buffer_font.family.clone(),\n                font_features: settings.buffer_font.features.clone(),\n                font_fallbacks: settings.buffer_font.fallbacks.clone(),\n                font_size: settings.buffer_font_size().into(),\n                font_weight: settings.buffer_font.weight,\n                line_height: relative(settings.buffer_line_height.value()),\n                ..Default::default()\n            },\n        };\n        if let Some(text_style_refinement) = &self.text_style_refinement {\n            text_style.refine(text_style_refinement)\n        }\n\n        let background = match self.mode {\n            EditorMode::SingleLine { .. } => cx.theme().system().transparent,\n            EditorMode::AutoHeight { max_lines: _ } => cx.theme().system().transparent,\n            EditorMode::Full => cx.theme().colors().editor_background,\n        };\n\n        EditorElement::new(\n            &cx.entity(),\n            EditorStyle {\n                background,\n                local_player: cx.theme().players().local(),\n                text: text_style,\n                scrollbar_width: EditorElement::SCROLLBAR_WIDTH,\n                syntax: cx.theme().syntax().clone(),\n                status: cx.theme().status().clone(),\n                inlay_hints_style: make_inlay_hints_style(cx),\n                inline_completion_styles: make_suggestion_styles(cx),\n                unnecessary_code_fade: ThemeSettings::get_global(cx).unnecessary_code_fade,\n            },\n        )\n    }\n}\n\nimpl EntityInputHandler for Editor {\n    fn text_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n        adjusted_range: &mut Option<Range<usize>>,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<String> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let start = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.start), Bias::Left);\n        let end = snapshot.clip_offset_utf16(OffsetUtf16(range_utf16.end), Bias::Right);\n        if (start.0..end.0) != range_utf16 {\n            adjusted_range.replace(start.0..end.0);\n        }\n        Some(snapshot.text_for_range(start..end).collect())\n    }\n\n    fn selected_text_range(\n        &mut self,\n        ignore_disabled_input: bool,\n        _: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<UTF16Selection> {\n        // Prevent the IME menu from appearing when holding down an alphabetic key\n        // while input is disabled.\n        if !ignore_disabled_input && !self.input_enabled {\n            return None;\n        }\n\n        let selection = self.selections.newest::<OffsetUtf16>(cx);\n        let range = selection.range();\n\n        Some(UTF16Selection {\n            range: range.start.0..range.end.0,\n            reversed: selection.reversed,\n        })\n    }\n\n    fn marked_text_range(&self, _: &mut Window, cx: &mut Context<Self>) -> Option<Range<usize>> {\n        let snapshot = self.buffer.read(cx).read(cx);\n        let range = self.text_highlights::<InputComposition>(cx)?.1.first()?;\n        Some(range.start.to_offset_utf16(&snapshot).0..range.end.to_offset_utf16(&snapshot).0)\n    }\n\n    fn unmark_text(&mut self, _: &mut Window, cx: &mut Context<Self>) {\n        self.clear_highlights::<InputComposition>(cx);\n        self.ime_transaction.take();\n    }\n\n    fn replace_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            cx.emit(EditorEvent::InputIgnored { text: text.into() });\n            return;\n        }\n\n        self.transact(window, cx, |this, window, cx| {\n            let new_selected_ranges = if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                this.marked_text_ranges(cx)\n            };\n\n            let range_to_replace = new_selected_ranges.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(cx)\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(new_selected_ranges) = new_selected_ranges {\n                this.change_selections(None, window, cx, |selections| {\n                    selections.select_ranges(new_selected_ranges)\n                });\n                this.backspace(&Default::default(), window, cx);\n            }\n\n            this.handle_input(text, window, cx);\n        });\n\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        self.unmark_text(window, cx);\n    }\n\n    fn replace_and_mark_text_in_range(\n        &mut self,\n        range_utf16: Option<Range<usize>>,\n        text: &str,\n        new_selected_range_utf16: Option<Range<usize>>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        if !self.input_enabled {\n            return;\n        }\n\n        let transaction = self.transact(window, cx, |this, window, cx| {\n            let ranges_to_replace = if let Some(mut marked_ranges) = this.marked_text_ranges(cx) {\n                let snapshot = this.buffer.read(cx).read(cx);\n                if let Some(relative_range_utf16) = range_utf16.as_ref() {\n                    for marked_range in &mut marked_ranges {\n                        marked_range.end.0 = marked_range.start.0 + relative_range_utf16.end;\n                        marked_range.start.0 += relative_range_utf16.start;\n                        marked_range.start =\n                            snapshot.clip_offset_utf16(marked_range.start, Bias::Left);\n                        marked_range.end =\n                            snapshot.clip_offset_utf16(marked_range.end, Bias::Right);\n                    }\n                }\n                Some(marked_ranges)\n            } else if let Some(range_utf16) = range_utf16 {\n                let range_utf16 = OffsetUtf16(range_utf16.start)..OffsetUtf16(range_utf16.end);\n                Some(this.selection_replacement_ranges(range_utf16, cx))\n            } else {\n                None\n            };\n\n            let range_to_replace = ranges_to_replace.as_ref().and_then(|ranges_to_replace| {\n                let newest_selection_id = this.selections.newest_anchor().id;\n                this.selections\n                    .all::<OffsetUtf16>(cx)\n                    .iter()\n                    .zip(ranges_to_replace.iter())\n                    .find_map(|(selection, range)| {\n                        if selection.id == newest_selection_id {\n                            Some(\n                                (range.start.0 as isize - selection.head().0 as isize)\n                                    ..(range.end.0 as isize - selection.head().0 as isize),\n                            )\n                        } else {\n                            None\n                        }\n                    })\n            });\n\n            cx.emit(EditorEvent::InputHandled {\n                utf16_range_to_replace: range_to_replace,\n                text: text.into(),\n            });\n\n            if let Some(ranges) = ranges_to_replace {\n                this.change_selections(None, window, cx, |s| s.select_ranges(ranges));\n            }\n\n            let marked_ranges = {\n                let snapshot = this.buffer.read(cx).read(cx);\n                this.selections\n                    .disjoint_anchors()\n                    .iter()\n                    .map(|selection| {\n                        selection.start.bias_left(&snapshot)..selection.end.bias_right(&snapshot)\n                    })\n                    .collect::<Vec<_>>()\n            };\n\n            if text.is_empty() {\n                this.unmark_text(window, cx);\n            } else {\n                this.highlight_text::<InputComposition>(\n                    marked_ranges.clone(),\n                    HighlightStyle {\n                        underline: Some(UnderlineStyle {\n                            thickness: px(1.),\n                            color: None,\n                            wavy: false,\n                        }),\n                        ..Default::default()\n                    },\n                    cx,\n                );\n            }\n\n            // Disable auto-closing when composing text (i.e. typing a `\"` on a Brazilian keyboard)\n            let use_autoclose = this.use_autoclose;\n            let use_auto_surround = this.use_auto_surround;\n            this.set_use_autoclose(false);\n            this.set_use_auto_surround(false);\n            this.handle_input(text, window, cx);\n            this.set_use_autoclose(use_autoclose);\n            this.set_use_auto_surround(use_auto_surround);\n\n            if let Some(new_selected_range) = new_selected_range_utf16 {\n                let snapshot = this.buffer.read(cx).read(cx);\n                let new_selected_ranges = marked_ranges\n                    .into_iter()\n                    .map(|marked_range| {\n                        let insertion_start = marked_range.start.to_offset_utf16(&snapshot).0;\n                        let new_start = OffsetUtf16(new_selected_range.start + insertion_start);\n                        let new_end = OffsetUtf16(new_selected_range.end + insertion_start);\n                        snapshot.clip_offset_utf16(new_start, Bias::Left)\n                            ..snapshot.clip_offset_utf16(new_end, Bias::Right)\n                    })\n                    .collect::<Vec<_>>();\n\n                drop(snapshot);\n                this.change_selections(None, window, cx, |selections| {\n                    selections.select_ranges(new_selected_ranges)\n                });\n            }\n        });\n\n        self.ime_transaction = self.ime_transaction.or(transaction);\n        if let Some(transaction) = self.ime_transaction {\n            self.buffer.update(cx, |buffer, cx| {\n                buffer.group_until_transaction(transaction, cx);\n            });\n        }\n\n        if self.text_highlights::<InputComposition>(cx).is_none() {\n            self.ime_transaction.take();\n        }\n    }\n\n    fn bounds_for_range(\n        &mut self,\n        range_utf16: Range<usize>,\n        element_bounds: gpui::Bounds<Pixels>,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) -> Option<gpui::Bounds<Pixels>> {\n        let text_layout_details = self.text_layout_details(window);\n        let gpui::Size {\n            width: em_width,\n            height: line_height,\n        } = self.character_size(window);\n\n        let snapshot = self.snapshot(window, cx);\n        let scroll_position = snapshot.scroll_position();\n        let scroll_left = scroll_position.x * em_width;\n\n        let start = OffsetUtf16(range_utf16.start).to_display_point(&snapshot);\n        let x = snapshot.x_for_display_point(start, &text_layout_details) - scroll_left\n            + self.gutter_dimensions.width\n            + self.gutter_dimensions.margin;\n        let y = line_height * (start.row().as_f32() - scroll_position.y);\n\n        Some(Bounds {\n            origin: element_bounds.origin + point(x, y),\n            size: size(em_width, line_height),\n        })\n    }\n\n    fn character_index_for_point(\n        &mut self,\n        point: gpui::Point<Pixels>,\n        _window: &mut Window,\n        _cx: &mut Context<Self>,\n    ) -> Option<usize> {\n        let position_map = self.last_position_map.as_ref()?;\n        if !position_map.text_hitbox.contains(&point) {\n            return None;\n        }\n        let display_point = position_map.point_for_position(point).previous_valid;\n        let anchor = position_map\n            .snapshot\n            .display_point_to_anchor(display_point, Bias::Left);\n        let utf16_offset = anchor.to_offset_utf16(&position_map.snapshot.buffer_snapshot);\n        Some(utf16_offset.0)\n    }\n}\n\ntrait SelectionExt {\n    fn display_range(&self, map: &DisplaySnapshot) -> Range<DisplayPoint>;\n    fn spanned_rows(\n        &self,\n        include_end_if_at_line_start: bool,\n        map: &DisplaySnapshot,\n    ) -> Range<MultiBufferRow>;\n}\n\nimpl<T: ToPoint + ToOffset> SelectionExt for Selection<T> {\n    fn display_range(&self, map: &DisplaySnapshot) -> Range<DisplayPoint> {\n        let start = self\n            .start\n            .to_point(&map.buffer_snapshot)\n            .to_display_point(map);\n        let end = self\n            .end\n            .to_point(&map.buffer_snapshot)\n            .to_display_point(map);\n        if self.reversed {\n            end..start\n        } else {\n            start..end\n        }\n    }\n\n    fn spanned_rows(\n        &self,\n        include_end_if_at_line_start: bool,\n        map: &DisplaySnapshot,\n    ) -> Range<MultiBufferRow> {\n        let start = self.start.to_point(&map.buffer_snapshot);\n        let mut end = self.end.to_point(&map.buffer_snapshot);\n        if !include_end_if_at_line_start && start.row != end.row && end.column == 0 {\n            end.row -= 1;\n        }\n\n        let buffer_start = map.prev_line_boundary(start).0;\n        let buffer_end = map.next_line_boundary(end).0;\n        MultiBufferRow(buffer_start.row)..MultiBufferRow(buffer_end.row + 1)\n    }\n}\n\nimpl<T: InvalidationRegion> InvalidationStack<T> {\n    fn invalidate<S>(&mut self, selections: &[Selection<S>], buffer: &MultiBufferSnapshot)\n    where\n        S: Clone + ToOffset,\n    {\n        while let Some(region) = self.last() {\n            let all_selections_inside_invalidation_ranges =\n                if selections.len() == region.ranges().len() {\n                    selections\n                        .iter()\n                        .zip(region.ranges().iter().map(|r| r.to_offset(buffer)))\n                        .all(|(selection, invalidation_range)| {\n                            let head = selection.head().to_offset(buffer);\n                            invalidation_range.start <= head && invalidation_range.end >= head\n                        })\n                } else {\n                    false\n                };\n\n            if all_selections_inside_invalidation_ranges {\n                break;\n            } else {\n                self.pop();\n            }\n        }\n    }\n}\n\nimpl<T> Default for InvalidationStack<T> {\n    fn default() -> Self {\n        Self(Default::default())\n    }\n}\n\nimpl<T> Deref for InvalidationStack<T> {\n    type Target = Vec<T>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for InvalidationStack<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl InvalidationRegion for SnippetState {\n    fn ranges(&self) -> &[Range<Anchor>] {\n        &self.ranges[self.active_index]\n    }\n}\n\npub fn diagnostic_block_renderer(\n    diagnostic: Diagnostic,\n    max_message_rows: Option<u8>,\n    allow_closing: bool,\n    _is_valid: bool,\n) -> RenderBlock {\n    let (text_without_backticks, code_ranges) =\n        highlight_diagnostic_message(&diagnostic, max_message_rows);\n\n    Arc::new(move |cx: &mut BlockContext| {\n        let group_id: SharedString = cx.block_id.to_string().into();\n\n        let mut text_style = cx.window.text_style().clone();\n        text_style.color = diagnostic_style(diagnostic.severity, cx.theme().status());\n        let theme_settings = ThemeSettings::get_global(cx);\n        text_style.font_family = theme_settings.buffer_font.family.clone();\n        text_style.font_style = theme_settings.buffer_font.style;\n        text_style.font_features = theme_settings.buffer_font.features.clone();\n        text_style.font_weight = theme_settings.buffer_font.weight;\n\n        let multi_line_diagnostic = diagnostic.message.contains('\\n');\n\n        let buttons = |diagnostic: &Diagnostic| {\n            if multi_line_diagnostic {\n                v_flex()\n            } else {\n                h_flex()\n            }\n            .when(allow_closing, |div| {\n                div.children(diagnostic.is_primary.then(|| {\n                    IconButton::new(\"close-block\", IconName::XCircle)\n                        .icon_color(Color::Muted)\n                        .size(ButtonSize::Compact)\n                        .style(ButtonStyle::Transparent)\n                        .visible_on_hover(group_id.clone())\n                        .on_click(move |_click, window, cx| {\n                            window.dispatch_action(Box::new(Cancel), cx)\n                        })\n                        .tooltip(|window, cx| {\n                            Tooltip::for_action(\"Close Diagnostics\", &Cancel, window, cx)\n                        })\n                }))\n            })\n            .child(\n                IconButton::new(\"copy-block\", IconName::Copy)\n                    .icon_color(Color::Muted)\n                    .size(ButtonSize::Compact)\n                    .style(ButtonStyle::Transparent)\n                    .visible_on_hover(group_id.clone())\n                    .on_click({\n                        let message = diagnostic.message.clone();\n                        move |_click, _, cx| {\n                            cx.write_to_clipboard(ClipboardItem::new_string(message.clone()))\n                        }\n                    })\n                    .tooltip(Tooltip::text(\"Copy diagnostic message\")),\n            )\n        };\n\n        let icon_size = buttons(&diagnostic).into_any_element().layout_as_root(\n            AvailableSpace::min_size(),\n            cx.window,\n            cx.app,\n        );\n\n        h_flex()\n            .id(cx.block_id)\n            .group(group_id.clone())\n            .relative()\n            .size_full()\n            .block_mouse_down()\n            .pl(cx.gutter_dimensions.width)\n            .w(cx.max_width - cx.gutter_dimensions.full_width())\n            .child(\n                div()\n                    .flex()\n                    .w(cx.anchor_x - cx.gutter_dimensions.width - icon_size.width)\n                    .flex_shrink(),\n            )\n            .child(buttons(&diagnostic))\n            .child(div().flex().flex_shrink_0().child(\n                StyledText::new(text_without_backticks.clone()).with_highlights(\n                    &text_style,\n                    code_ranges.iter().map(|range| {\n                        (\n                            range.clone(),\n                            HighlightStyle {\n                                font_weight: Some(FontWeight::BOLD),\n                                ..Default::default()\n                            },\n                        )\n                    }),\n                ),\n            ))\n            .into_any_element()\n    })\n}\n\nfn inline_completion_edit_text(\n    current_snapshot: &BufferSnapshot,\n    edits: &[(Range<Anchor>, String)],\n    edit_preview: &EditPreview,\n    include_deletions: bool,\n    cx: &App,\n) -> HighlightedText {\n    let edits = edits\n        .iter()\n        .map(|(anchor, text)| {\n            (\n                anchor.start.text_anchor..anchor.end.text_anchor,\n                text.clone(),\n            )\n        })\n        .collect::<Vec<_>>();\n\n    edit_preview.highlight_edits(current_snapshot, &edits, include_deletions, cx)\n}\n\npub fn highlight_diagnostic_message(\n    diagnostic: &Diagnostic,\n    mut max_message_rows: Option<u8>,\n) -> (SharedString, Vec<Range<usize>>) {\n    let mut text_without_backticks = String::new();\n    let mut code_ranges = Vec::new();\n\n    if let Some(source) = &diagnostic.source {\n        text_without_backticks.push_str(source);\n        code_ranges.push(0..source.len());\n        text_without_backticks.push_str(\": \");\n    }\n\n    let mut prev_offset = 0;\n    let mut in_code_block = false;\n    let has_row_limit = max_message_rows.is_some();\n    let mut newline_indices = diagnostic\n        .message\n        .match_indices('\\n')\n        .filter(|_| has_row_limit)\n        .map(|(ix, _)| ix)\n        .fuse()\n        .peekable();\n\n    for (quote_ix, _) in diagnostic\n        .message\n        .match_indices('`')\n        .chain([(diagnostic.message.len(), \"\")])\n    {\n        let mut first_newline_ix = None;\n        let mut last_newline_ix = None;\n        while let Some(newline_ix) = newline_indices.peek() {\n            if *newline_ix < quote_ix {\n                if first_newline_ix.is_none() {\n                    first_newline_ix = Some(*newline_ix);\n                }\n                last_newline_ix = Some(*newline_ix);\n\n                if let Some(rows_left) = &mut max_message_rows {\n                    if *rows_left == 0 {\n                        break;\n                    } else {\n                        *rows_left -= 1;\n                    }\n                }\n                let _ = newline_indices.next();\n            } else {\n                break;\n            }\n        }\n        let prev_len = text_without_backticks.len();\n        let new_text = &diagnostic.message[prev_offset..first_newline_ix.unwrap_or(quote_ix)];\n        text_without_backticks.push_str(new_text);\n        if in_code_block {\n            code_ranges.push(prev_len..text_without_backticks.len());\n        }\n        prev_offset = last_newline_ix.unwrap_or(quote_ix) + 1;\n        in_code_block = !in_code_block;\n        if first_newline_ix.map_or(false, |newline_ix| newline_ix < quote_ix) {\n            text_without_backticks.push_str(\"...\");\n            break;\n        }\n    }\n\n    (text_without_backticks.into(), code_ranges)\n}\n\nfn diagnostic_style(severity: DiagnosticSeverity, colors: &StatusColors) -> Hsla {\n    match severity {\n        DiagnosticSeverity::ERROR => colors.error,\n        DiagnosticSeverity::WARNING => colors.warning,\n        DiagnosticSeverity::INFORMATION => colors.info,\n        DiagnosticSeverity::HINT => colors.info,\n        _ => colors.ignored,\n    }\n}\n\npub fn styled_runs_for_code_label<'a>(\n    label: &'a CodeLabel,\n    syntax_theme: &'a theme::SyntaxTheme,\n) -> impl 'a + Iterator<Item = (Range<usize>, HighlightStyle)> {\n    let fade_out = HighlightStyle {\n        fade_out: Some(0.35),\n        ..Default::default()\n    };\n\n    let mut prev_end = label.filter_range.end;\n    label\n        .runs\n        .iter()\n        .enumerate()\n        .flat_map(move |(ix, (range, highlight_id))| {\n            let style = if let Some(style) = highlight_id.style(syntax_theme) {\n                style\n            } else {\n                return Default::default();\n            };\n            let mut muted_style = style;\n            muted_style.highlight(fade_out);\n\n            let mut runs = SmallVec::<[(Range<usize>, HighlightStyle); 3]>::new();\n            if range.start >= label.filter_range.end {\n                if range.start > prev_end {\n                    runs.push((prev_end..range.start, fade_out));\n                }\n                runs.push((range.clone(), muted_style));\n            } else if range.end <= label.filter_range.end {\n                runs.push((range.clone(), style));\n            } else {\n                runs.push((range.start..label.filter_range.end, style));\n                runs.push((label.filter_range.end..range.end, muted_style));\n            }\n            prev_end = cmp::max(prev_end, range.end);\n\n            if ix + 1 == label.runs.len() && label.text.len() > prev_end {\n                runs.push((prev_end..label.text.len(), fade_out));\n            }\n\n            runs\n        })\n}\n\npub(crate) fn split_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n    let mut prev_index = 0;\n    let mut prev_codepoint: Option<char> = None;\n    text.char_indices()\n        .chain([(text.len(), '\\0')])\n        .filter_map(move |(index, codepoint)| {\n            let prev_codepoint = prev_codepoint.replace(codepoint)?;\n            let is_boundary = index == text.len()\n                || !prev_codepoint.is_uppercase() && codepoint.is_uppercase()\n                || !prev_codepoint.is_alphanumeric() && codepoint.is_alphanumeric();\n            if is_boundary {\n                let chunk = &text[prev_index..index];\n                prev_index = index;\n                Some(chunk)\n            } else {\n                None\n            }\n        })\n}\n\npub trait RangeToAnchorExt: Sized {\n    fn to_anchors(self, snapshot: &MultiBufferSnapshot) -> Range<Anchor>;\n\n    fn to_display_points(self, snapshot: &EditorSnapshot) -> Range<DisplayPoint> {\n        let anchor_range = self.to_anchors(&snapshot.buffer_snapshot);\n        anchor_range.start.to_display_point(snapshot)..anchor_range.end.to_display_point(snapshot)\n    }\n}\n\nimpl<T: ToOffset> RangeToAnchorExt for Range<T> {\n    fn to_anchors(self, snapshot: &MultiBufferSnapshot) -> Range<Anchor> {\n        let start_offset = self.start.to_offset(snapshot);\n        let end_offset = self.end.to_offset(snapshot);\n        if start_offset == end_offset {\n            snapshot.anchor_before(start_offset)..snapshot.anchor_before(end_offset)\n        } else {\n            snapshot.anchor_after(self.start)..snapshot.anchor_before(self.end)\n        }\n    }\n}\n\npub trait RowExt {\n    fn as_f32(&self) -> f32;\n\n    fn next_row(&self) -> Self;\n\n    fn previous_row(&self) -> Self;\n\n    fn minus(&self, other: Self) -> u32;\n}\n\nimpl RowExt for DisplayRow {\n    fn as_f32(&self) -> f32 {\n        self.0 as f32\n    }\n\n    fn next_row(&self) -> Self {\n        Self(self.0 + 1)\n    }\n\n    fn previous_row(&self) -> Self {\n        Self(self.0.saturating_sub(1))\n    }\n\n    fn minus(&self, other: Self) -> u32 {\n        self.0 - other.0\n    }\n}\n\nimpl RowExt for MultiBufferRow {\n    fn as_f32(&self) -> f32 {\n        self.0 as f32\n    }\n\n    fn next_row(&self) -> Self {\n        Self(self.0 + 1)\n    }\n\n    fn previous_row(&self) -> Self {\n        Self(self.0.saturating_sub(1))\n    }\n\n    fn minus(&self, other: Self) -> u32 {\n        self.0 - other.0\n    }\n}\n\ntrait RowRangeExt {\n    type Row;\n\n    fn len(&self) -> usize;\n\n    fn iter_rows(&self) -> impl DoubleEndedIterator<Item = Self::Row>;\n}\n\nimpl RowRangeExt for Range<MultiBufferRow> {\n    type Row = MultiBufferRow;\n\n    fn len(&self) -> usize {\n        (self.end.0 - self.start.0) as usize\n    }\n\n    fn iter_rows(&self) -> impl DoubleEndedIterator<Item = MultiBufferRow> {\n        (self.start.0..self.end.0).map(MultiBufferRow)\n    }\n}\n\nimpl RowRangeExt for Range<DisplayRow> {\n    type Row = DisplayRow;\n\n    fn len(&self) -> usize {\n        (self.end.0 - self.start.0) as usize\n    }\n\n    fn iter_rows(&self) -> impl DoubleEndedIterator<Item = DisplayRow> {\n        (self.start.0..self.end.0).map(DisplayRow)\n    }\n}\n\n/// If select range has more than one line, we\n/// just point the cursor to range.start.\nfn collapse_multiline_range(range: Range<Point>) -> Range<Point> {\n    if range.start.row == range.end.row {\n        range\n    } else {\n        range.start..range.start\n    }\n}\npub struct KillRing(ClipboardItem);\nimpl Global for KillRing {}\n\nconst UPDATE_DEBOUNCE: Duration = Duration::from_millis(50);\n\nfn all_edits_insertions_or_deletions(\n    edits: &Vec<(Range<Anchor>, String)>,\n    snapshot: &MultiBufferSnapshot,\n) -> bool {\n    let mut all_insertions = true;\n    let mut all_deletions = true;\n\n    for (range, new_text) in edits.iter() {\n        let range_is_empty = range.to_offset(&snapshot).is_empty();\n        let text_is_empty = new_text.is_empty();\n\n        if range_is_empty != text_is_empty {\n            if range_is_empty {\n                all_deletions = false;\n            } else {\n                all_insertions = false;\n            }\n        } else {\n            return false;\n        }\n\n        if !all_insertions && !all_deletions {\n            return false;\n        }\n    }\n    all_insertions || all_deletions\n}\n```\n\n\nHow do I get syntax highlighting in an instance of `Editor`?\nTo enable syntax highlighting in a Zed `Editor` instance, there are a few key steps:\n\n1. Ensure the editor has a proper `EditorStyle` set with a syntax theme. This happens automatically when rendering the editor via the `Render` implementation, but the main components needed are:\n\n```rust\nlet style = EditorStyle {\n    background: background_color,\n    local_player: player_color,\n    text: text_style,\n    scrollbar_width: scrollbar_width, \n    syntax: cx.theme().syntax().clone(), // This provides the syntax highlighting theme\n    status: status_colors,\n    // ...other fields...\n};\n```\n\n2. The buffer being edited needs to have a language assigned to it. This can happen in a few ways:\n\n```rust\n// When creating a new buffer:\nlet buffer = cx.new(|cx| Buffer::new(0, text, language)); \n\n// Or setting the language later:\nbuffer.update(cx, |buffer, cx| {\n    buffer.set_language(Some(language), cx);\n});\n```\n\n3. The buffer needs to be properly parsed. This happens automatically as text is edited, but you can also trigger it manually:\n\n```rust\nbuffer.update(cx, |buffer, cx| {\n    buffer.reparse(cx);\n});\n```\n\n4. When creating the editor, make sure to pass in the buffer and project context:\n\n```rust\nlet editor = cx.new(|cx| Editor::for_buffer(\n    buffer,\n    Some(project), // Project provides language services\n    window,\n    cx\n));\n```\n\n5. The editor needs to be rendered with proper text styling that includes font settings. This is handled automatically by the `Render` implementation but requires theme settings to be configured.\n\nHere's a complete example:\n\n```rust\n// Create a buffer with a language\nlet buffer = cx.new(|cx| {\n    let mut buffer = Buffer::new(0, initial_text, None);\n    buffer.set_language(Some(language), cx);\n    buffer\n});\n\n// Create a multi-buffer wrapper\nlet multi_buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n\n// Create the editor\nlet editor = cx.new(|cx| Editor::for_buffer(\n    buffer,\n    Some(project),\n    window, \n    cx\n));\n\n// The editor will automatically pick up syntax highlighting when rendered\n// as long as the theme system is properly configured\n```\n\nThe key things to remember are:\n\n1. The buffer needs a language assigned\n2. The editor needs a syntax theme via `EditorStyle`\n3. The buffer needs to be parsed \n4. The editor needs project context for language services\n5. Theme settings need to be properly configured\n\nThe syntax highlighting will then be applied automatically as the buffer is edited and displayed.\n\nLet me know if you have any other questions about configuring syntax highlighting in Zed's editor!\n```rs zed/crates/project/src/project.rs\npub mod buffer_store;\nmod color_extractor;\npub mod connection_manager;\npub mod debounced_delay;\npub mod git;\npub mod image_store;\npub mod lsp_command;\npub mod lsp_ext_command;\npub mod lsp_store;\npub mod prettier_store;\npub mod project_settings;\npub mod search;\nmod task_inventory;\npub mod task_store;\npub mod terminals;\npub mod toolchain_store;\npub mod worktree_store;\n\n#[cfg(test)]\nmod project_tests;\n\nmod direnv;\nmod environment;\nuse buffer_diff::BufferDiff;\npub use environment::EnvironmentErrorMessage;\nuse git::Repository;\npub mod search_history;\nmod yarn;\n\nuse crate::git::GitState;\nuse anyhow::{anyhow, Context as _, Result};\nuse buffer_store::{BufferStore, BufferStoreEvent};\nuse client::{\n    proto, Client, Collaborator, PendingEntitySubscription, ProjectId, TypedEnvelope, UserStore,\n};\nuse clock::ReplicaId;\nuse collections::{BTreeSet, HashMap, HashSet};\nuse debounced_delay::DebouncedDelay;\npub use environment::ProjectEnvironment;\nuse futures::{\n    channel::mpsc::{self, UnboundedReceiver},\n    future::try_join_all,\n    StreamExt,\n};\npub use image_store::{ImageItem, ImageStore};\nuse image_store::{ImageItemEvent, ImageStoreEvent};\n\nuse ::git::{\n    blame::Blame,\n    repository::{Branch, GitRepository, RepoPath},\n    status::FileStatus,\n};\nuse gpui::{\n    AnyEntity, App, AppContext as _, AsyncApp, BorrowAppContext, Context, Entity, EventEmitter,\n    Hsla, SharedString, Task, WeakEntity, Window,\n};\nuse itertools::Itertools;\nuse language::{\n    language_settings::InlayHintKind, proto::split_operations, Buffer, BufferEvent,\n    CachedLspAdapter, Capability, CodeLabel, CompletionDocumentation, File as _, Language,\n    LanguageName, LanguageRegistry, PointUtf16, ToOffset, ToPointUtf16, Toolchain, ToolchainList,\n    Transaction, Unclipped,\n};\nuse lsp::{\n    CodeActionKind, CompletionContext, CompletionItemKind, DocumentHighlightKind, LanguageServer,\n    LanguageServerId, LanguageServerName, MessageActionItem,\n};\nuse lsp_command::*;\nuse lsp_store::LspFormatTarget;\nuse node_runtime::NodeRuntime;\nuse parking_lot::Mutex;\npub use prettier_store::PrettierStore;\nuse project_settings::{ProjectSettings, SettingsObserver, SettingsObserverEvent};\nuse remote::{SshConnectionOptions, SshRemoteClient};\nuse rpc::{\n    proto::{FromProto, LanguageServerPromptResponse, ToProto, SSH_PROJECT_ID},\n    AnyProtoClient, ErrorCode,\n};\nuse search::{SearchInputKind, SearchQuery, SearchResult};\nuse search_history::SearchHistory;\nuse settings::{InvalidSettingsError, Settings, SettingsLocation, SettingsStore};\nuse smol::channel::Receiver;\nuse snippet::Snippet;\nuse snippet_provider::SnippetProvider;\nuse std::{\n    borrow::Cow,\n    ops::Range,\n    path::{Component, Path, PathBuf},\n    pin::pin,\n    str,\n    sync::Arc,\n    time::Duration,\n};\nuse task_store::TaskStore;\nuse terminals::Terminals;\nuse text::{Anchor, BufferId};\nuse toolchain_store::EmptyToolchainStore;\nuse util::{paths::compare_paths, ResultExt as _};\nuse worktree::{CreatedEntry, Snapshot, Traversal};\nuse worktree_store::{WorktreeStore, WorktreeStoreEvent};\n\npub use fs::*;\npub use language::Location;\n#[cfg(any(test, feature = \"test-support\"))]\npub use prettier::FORMAT_SUFFIX as TEST_PRETTIER_FORMAT_SUFFIX;\npub use task_inventory::{\n    BasicContextProvider, ContextProviderWithTasks, Inventory, TaskSourceKind,\n};\npub use worktree::{\n    Entry, EntryKind, File, LocalWorktree, PathChange, ProjectEntryId, UpdatedEntriesSet,\n    UpdatedGitRepositoriesSet, Worktree, WorktreeId, WorktreeSettings, FS_WATCH_LATENCY,\n};\n\npub use buffer_store::ProjectTransaction;\npub use lsp_store::{\n    DiagnosticSummary, LanguageServerLogType, LanguageServerProgress, LanguageServerPromptRequest,\n    LanguageServerStatus, LanguageServerToQuery, LspStore, LspStoreEvent,\n    SERVER_PROGRESS_THROTTLE_TIMEOUT,\n};\npub use toolchain_store::ToolchainStore;\nconst MAX_PROJECT_SEARCH_HISTORY_SIZE: usize = 500;\nconst MAX_SEARCH_RESULT_FILES: usize = 5_000;\nconst MAX_SEARCH_RESULT_RANGES: usize = 10_000;\n\npub trait ProjectItem {\n    fn try_open(\n        project: &Entity<Project>,\n        path: &ProjectPath,\n        cx: &mut App,\n    ) -> Option<Task<Result<Entity<Self>>>>\n    where\n        Self: Sized;\n    fn entry_id(&self, cx: &App) -> Option<ProjectEntryId>;\n    fn project_path(&self, cx: &App) -> Option<ProjectPath>;\n    fn is_dirty(&self) -> bool;\n}\n\n#[derive(Clone)]\npub enum OpenedBufferEvent {\n    Disconnected,\n    Ok(BufferId),\n    Err(BufferId, Arc<anyhow::Error>),\n}\n\n/// Semantics-aware entity that is relevant to one or more [`Worktree`] with the files.\n/// `Project` is responsible for tasks, LSP and collab queries, synchronizing worktree states accordingly.\n/// Maps [`Worktree`] entries with its own logic using [`ProjectEntryId`] and [`ProjectPath`] structs.\n///\n/// Can be either local (for the project opened on the same host) or remote.(for collab projects, browsed by multiple remote users).\npub struct Project {\n    active_entry: Option<ProjectEntryId>,\n    buffer_ordered_messages_tx: mpsc::UnboundedSender<BufferOrderedMessage>,\n    languages: Arc<LanguageRegistry>,\n    client: Arc<client::Client>,\n    join_project_response_message_id: u32,\n    task_store: Entity<TaskStore>,\n    user_store: Entity<UserStore>,\n    fs: Arc<dyn Fs>,\n    ssh_client: Option<Entity<SshRemoteClient>>,\n    client_state: ProjectClientState,\n    git_state: Entity<GitState>,\n    collaborators: HashMap<proto::PeerId, Collaborator>,\n    client_subscriptions: Vec<client::Subscription>,\n    worktree_store: Entity<WorktreeStore>,\n    buffer_store: Entity<BufferStore>,\n    image_store: Entity<ImageStore>,\n    lsp_store: Entity<LspStore>,\n    _subscriptions: Vec<gpui::Subscription>,\n    buffers_needing_diff: HashSet<WeakEntity<Buffer>>,\n    git_diff_debouncer: DebouncedDelay<Self>,\n    remotely_created_models: Arc<Mutex<RemotelyCreatedModels>>,\n    terminals: Terminals,\n    node: Option<NodeRuntime>,\n    search_history: SearchHistory,\n    search_included_history: SearchHistory,\n    search_excluded_history: SearchHistory,\n    snippets: Entity<SnippetProvider>,\n    environment: Entity<ProjectEnvironment>,\n    settings_observer: Entity<SettingsObserver>,\n    toolchain_store: Option<Entity<ToolchainStore>>,\n}\n\n#[derive(Default)]\nstruct RemotelyCreatedModels {\n    worktrees: Vec<Entity<Worktree>>,\n    buffers: Vec<Entity<Buffer>>,\n    retain_count: usize,\n}\n\nstruct RemotelyCreatedModelGuard {\n    remote_models: std::sync::Weak<Mutex<RemotelyCreatedModels>>,\n}\n\nimpl Drop for RemotelyCreatedModelGuard {\n    fn drop(&mut self) {\n        if let Some(remote_models) = self.remote_models.upgrade() {\n            let mut remote_models = remote_models.lock();\n            assert!(\n                remote_models.retain_count > 0,\n                \"RemotelyCreatedModelGuard dropped too many times\"\n            );\n            remote_models.retain_count -= 1;\n            if remote_models.retain_count == 0 {\n                remote_models.buffers.clear();\n                remote_models.worktrees.clear();\n            }\n        }\n    }\n}\n/// Message ordered with respect to buffer operations\n#[derive(Debug)]\nenum BufferOrderedMessage {\n    Operation {\n        buffer_id: BufferId,\n        operation: proto::Operation,\n    },\n    LanguageServerUpdate {\n        language_server_id: LanguageServerId,\n        message: proto::update_language_server::Variant,\n    },\n    Resync,\n}\n\n#[derive(Debug)]\nenum ProjectClientState {\n    /// Single-player mode.\n    Local,\n    /// Multi-player mode but still a local project.\n    Shared { remote_id: u64 },\n    /// Multi-player mode but working on a remote project.\n    Remote {\n        sharing_has_stopped: bool,\n        capability: Capability,\n        remote_id: u64,\n        replica_id: ReplicaId,\n    },\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Event {\n    LanguageServerAdded(LanguageServerId, LanguageServerName, Option<WorktreeId>),\n    LanguageServerRemoved(LanguageServerId),\n    LanguageServerLog(LanguageServerId, LanguageServerLogType, String),\n    Toast {\n        notification_id: SharedString,\n        message: String,\n    },\n    HideToast {\n        notification_id: SharedString,\n    },\n    LanguageServerPrompt(LanguageServerPromptRequest),\n    LanguageNotFound(Entity<Buffer>),\n    ActiveEntryChanged(Option<ProjectEntryId>),\n    ActivateProjectPanel,\n    WorktreeAdded(WorktreeId),\n    WorktreeOrderChanged,\n    WorktreeRemoved(WorktreeId),\n    WorktreeUpdatedEntries(WorktreeId, UpdatedEntriesSet),\n    WorktreeUpdatedGitRepositories(WorktreeId),\n    DiskBasedDiagnosticsStarted {\n        language_server_id: LanguageServerId,\n    },\n    DiskBasedDiagnosticsFinished {\n        language_server_id: LanguageServerId,\n    },\n    DiagnosticsUpdated {\n        path: ProjectPath,\n        language_server_id: LanguageServerId,\n    },\n    RemoteIdChanged(Option<u64>),\n    DisconnectedFromHost,\n    DisconnectedFromSshRemote,\n    Closed,\n    DeletedEntry(WorktreeId, ProjectEntryId),\n    CollaboratorUpdated {\n        old_peer_id: proto::PeerId,\n        new_peer_id: proto::PeerId,\n    },\n    CollaboratorJoined(proto::PeerId),\n    CollaboratorLeft(proto::PeerId),\n    HostReshared,\n    Reshared,\n    Rejoined,\n    RefreshInlayHints,\n    RevealInProjectPanel(ProjectEntryId),\n    SnippetEdit(BufferId, Vec<(lsp::Range, Snippet)>),\n    ExpandedAllForEntry(WorktreeId, ProjectEntryId),\n}\n\n#[derive(Clone, Debug, Eq, PartialEq, Hash, PartialOrd, Ord)]\npub struct ProjectPath {\n    pub worktree_id: WorktreeId,\n    pub path: Arc<Path>,\n}\n\nimpl ProjectPath {\n    pub fn from_proto(p: proto::ProjectPath) -> Self {\n        Self {\n            worktree_id: WorktreeId::from_proto(p.worktree_id),\n            path: Arc::<Path>::from_proto(p.path),\n        }\n    }\n\n    pub fn to_proto(&self) -> proto::ProjectPath {\n        proto::ProjectPath {\n            worktree_id: self.worktree_id.to_proto(),\n            path: self.path.as_ref().to_proto(),\n        }\n    }\n\n    pub fn root_path(worktree_id: WorktreeId) -> Self {\n        Self {\n            worktree_id,\n            path: Path::new(\"\").into(),\n        }\n    }\n}\n\n#[derive(Debug, Default)]\npub enum PrepareRenameResponse {\n    Success(Range<Anchor>),\n    OnlyUnpreparedRenameSupported,\n    #[default]\n    InvalidPosition,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct InlayHint {\n    pub position: language::Anchor,\n    pub label: InlayHintLabel,\n    pub kind: Option<InlayHintKind>,\n    pub padding_left: bool,\n    pub padding_right: bool,\n    pub tooltip: Option<InlayHintTooltip>,\n    pub resolve_state: ResolveState,\n}\n\n/// The user's intent behind a given completion confirmation\n#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\npub enum CompletionIntent {\n    /// The user intends to 'commit' this result, if possible\n    /// completion confirmations should run side effects\n    Complete,\n    /// The user intends to continue 'composing' this completion\n    /// completion confirmations should not run side effects and\n    /// let the user continue composing their action\n    Compose,\n}\n\nimpl CompletionIntent {\n    pub fn is_complete(&self) -> bool {\n        self == &Self::Complete\n    }\n\n    pub fn is_compose(&self) -> bool {\n        self == &Self::Compose\n    }\n}\n\n/// A completion provided by a language server\n#[derive(Clone)]\npub struct Completion {\n    /// The range of the buffer that will be replaced.\n    pub old_range: Range<Anchor>,\n    /// The new text that will be inserted.\n    pub new_text: String,\n    /// A label for this completion that is shown in the menu.\n    pub label: CodeLabel,\n    /// The id of the language server that produced this completion.\n    pub server_id: LanguageServerId,\n    /// The documentation for this completion.\n    pub documentation: Option<CompletionDocumentation>,\n    /// The raw completion provided by the language server.\n    pub lsp_completion: lsp::CompletionItem,\n    /// Whether this completion has been resolved, to ensure it happens once per completion.\n    pub resolved: bool,\n    /// An optional callback to invoke when this completion is confirmed.\n    /// Returns, whether new completions should be retriggered after the current one.\n    /// If `true` is returned, the editor will show a new completion menu after this completion is confirmed.\n    /// if no confirmation is provided or `false` is returned, the completion will be committed.\n    pub confirm: Option<Arc<dyn Send + Sync + Fn(CompletionIntent, &mut Window, &mut App) -> bool>>,\n}\n\nimpl std::fmt::Debug for Completion {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Completion\")\n            .field(\"old_range\", &self.old_range)\n            .field(\"new_text\", &self.new_text)\n            .field(\"label\", &self.label)\n            .field(\"server_id\", &self.server_id)\n            .field(\"documentation\", &self.documentation)\n            .field(\"lsp_completion\", &self.lsp_completion)\n            .finish()\n    }\n}\n\n/// A completion provided by a language server\n#[derive(Clone, Debug)]\npub(crate) struct CoreCompletion {\n    old_range: Range<Anchor>,\n    new_text: String,\n    server_id: LanguageServerId,\n    lsp_completion: lsp::CompletionItem,\n    resolved: bool,\n}\n\n/// A code action provided by a language server.\n#[derive(Clone, Debug)]\npub struct CodeAction {\n    /// The id of the language server that produced this code action.\n    pub server_id: LanguageServerId,\n    /// The range of the buffer where this code action is applicable.\n    pub range: Range<Anchor>,\n    /// The raw code action provided by the language server.\n    pub lsp_action: lsp::CodeAction,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ResolveState {\n    Resolved,\n    CanResolve(LanguageServerId, Option<lsp::LSPAny>),\n    Resolving,\n}\n\nimpl InlayHint {\n    pub fn text(&self) -> String {\n        match &self.label {\n            InlayHintLabel::String(s) => s.to_owned(),\n            InlayHintLabel::LabelParts(parts) => parts.iter().map(|part| &part.value).join(\"\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InlayHintLabel {\n    String(String),\n    LabelParts(Vec<InlayHintLabelPart>),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct InlayHintLabelPart {\n    pub value: String,\n    pub tooltip: Option<InlayHintLabelPartTooltip>,\n    pub location: Option<(LanguageServerId, lsp::Location)>,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InlayHintTooltip {\n    String(String),\n    MarkupContent(MarkupContent),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum InlayHintLabelPartTooltip {\n    String(String),\n    MarkupContent(MarkupContent),\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MarkupContent {\n    pub kind: HoverBlockKind,\n    pub value: String,\n}\n\n#[derive(Debug, Clone)]\npub struct LocationLink {\n    pub origin: Option<Location>,\n    pub target: Location,\n}\n\n#[derive(Debug)]\npub struct DocumentHighlight {\n    pub range: Range<language::Anchor>,\n    pub kind: DocumentHighlightKind,\n}\n\n#[derive(Clone, Debug)]\npub struct Symbol {\n    pub language_server_name: LanguageServerName,\n    pub source_worktree_id: WorktreeId,\n    pub path: ProjectPath,\n    pub label: CodeLabel,\n    pub name: String,\n    pub kind: lsp::SymbolKind,\n    pub range: Range<Unclipped<PointUtf16>>,\n    pub signature: [u8; 32],\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct HoverBlock {\n    pub text: String,\n    pub kind: HoverBlockKind,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum HoverBlockKind {\n    PlainText,\n    Markdown,\n    Code { language: String },\n}\n\n#[derive(Debug, Clone)]\npub struct Hover {\n    pub contents: Vec<HoverBlock>,\n    pub range: Option<Range<language::Anchor>>,\n    pub language: Option<Arc<Language>>,\n}\n\nimpl Hover {\n    pub fn is_empty(&self) -> bool {\n        self.contents.iter().all(|block| block.text.is_empty())\n    }\n}\n\nenum EntitySubscription {\n    Project(PendingEntitySubscription<Project>),\n    BufferStore(PendingEntitySubscription<BufferStore>),\n    WorktreeStore(PendingEntitySubscription<WorktreeStore>),\n    LspStore(PendingEntitySubscription<LspStore>),\n    SettingsObserver(PendingEntitySubscription<SettingsObserver>),\n}\n\n#[derive(Clone)]\npub enum DirectoryLister {\n    Project(Entity<Project>),\n    Local(Arc<dyn Fs>),\n}\n\nimpl DirectoryLister {\n    pub fn is_local(&self, cx: &App) -> bool {\n        match self {\n            DirectoryLister::Local(_) => true,\n            DirectoryLister::Project(project) => project.read(cx).is_local(),\n        }\n    }\n\n    pub fn resolve_tilde<'a>(&self, path: &'a String, cx: &App) -> Cow<'a, str> {\n        if self.is_local(cx) {\n            shellexpand::tilde(path)\n        } else {\n            Cow::from(path)\n        }\n    }\n\n    pub fn default_query(&self, cx: &mut App) -> String {\n        if let DirectoryLister::Project(project) = self {\n            if let Some(worktree) = project.read(cx).visible_worktrees(cx).next() {\n                return worktree.read(cx).abs_path().to_string_lossy().to_string();\n            }\n        };\n        \"~/\".to_string()\n    }\n\n    pub fn list_directory(&self, path: String, cx: &mut App) -> Task<Result<Vec<PathBuf>>> {\n        match self {\n            DirectoryLister::Project(project) => {\n                project.update(cx, |project, cx| project.list_directory(path, cx))\n            }\n            DirectoryLister::Local(fs) => {\n                let fs = fs.clone();\n                cx.background_executor().spawn(async move {\n                    let mut results = vec![];\n                    let expanded = shellexpand::tilde(&path);\n                    let query = Path::new(expanded.as_ref());\n                    let mut response = fs.read_dir(query).await?;\n                    while let Some(path) = response.next().await {\n                        if let Some(file_name) = path?.file_name() {\n                            results.push(PathBuf::from(file_name.to_os_string()));\n                        }\n                    }\n                    Ok(results)\n                })\n            }\n        }\n    }\n}\n\n#[cfg(any(test, feature = \"test-support\"))]\npub const DEFAULT_COMPLETION_CONTEXT: CompletionContext = CompletionContext {\n    trigger_kind: lsp::CompletionTriggerKind::INVOKED,\n    trigger_character: None,\n};\n\nimpl Project {\n    pub fn init_settings(cx: &mut App) {\n        WorktreeSettings::register(cx);\n        ProjectSettings::register(cx);\n    }\n\n    pub fn init(client: &Arc<Client>, cx: &mut App) {\n        connection_manager::init(client.clone(), cx);\n        Self::init_settings(cx);\n\n        let client: AnyProtoClient = client.clone().into();\n        client.add_entity_message_handler(Self::handle_add_collaborator);\n        client.add_entity_message_handler(Self::handle_update_project_collaborator);\n        client.add_entity_message_handler(Self::handle_remove_collaborator);\n        client.add_entity_message_handler(Self::handle_update_project);\n        client.add_entity_message_handler(Self::handle_unshare_project);\n        client.add_entity_request_handler(Self::handle_update_buffer);\n        client.add_entity_message_handler(Self::handle_update_worktree);\n        client.add_entity_request_handler(Self::handle_synchronize_buffers);\n\n        client.add_entity_request_handler(Self::handle_search_candidate_buffers);\n        client.add_entity_request_handler(Self::handle_open_buffer_by_id);\n        client.add_entity_request_handler(Self::handle_open_buffer_by_path);\n        client.add_entity_request_handler(Self::handle_open_new_buffer);\n        client.add_entity_message_handler(Self::handle_create_buffer_for_peer);\n\n        client.add_entity_request_handler(Self::handle_stage);\n        client.add_entity_request_handler(Self::handle_unstage);\n        client.add_entity_request_handler(Self::handle_commit);\n        client.add_entity_request_handler(Self::handle_open_commit_message_buffer);\n\n        WorktreeStore::init(&client);\n        BufferStore::init(&client);\n        LspStore::init(&client);\n        SettingsObserver::init(&client);\n        TaskStore::init(Some(&client));\n        ToolchainStore::init(&client);\n    }\n\n    pub fn local(\n        client: Arc<Client>,\n        node: NodeRuntime,\n        user_store: Entity<UserStore>,\n        languages: Arc<LanguageRegistry>,\n        fs: Arc<dyn Fs>,\n        env: Option<HashMap<String, String>>,\n        cx: &mut App,\n    ) -> Entity<Self> {\n        cx.new(|cx: &mut Context<Self>| {\n            let (tx, rx) = mpsc::unbounded();\n            cx.spawn(move |this, cx| Self::send_buffer_ordered_messages(this, rx, cx))\n                .detach();\n            let snippets = SnippetProvider::new(fs.clone(), BTreeSet::from_iter([]), cx);\n            let worktree_store = cx.new(|_| WorktreeStore::local(false, fs.clone()));\n            cx.subscribe(&worktree_store, Self::on_worktree_store_event)\n                .detach();\n\n            let buffer_store = cx.new(|cx| BufferStore::local(worktree_store.clone(), cx));\n            cx.subscribe(&buffer_store, Self::on_buffer_store_event)\n                .detach();\n\n            let image_store = cx.new(|cx| ImageStore::local(worktree_store.clone(), cx));\n            cx.subscribe(&image_store, Self::on_image_store_event)\n                .detach();\n\n            let prettier_store = cx.new(|cx| {\n                PrettierStore::new(\n                    node.clone(),\n                    fs.clone(),\n                    languages.clone(),\n                    worktree_store.clone(),\n                    cx,\n                )\n            });\n\n            let environment = ProjectEnvironment::new(&worktree_store, env, cx);\n            let toolchain_store = cx.new(|cx| {\n                ToolchainStore::local(\n                    languages.clone(),\n                    worktree_store.clone(),\n                    environment.clone(),\n                    cx,\n                )\n            });\n            let task_store = cx.new(|cx| {\n                TaskStore::local(\n                    fs.clone(),\n                    buffer_store.downgrade(),\n                    worktree_store.clone(),\n                    toolchain_store.read(cx).as_language_toolchain_store(),\n                    environment.clone(),\n                    cx,\n                )\n            });\n\n            let settings_observer = cx.new(|cx| {\n                SettingsObserver::new_local(\n                    fs.clone(),\n                    worktree_store.clone(),\n                    task_store.clone(),\n                    cx,\n                )\n            });\n            cx.subscribe(&settings_observer, Self::on_settings_observer_event)\n                .detach();\n\n            let lsp_store = cx.new(|cx| {\n                LspStore::new_local(\n                    buffer_store.clone(),\n                    worktree_store.clone(),\n                    prettier_store.clone(),\n                    toolchain_store.clone(),\n                    environment.clone(),\n                    languages.clone(),\n                    client.http_client(),\n                    fs.clone(),\n                    cx,\n                )\n            });\n\n            let git_state = cx.new(|cx| GitState::new(&worktree_store, None, None, cx));\n\n            cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n\n            Self {\n                buffer_ordered_messages_tx: tx,\n                collaborators: Default::default(),\n                worktree_store,\n                buffer_store,\n                image_store,\n                lsp_store,\n                join_project_response_message_id: 0,\n                client_state: ProjectClientState::Local,\n                git_state,\n                client_subscriptions: Vec::new(),\n                _subscriptions: vec![cx.on_release(Self::release)],\n                active_entry: None,\n                snippets,\n                languages,\n                client,\n                task_store,\n                user_store,\n                settings_observer,\n                fs,\n                ssh_client: None,\n                buffers_needing_diff: Default::default(),\n                git_diff_debouncer: DebouncedDelay::new(),\n                terminals: Terminals {\n                    local_handles: Vec::new(),\n                },\n                node: Some(node),\n                search_history: Self::new_search_history(),\n                environment,\n                remotely_created_models: Default::default(),\n\n                search_included_history: Self::new_search_history(),\n                search_excluded_history: Self::new_search_history(),\n\n                toolchain_store: Some(toolchain_store),\n            }\n        })\n    }\n\n    pub fn ssh(\n        ssh: Entity<SshRemoteClient>,\n        client: Arc<Client>,\n        node: NodeRuntime,\n        user_store: Entity<UserStore>,\n        languages: Arc<LanguageRegistry>,\n        fs: Arc<dyn Fs>,\n        cx: &mut App,\n    ) -> Entity<Self> {\n        cx.new(|cx: &mut Context<Self>| {\n            let (tx, rx) = mpsc::unbounded();\n            cx.spawn(move |this, cx| Self::send_buffer_ordered_messages(this, rx, cx))\n                .detach();\n            let global_snippets_dir = paths::config_dir().join(\"snippets\");\n            let snippets =\n                SnippetProvider::new(fs.clone(), BTreeSet::from_iter([global_snippets_dir]), cx);\n\n            let ssh_proto = ssh.read(cx).proto_client();\n            let worktree_store =\n                cx.new(|_| WorktreeStore::remote(false, ssh_proto.clone(), SSH_PROJECT_ID));\n            cx.subscribe(&worktree_store, Self::on_worktree_store_event)\n                .detach();\n\n            let buffer_store = cx.new(|cx| {\n                BufferStore::remote(\n                    worktree_store.clone(),\n                    ssh.read(cx).proto_client(),\n                    SSH_PROJECT_ID,\n                    cx,\n                )\n            });\n            let image_store = cx.new(|cx| {\n                ImageStore::remote(\n                    worktree_store.clone(),\n                    ssh.read(cx).proto_client(),\n                    SSH_PROJECT_ID,\n                    cx,\n                )\n            });\n            cx.subscribe(&buffer_store, Self::on_buffer_store_event)\n                .detach();\n            let toolchain_store = cx\n                .new(|cx| ToolchainStore::remote(SSH_PROJECT_ID, ssh.read(cx).proto_client(), cx));\n            let task_store = cx.new(|cx| {\n                TaskStore::remote(\n                    fs.clone(),\n                    buffer_store.downgrade(),\n                    worktree_store.clone(),\n                    toolchain_store.read(cx).as_language_toolchain_store(),\n                    ssh.read(cx).proto_client(),\n                    SSH_PROJECT_ID,\n                    cx,\n                )\n            });\n\n            let settings_observer = cx.new(|cx| {\n                SettingsObserver::new_remote(worktree_store.clone(), task_store.clone(), cx)\n            });\n            cx.subscribe(&settings_observer, Self::on_settings_observer_event)\n                .detach();\n\n            let environment = ProjectEnvironment::new(&worktree_store, None, cx);\n\n            let lsp_store = cx.new(|cx| {\n                LspStore::new_remote(\n                    buffer_store.clone(),\n                    worktree_store.clone(),\n                    Some(toolchain_store.clone()),\n                    languages.clone(),\n                    ssh_proto.clone(),\n                    SSH_PROJECT_ID,\n                    fs.clone(),\n                    cx,\n                )\n            });\n            cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n\n            let git_state = cx.new(|cx| {\n                GitState::new(\n                    &worktree_store,\n                    Some(ssh_proto.clone()),\n                    Some(ProjectId(SSH_PROJECT_ID)),\n                    cx,\n                )\n            });\n\n            cx.subscribe(&ssh, Self::on_ssh_event).detach();\n            cx.observe(&ssh, |_, _, cx| cx.notify()).detach();\n\n            let this = Self {\n                buffer_ordered_messages_tx: tx,\n                collaborators: Default::default(),\n                worktree_store,\n                buffer_store,\n                image_store,\n                lsp_store,\n                join_project_response_message_id: 0,\n                client_state: ProjectClientState::Local,\n                git_state,\n                client_subscriptions: Vec::new(),\n                _subscriptions: vec![\n                    cx.on_release(Self::release),\n                    cx.on_app_quit(|this, cx| {\n                        let shutdown = this.ssh_client.take().and_then(|client| {\n                            client\n                                .read(cx)\n                                .shutdown_processes(Some(proto::ShutdownRemoteServer {}))\n                        });\n\n                        cx.background_executor().spawn(async move {\n                            if let Some(shutdown) = shutdown {\n                                shutdown.await;\n                            }\n                        })\n                    }),\n                ],\n                active_entry: None,\n                snippets,\n                languages,\n                client,\n                task_store,\n                user_store,\n                settings_observer,\n                fs,\n                ssh_client: Some(ssh.clone()),\n                buffers_needing_diff: Default::default(),\n                git_diff_debouncer: DebouncedDelay::new(),\n                terminals: Terminals {\n                    local_handles: Vec::new(),\n                },\n                node: Some(node),\n                search_history: Self::new_search_history(),\n                environment,\n                remotely_created_models: Default::default(),\n\n                search_included_history: Self::new_search_history(),\n                search_excluded_history: Self::new_search_history(),\n\n                toolchain_store: Some(toolchain_store),\n            };\n\n            // ssh -> local machine handlers\n            let ssh = ssh.read(cx);\n            ssh.subscribe_to_entity(SSH_PROJECT_ID, &cx.entity());\n            ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.buffer_store);\n            ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.worktree_store);\n            ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.lsp_store);\n            ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.settings_observer);\n\n            ssh_proto.add_entity_message_handler(Self::handle_create_buffer_for_peer);\n            ssh_proto.add_entity_message_handler(Self::handle_update_worktree);\n            ssh_proto.add_entity_message_handler(Self::handle_update_project);\n            ssh_proto.add_entity_message_handler(Self::handle_toast);\n            ssh_proto.add_entity_request_handler(Self::handle_language_server_prompt_request);\n            ssh_proto.add_entity_message_handler(Self::handle_hide_toast);\n            ssh_proto.add_entity_request_handler(Self::handle_update_buffer_from_ssh);\n            BufferStore::init(&ssh_proto);\n            LspStore::init(&ssh_proto);\n            SettingsObserver::init(&ssh_proto);\n            TaskStore::init(Some(&ssh_proto));\n            ToolchainStore::init(&ssh_proto);\n\n            this\n        })\n    }\n\n    pub async fn remote(\n        remote_id: u64,\n        client: Arc<Client>,\n        user_store: Entity<UserStore>,\n        languages: Arc<LanguageRegistry>,\n        fs: Arc<dyn Fs>,\n        cx: AsyncApp,\n    ) -> Result<Entity<Self>> {\n        let project =\n            Self::in_room(remote_id, client, user_store, languages, fs, cx.clone()).await?;\n        cx.update(|cx| {\n            connection_manager::Manager::global(cx).update(cx, |manager, cx| {\n                manager.maintain_project_connection(&project, cx)\n            })\n        })?;\n        Ok(project)\n    }\n\n    pub async fn in_room(\n        remote_id: u64,\n        client: Arc<Client>,\n        user_store: Entity<UserStore>,\n        languages: Arc<LanguageRegistry>,\n        fs: Arc<dyn Fs>,\n        cx: AsyncApp,\n    ) -> Result<Entity<Self>> {\n        client.authenticate_and_connect(true, &cx).await?;\n\n        let subscriptions = [\n            EntitySubscription::Project(client.subscribe_to_entity::<Self>(remote_id)?),\n            EntitySubscription::BufferStore(client.subscribe_to_entity::<BufferStore>(remote_id)?),\n            EntitySubscription::WorktreeStore(\n                client.subscribe_to_entity::<WorktreeStore>(remote_id)?,\n            ),\n            EntitySubscription::LspStore(client.subscribe_to_entity::<LspStore>(remote_id)?),\n            EntitySubscription::SettingsObserver(\n                client.subscribe_to_entity::<SettingsObserver>(remote_id)?,\n            ),\n        ];\n        let response = client\n            .request_envelope(proto::JoinProject {\n                project_id: remote_id,\n            })\n            .await?;\n        Self::from_join_project_response(\n            response,\n            subscriptions,\n            client,\n            false,\n            user_store,\n            languages,\n            fs,\n            cx,\n        )\n        .await\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    async fn from_join_project_response(\n        response: TypedEnvelope<proto::JoinProjectResponse>,\n        subscriptions: [EntitySubscription; 5],\n        client: Arc<Client>,\n        run_tasks: bool,\n        user_store: Entity<UserStore>,\n        languages: Arc<LanguageRegistry>,\n        fs: Arc<dyn Fs>,\n        mut cx: AsyncApp,\n    ) -> Result<Entity<Self>> {\n        let remote_id = response.payload.project_id;\n        let role = response.payload.role();\n\n        let worktree_store = cx.new(|_| {\n            WorktreeStore::remote(true, client.clone().into(), response.payload.project_id)\n        })?;\n        let buffer_store = cx.new(|cx| {\n            BufferStore::remote(worktree_store.clone(), client.clone().into(), remote_id, cx)\n        })?;\n        let image_store = cx.new(|cx| {\n            ImageStore::remote(worktree_store.clone(), client.clone().into(), remote_id, cx)\n        })?;\n\n        let lsp_store = cx.new(|cx| {\n            let mut lsp_store = LspStore::new_remote(\n                buffer_store.clone(),\n                worktree_store.clone(),\n                None,\n                languages.clone(),\n                client.clone().into(),\n                remote_id,\n                fs.clone(),\n                cx,\n            );\n            lsp_store.set_language_server_statuses_from_proto(response.payload.language_servers);\n            lsp_store\n        })?;\n\n        let task_store = cx.new(|cx| {\n            if run_tasks {\n                TaskStore::remote(\n                    fs.clone(),\n                    buffer_store.downgrade(),\n                    worktree_store.clone(),\n                    Arc::new(EmptyToolchainStore),\n                    client.clone().into(),\n                    remote_id,\n                    cx,\n                )\n            } else {\n                TaskStore::Noop\n            }\n        })?;\n\n        let settings_observer = cx.new(|cx| {\n            SettingsObserver::new_remote(worktree_store.clone(), task_store.clone(), cx)\n        })?;\n\n        let git_state = cx.new(|cx| {\n            GitState::new(\n                &worktree_store,\n                Some(client.clone().into()),\n                Some(ProjectId(remote_id)),\n                cx,\n            )\n        })?;\n\n        let this = cx.new(|cx| {\n            let replica_id = response.payload.replica_id as ReplicaId;\n\n            let snippets = SnippetProvider::new(fs.clone(), BTreeSet::from_iter([]), cx);\n\n            let mut worktrees = Vec::new();\n            for worktree in response.payload.worktrees {\n                let worktree =\n                    Worktree::remote(remote_id, replica_id, worktree, client.clone().into(), cx);\n                worktrees.push(worktree);\n            }\n\n            let (tx, rx) = mpsc::unbounded();\n            cx.spawn(move |this, cx| Self::send_buffer_ordered_messages(this, rx, cx))\n                .detach();\n\n            cx.subscribe(&worktree_store, Self::on_worktree_store_event)\n                .detach();\n\n            cx.subscribe(&buffer_store, Self::on_buffer_store_event)\n                .detach();\n            cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n            cx.subscribe(&settings_observer, Self::on_settings_observer_event)\n                .detach();\n\n            let mut this = Self {\n                buffer_ordered_messages_tx: tx,\n                buffer_store: buffer_store.clone(),\n                image_store,\n                worktree_store: worktree_store.clone(),\n                lsp_store: lsp_store.clone(),\n                active_entry: None,\n                collaborators: Default::default(),\n                join_project_response_message_id: response.message_id,\n                languages,\n                user_store: user_store.clone(),\n                task_store,\n                snippets,\n                fs,\n                ssh_client: None,\n                settings_observer: settings_observer.clone(),\n                client_subscriptions: Default::default(),\n                _subscriptions: vec![cx.on_release(Self::release)],\n                client: client.clone(),\n                client_state: ProjectClientState::Remote {\n                    sharing_has_stopped: false,\n                    capability: Capability::ReadWrite,\n                    remote_id,\n                    replica_id,\n                },\n                git_state,\n                buffers_needing_diff: Default::default(),\n                git_diff_debouncer: DebouncedDelay::new(),\n                terminals: Terminals {\n                    local_handles: Vec::new(),\n                },\n                node: None,\n                search_history: Self::new_search_history(),\n                search_included_history: Self::new_search_history(),\n                search_excluded_history: Self::new_search_history(),\n                environment: ProjectEnvironment::new(&worktree_store, None, cx),\n                remotely_created_models: Arc::new(Mutex::new(RemotelyCreatedModels::default())),\n                toolchain_store: None,\n            };\n            this.set_role(role, cx);\n            for worktree in worktrees {\n                this.add_worktree(&worktree, cx);\n            }\n            this\n        })?;\n\n        let subscriptions = subscriptions\n            .into_iter()\n            .map(|s| match s {\n                EntitySubscription::BufferStore(subscription) => {\n                    subscription.set_entity(&buffer_store, &mut cx)\n                }\n                EntitySubscription::WorktreeStore(subscription) => {\n                    subscription.set_entity(&worktree_store, &mut cx)\n                }\n                EntitySubscription::SettingsObserver(subscription) => {\n                    subscription.set_entity(&settings_observer, &mut cx)\n                }\n                EntitySubscription::Project(subscription) => {\n                    subscription.set_entity(&this, &mut cx)\n                }\n                EntitySubscription::LspStore(subscription) => {\n                    subscription.set_entity(&lsp_store, &mut cx)\n                }\n            })\n            .collect::<Vec<_>>();\n\n        let user_ids = response\n            .payload\n            .collaborators\n            .iter()\n            .map(|peer| peer.user_id)\n            .collect();\n        user_store\n            .update(&mut cx, |user_store, cx| user_store.get_users(user_ids, cx))?\n            .await?;\n\n        this.update(&mut cx, |this, cx| {\n            this.set_collaborators_from_proto(response.payload.collaborators, cx)?;\n            this.client_subscriptions.extend(subscriptions);\n            anyhow::Ok(())\n        })??;\n\n        Ok(this)\n    }\n\n    fn new_search_history() -> SearchHistory {\n        SearchHistory::new(\n            Some(MAX_PROJECT_SEARCH_HISTORY_SIZE),\n            search_history::QueryInsertionBehavior::AlwaysInsert,\n        )\n    }\n\n    fn release(&mut self, cx: &mut App) {\n        if let Some(client) = self.ssh_client.take() {\n            let shutdown = client\n                .read(cx)\n                .shutdown_processes(Some(proto::ShutdownRemoteServer {}));\n\n            cx.background_executor()\n                .spawn(async move {\n                    if let Some(shutdown) = shutdown {\n                        shutdown.await;\n                    }\n                })\n                .detach()\n        }\n\n        match &self.client_state {\n            ProjectClientState::Local => {}\n            ProjectClientState::Shared { .. } => {\n                let _ = self.unshare_internal(cx);\n            }\n            ProjectClientState::Remote { remote_id, .. } => {\n                let _ = self.client.send(proto::LeaveProject {\n                    project_id: *remote_id,\n                });\n                self.disconnected_from_host_internal(cx);\n            }\n        }\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub async fn example(\n        root_paths: impl IntoIterator<Item = &Path>,\n        cx: &mut AsyncApp,\n    ) -> Entity<Project> {\n        use clock::FakeSystemClock;\n\n        let fs = Arc::new(RealFs::default());\n        let languages = LanguageRegistry::test(cx.background_executor().clone());\n        let clock = Arc::new(FakeSystemClock::new());\n        let http_client = http_client::FakeHttpClient::with_404_response();\n        let client = cx\n            .update(|cx| client::Client::new(clock, http_client.clone(), cx))\n            .unwrap();\n        let user_store = cx.new(|cx| UserStore::new(client.clone(), cx)).unwrap();\n        let project = cx\n            .update(|cx| {\n                Project::local(\n                    client,\n                    node_runtime::NodeRuntime::unavailable(),\n                    user_store,\n                    Arc::new(languages),\n                    fs,\n                    None,\n                    cx,\n                )\n            })\n            .unwrap();\n        for path in root_paths {\n            let (tree, _) = project\n                .update(cx, |project, cx| {\n                    project.find_or_create_worktree(path, true, cx)\n                })\n                .unwrap()\n                .await\n                .unwrap();\n            tree.update(cx, |tree, _| tree.as_local().unwrap().scan_complete())\n                .unwrap()\n                .await;\n        }\n        project\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub async fn test(\n        fs: Arc<dyn Fs>,\n        root_paths: impl IntoIterator<Item = &Path>,\n        cx: &mut gpui::TestAppContext,\n    ) -> Entity<Project> {\n        use clock::FakeSystemClock;\n\n        let languages = LanguageRegistry::test(cx.executor());\n        let clock = Arc::new(FakeSystemClock::new());\n        let http_client = http_client::FakeHttpClient::with_404_response();\n        let client = cx.update(|cx| client::Client::new(clock, http_client.clone(), cx));\n        let user_store = cx.new(|cx| UserStore::new(client.clone(), cx));\n        let project = cx.update(|cx| {\n            Project::local(\n                client,\n                node_runtime::NodeRuntime::unavailable(),\n                user_store,\n                Arc::new(languages),\n                fs,\n                None,\n                cx,\n            )\n        });\n        for path in root_paths {\n            let (tree, _) = project\n                .update(cx, |project, cx| {\n                    project.find_or_create_worktree(path, true, cx)\n                })\n                .await\n                .unwrap();\n\n            tree.update(cx, |tree, _| tree.as_local().unwrap().scan_complete())\n                .await;\n        }\n        project\n    }\n\n    pub fn lsp_store(&self) -> Entity<LspStore> {\n        self.lsp_store.clone()\n    }\n\n    pub fn worktree_store(&self) -> Entity<WorktreeStore> {\n        self.worktree_store.clone()\n    }\n\n    pub fn buffer_for_id(&self, remote_id: BufferId, cx: &App) -> Option<Entity<Buffer>> {\n        self.buffer_store.read(cx).get(remote_id)\n    }\n\n    pub fn languages(&self) -> &Arc<LanguageRegistry> {\n        &self.languages\n    }\n\n    pub fn client(&self) -> Arc<Client> {\n        self.client.clone()\n    }\n\n    pub fn ssh_client(&self) -> Option<Entity<SshRemoteClient>> {\n        self.ssh_client.clone()\n    }\n\n    pub fn user_store(&self) -> Entity<UserStore> {\n        self.user_store.clone()\n    }\n\n    pub fn node_runtime(&self) -> Option<&NodeRuntime> {\n        self.node.as_ref()\n    }\n\n    pub fn opened_buffers(&self, cx: &App) -> Vec<Entity<Buffer>> {\n        self.buffer_store.read(cx).buffers().collect()\n    }\n\n    pub fn environment(&self) -> &Entity<ProjectEnvironment> {\n        &self.environment\n    }\n\n    pub fn cli_environment(&self, cx: &App) -> Option<HashMap<String, String>> {\n        self.environment.read(cx).get_cli_environment()\n    }\n\n    pub fn shell_environment_errors<'a>(\n        &'a self,\n        cx: &'a App,\n    ) -> impl Iterator<Item = (&'a WorktreeId, &'a EnvironmentErrorMessage)> {\n        self.environment.read(cx).environment_errors()\n    }\n\n    pub fn remove_environment_error(&mut self, cx: &mut Context<Self>, worktree_id: WorktreeId) {\n        self.environment.update(cx, |environment, _| {\n            environment.remove_environment_error(worktree_id);\n        });\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn has_open_buffer(&self, path: impl Into<ProjectPath>, cx: &App) -> bool {\n        self.buffer_store\n            .read(cx)\n            .get_by_path(&path.into(), cx)\n            .is_some()\n    }\n\n    pub fn fs(&self) -> &Arc<dyn Fs> {\n        &self.fs\n    }\n\n    pub fn remote_id(&self) -> Option<u64> {\n        match self.client_state {\n            ProjectClientState::Local => None,\n            ProjectClientState::Shared { remote_id, .. }\n            | ProjectClientState::Remote { remote_id, .. } => Some(remote_id),\n        }\n    }\n\n    pub fn supports_terminal(&self, _cx: &App) -> bool {\n        if self.is_local() {\n            return true;\n        }\n        if self.is_via_ssh() {\n            return true;\n        }\n\n        return false;\n    }\n\n    pub fn ssh_connection_string(&self, cx: &App) -> Option<SharedString> {\n        if let Some(ssh_state) = &self.ssh_client {\n            return Some(ssh_state.read(cx).connection_string().into());\n        }\n\n        return None;\n    }\n\n    pub fn ssh_connection_state(&self, cx: &App) -> Option<remote::ConnectionState> {\n        self.ssh_client\n            .as_ref()\n            .map(|ssh| ssh.read(cx).connection_state())\n    }\n\n    pub fn ssh_connection_options(&self, cx: &App) -> Option<SshConnectionOptions> {\n        self.ssh_client\n            .as_ref()\n            .map(|ssh| ssh.read(cx).connection_options())\n    }\n\n    pub fn replica_id(&self) -> ReplicaId {\n        match self.client_state {\n            ProjectClientState::Remote { replica_id, .. } => replica_id,\n            _ => {\n                if self.ssh_client.is_some() {\n                    1\n                } else {\n                    0\n                }\n            }\n        }\n    }\n\n    pub fn task_store(&self) -> &Entity<TaskStore> {\n        &self.task_store\n    }\n\n    pub fn snippets(&self) -> &Entity<SnippetProvider> {\n        &self.snippets\n    }\n\n    pub fn search_history(&self, kind: SearchInputKind) -> &SearchHistory {\n        match kind {\n            SearchInputKind::Query => &self.search_history,\n            SearchInputKind::Include => &self.search_included_history,\n            SearchInputKind::Exclude => &self.search_excluded_history,\n        }\n    }\n\n    pub fn search_history_mut(&mut self, kind: SearchInputKind) -> &mut SearchHistory {\n        match kind {\n            SearchInputKind::Query => &mut self.search_history,\n            SearchInputKind::Include => &mut self.search_included_history,\n            SearchInputKind::Exclude => &mut self.search_excluded_history,\n        }\n    }\n\n    pub fn collaborators(&self) -> &HashMap<proto::PeerId, Collaborator> {\n        &self.collaborators\n    }\n\n    pub fn host(&self) -> Option<&Collaborator> {\n        self.collaborators.values().find(|c| c.is_host)\n    }\n\n    pub fn set_worktrees_reordered(&mut self, worktrees_reordered: bool, cx: &mut App) {\n        self.worktree_store.update(cx, |store, _| {\n            store.set_worktrees_reordered(worktrees_reordered);\n        });\n    }\n\n    /// Collect all worktrees, including ones that don't appear in the project panel\n    pub fn worktrees<'a>(\n        &self,\n        cx: &'a App,\n    ) -> impl 'a + DoubleEndedIterator<Item = Entity<Worktree>> {\n        self.worktree_store.read(cx).worktrees()\n    }\n\n    /// Collect all user-visible worktrees, the ones that appear in the project panel.\n    pub fn visible_worktrees<'a>(\n        &'a self,\n        cx: &'a App,\n    ) -> impl 'a + DoubleEndedIterator<Item = Entity<Worktree>> {\n        self.worktree_store.read(cx).visible_worktrees(cx)\n    }\n\n    pub fn worktree_root_names<'a>(&'a self, cx: &'a App) -> impl Iterator<Item = &'a str> {\n        self.visible_worktrees(cx)\n            .map(|tree| tree.read(cx).root_name())\n    }\n\n    pub fn worktree_for_id(&self, id: WorktreeId, cx: &App) -> Option<Entity<Worktree>> {\n        self.worktree_store.read(cx).worktree_for_id(id, cx)\n    }\n\n    pub fn worktree_for_entry(\n        &self,\n        entry_id: ProjectEntryId,\n        cx: &App,\n    ) -> Option<Entity<Worktree>> {\n        self.worktree_store\n            .read(cx)\n            .worktree_for_entry(entry_id, cx)\n    }\n\n    pub fn worktree_id_for_entry(&self, entry_id: ProjectEntryId, cx: &App) -> Option<WorktreeId> {\n        self.worktree_for_entry(entry_id, cx)\n            .map(|worktree| worktree.read(cx).id())\n    }\n\n    /// Checks if the entry is the root of a worktree.\n    pub fn entry_is_worktree_root(&self, entry_id: ProjectEntryId, cx: &App) -> bool {\n        self.worktree_for_entry(entry_id, cx)\n            .map(|worktree| {\n                worktree\n                    .read(cx)\n                    .root_entry()\n                    .is_some_and(|e| e.id == entry_id)\n            })\n            .unwrap_or(false)\n    }\n\n    pub fn project_path_git_status(\n        &self,\n        project_path: &ProjectPath,\n        cx: &App,\n    ) -> Option<FileStatus> {\n        self.worktree_for_id(project_path.worktree_id, cx)\n            .and_then(|worktree| worktree.read(cx).status_for_file(&project_path.path))\n    }\n\n    pub fn visibility_for_paths(&self, paths: &[PathBuf], cx: &App) -> Option<bool> {\n        paths\n            .iter()\n            .map(|path| self.visibility_for_path(path, cx))\n            .max()\n            .flatten()\n    }\n\n    pub fn visibility_for_path(&self, path: &Path, cx: &App) -> Option<bool> {\n        self.worktrees(cx)\n            .filter_map(|worktree| {\n                let worktree = worktree.read(cx);\n                worktree\n                    .as_local()?\n                    .contains_abs_path(path)\n                    .then(|| worktree.is_visible())\n            })\n            .max()\n    }\n\n    pub fn create_entry(\n        &mut self,\n        project_path: impl Into<ProjectPath>,\n        is_directory: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<CreatedEntry>> {\n        let project_path = project_path.into();\n        let Some(worktree) = self.worktree_for_id(project_path.worktree_id, cx) else {\n            return Task::ready(Err(anyhow!(format!(\n                \"No worktree for path {project_path:?}\"\n            ))));\n        };\n        worktree.update(cx, |worktree, cx| {\n            worktree.create_entry(project_path.path, is_directory, cx)\n        })\n    }\n\n    pub fn copy_entry(\n        &mut self,\n        entry_id: ProjectEntryId,\n        relative_worktree_source_path: Option<PathBuf>,\n        new_path: impl Into<Arc<Path>>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Option<Entry>>> {\n        let Some(worktree) = self.worktree_for_entry(entry_id, cx) else {\n            return Task::ready(Ok(None));\n        };\n        worktree.update(cx, |worktree, cx| {\n            worktree.copy_entry(entry_id, relative_worktree_source_path, new_path, cx)\n        })\n    }\n\n    /// Renames the project entry with given `entry_id`.\n    ///\n    /// `new_path` is a relative path to worktree root.\n    /// If root entry is renamed then its new root name is used instead.\n    pub fn rename_entry(\n        &mut self,\n        entry_id: ProjectEntryId,\n        new_path: impl Into<Arc<Path>>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<CreatedEntry>> {\n        let worktree_store = self.worktree_store.read(cx);\n        let new_path = new_path.into();\n        let Some((worktree, old_path, is_dir)) = worktree_store\n            .worktree_and_entry_for_id(entry_id, cx)\n            .map(|(worktree, entry)| (worktree, entry.path.clone(), entry.is_dir()))\n        else {\n            return Task::ready(Err(anyhow!(format!(\"No worktree for entry {entry_id:?}\"))));\n        };\n\n        let worktree_id = worktree.read(cx).id();\n        let is_root_entry = self.entry_is_worktree_root(entry_id, cx);\n\n        let lsp_store = self.lsp_store().downgrade();\n        cx.spawn(|_, mut cx| async move {\n            let (old_abs_path, new_abs_path) = {\n                let root_path = worktree.update(&mut cx, |this, _| this.abs_path())?;\n                let new_abs_path = if is_root_entry {\n                    root_path.parent().unwrap().join(&new_path)\n                } else {\n                    root_path.join(&new_path)\n                };\n                (root_path.join(&old_path), new_abs_path)\n            };\n            LspStore::will_rename_entry(\n                lsp_store.clone(),\n                worktree_id,\n                &old_abs_path,\n                &new_abs_path,\n                is_dir,\n                cx.clone(),\n            )\n            .await;\n\n            let entry = worktree\n                .update(&mut cx, |worktree, cx| {\n                    worktree.rename_entry(entry_id, new_path.clone(), cx)\n                })?\n                .await?;\n\n            lsp_store\n                .update(&mut cx, |this, _| {\n                    this.did_rename_entry(worktree_id, &old_abs_path, &new_abs_path, is_dir);\n                })\n                .ok();\n            Ok(entry)\n        })\n    }\n\n    pub fn delete_entry(\n        &mut self,\n        entry_id: ProjectEntryId,\n        trash: bool,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let worktree = self.worktree_for_entry(entry_id, cx)?;\n        cx.emit(Event::DeletedEntry(worktree.read(cx).id(), entry_id));\n        worktree.update(cx, |worktree, cx| {\n            worktree.delete_entry(entry_id, trash, cx)\n        })\n    }\n\n    pub fn expand_entry(\n        &mut self,\n        worktree_id: WorktreeId,\n        entry_id: ProjectEntryId,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let worktree = self.worktree_for_id(worktree_id, cx)?;\n        worktree.update(cx, |worktree, cx| worktree.expand_entry(entry_id, cx))\n    }\n\n    pub fn expand_all_for_entry(\n        &mut self,\n        worktree_id: WorktreeId,\n        entry_id: ProjectEntryId,\n        cx: &mut Context<Self>,\n    ) -> Option<Task<Result<()>>> {\n        let worktree = self.worktree_for_id(worktree_id, cx)?;\n        let task = worktree.update(cx, |worktree, cx| {\n            worktree.expand_all_for_entry(entry_id, cx)\n        });\n        Some(cx.spawn(|this, mut cx| async move {\n            task.ok_or_else(|| anyhow!(\"no task\"))?.await?;\n            this.update(&mut cx, |_, cx| {\n                cx.emit(Event::ExpandedAllForEntry(worktree_id, entry_id));\n            })?;\n            Ok(())\n        }))\n    }\n\n    pub fn shared(&mut self, project_id: u64, cx: &mut Context<Self>) -> Result<()> {\n        if !matches!(self.client_state, ProjectClientState::Local) {\n            return Err(anyhow!(\"project was already shared\"));\n        }\n\n        self.client_subscriptions.extend([\n            self.client\n                .subscribe_to_entity(project_id)?\n                .set_entity(&cx.entity(), &mut cx.to_async()),\n            self.client\n                .subscribe_to_entity(project_id)?\n                .set_entity(&self.worktree_store, &mut cx.to_async()),\n            self.client\n                .subscribe_to_entity(project_id)?\n                .set_entity(&self.buffer_store, &mut cx.to_async()),\n            self.client\n                .subscribe_to_entity(project_id)?\n                .set_entity(&self.lsp_store, &mut cx.to_async()),\n            self.client\n                .subscribe_to_entity(project_id)?\n                .set_entity(&self.settings_observer, &mut cx.to_async()),\n        ]);\n\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.shared(project_id, self.client.clone().into(), cx)\n        });\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.shared(project_id, self.client.clone().into(), cx);\n        });\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.shared(project_id, self.client.clone().into(), cx)\n        });\n        self.task_store.update(cx, |task_store, cx| {\n            task_store.shared(project_id, self.client.clone().into(), cx);\n        });\n        self.settings_observer.update(cx, |settings_observer, cx| {\n            settings_observer.shared(project_id, self.client.clone().into(), cx)\n        });\n\n        self.client_state = ProjectClientState::Shared {\n            remote_id: project_id,\n        };\n\n        cx.emit(Event::RemoteIdChanged(Some(project_id)));\n        cx.notify();\n        Ok(())\n    }\n\n    pub fn reshared(\n        &mut self,\n        message: proto::ResharedProject,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        self.buffer_store\n            .update(cx, |buffer_store, _| buffer_store.forget_shared_buffers());\n        self.set_collaborators_from_proto(message.collaborators, cx)?;\n\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.send_project_updates(cx);\n        });\n        cx.notify();\n        cx.emit(Event::Reshared);\n        Ok(())\n    }\n\n    pub fn rejoined(\n        &mut self,\n        message: proto::RejoinedProject,\n        message_id: u32,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        cx.update_global::<SettingsStore, _>(|store, cx| {\n            self.worktree_store.update(cx, |worktree_store, cx| {\n                for worktree in worktree_store.worktrees() {\n                    store\n                        .clear_local_settings(worktree.read(cx).id(), cx)\n                        .log_err();\n                }\n            });\n        });\n\n        self.join_project_response_message_id = message_id;\n        self.set_worktrees_from_proto(message.worktrees, cx)?;\n        self.set_collaborators_from_proto(message.collaborators, cx)?;\n        self.lsp_store.update(cx, |lsp_store, _| {\n            lsp_store.set_language_server_statuses_from_proto(message.language_servers)\n        });\n        self.enqueue_buffer_ordered_message(BufferOrderedMessage::Resync)\n            .unwrap();\n        cx.emit(Event::Rejoined);\n        cx.notify();\n        Ok(())\n    }\n\n    pub fn unshare(&mut self, cx: &mut Context<Self>) -> Result<()> {\n        self.unshare_internal(cx)?;\n        cx.notify();\n        Ok(())\n    }\n\n    fn unshare_internal(&mut self, cx: &mut App) -> Result<()> {\n        if self.is_via_collab() {\n            return Err(anyhow!(\"attempted to unshare a remote project\"));\n        }\n\n        if let ProjectClientState::Shared { remote_id, .. } = self.client_state {\n            self.client_state = ProjectClientState::Local;\n            self.collaborators.clear();\n            self.client_subscriptions.clear();\n            self.worktree_store.update(cx, |store, cx| {\n                store.unshared(cx);\n            });\n            self.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.forget_shared_buffers();\n                buffer_store.unshared(cx)\n            });\n            self.task_store.update(cx, |task_store, cx| {\n                task_store.unshared(cx);\n            });\n            self.settings_observer.update(cx, |settings_observer, cx| {\n                settings_observer.unshared(cx);\n            });\n\n            self.client\n                .send(proto::UnshareProject {\n                    project_id: remote_id,\n                })\n                .ok();\n            Ok(())\n        } else {\n            Err(anyhow!(\"attempted to unshare an unshared project\"))\n        }\n    }\n\n    pub fn disconnected_from_host(&mut self, cx: &mut Context<Self>) {\n        if self.is_disconnected(cx) {\n            return;\n        }\n        self.disconnected_from_host_internal(cx);\n        cx.emit(Event::DisconnectedFromHost);\n        cx.notify();\n    }\n\n    pub fn set_role(&mut self, role: proto::ChannelRole, cx: &mut Context<Self>) {\n        let new_capability =\n            if role == proto::ChannelRole::Member || role == proto::ChannelRole::Admin {\n                Capability::ReadWrite\n            } else {\n                Capability::ReadOnly\n            };\n        if let ProjectClientState::Remote { capability, .. } = &mut self.client_state {\n            if *capability == new_capability {\n                return;\n            }\n\n            *capability = new_capability;\n            for buffer in self.opened_buffers(cx) {\n                buffer.update(cx, |buffer, cx| buffer.set_capability(new_capability, cx));\n            }\n        }\n    }\n\n    fn disconnected_from_host_internal(&mut self, cx: &mut App) {\n        if let ProjectClientState::Remote {\n            sharing_has_stopped,\n            ..\n        } = &mut self.client_state\n        {\n            *sharing_has_stopped = true;\n            self.collaborators.clear();\n            self.worktree_store.update(cx, |store, cx| {\n                store.disconnected_from_host(cx);\n            });\n            self.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.disconnected_from_host(cx)\n            });\n            self.lsp_store\n                .update(cx, |lsp_store, _cx| lsp_store.disconnected_from_host());\n        }\n    }\n\n    pub fn close(&mut self, cx: &mut Context<Self>) {\n        cx.emit(Event::Closed);\n    }\n\n    pub fn is_disconnected(&self, cx: &App) -> bool {\n        match &self.client_state {\n            ProjectClientState::Remote {\n                sharing_has_stopped,\n                ..\n            } => *sharing_has_stopped,\n            ProjectClientState::Local if self.is_via_ssh() => self.ssh_is_disconnected(cx),\n            _ => false,\n        }\n    }\n\n    fn ssh_is_disconnected(&self, cx: &App) -> bool {\n        self.ssh_client\n            .as_ref()\n            .map(|ssh| ssh.read(cx).is_disconnected())\n            .unwrap_or(false)\n    }\n\n    pub fn capability(&self) -> Capability {\n        match &self.client_state {\n            ProjectClientState::Remote { capability, .. } => *capability,\n            ProjectClientState::Shared { .. } | ProjectClientState::Local => Capability::ReadWrite,\n        }\n    }\n\n    pub fn is_read_only(&self, cx: &App) -> bool {\n        self.is_disconnected(cx) || self.capability() == Capability::ReadOnly\n    }\n\n    pub fn is_local(&self) -> bool {\n        match &self.client_state {\n            ProjectClientState::Local | ProjectClientState::Shared { .. } => {\n                self.ssh_client.is_none()\n            }\n            ProjectClientState::Remote { .. } => false,\n        }\n    }\n\n    pub fn is_via_ssh(&self) -> bool {\n        match &self.client_state {\n            ProjectClientState::Local | ProjectClientState::Shared { .. } => {\n                self.ssh_client.is_some()\n            }\n            ProjectClientState::Remote { .. } => false,\n        }\n    }\n\n    pub fn is_via_collab(&self) -> bool {\n        match &self.client_state {\n            ProjectClientState::Local | ProjectClientState::Shared { .. } => false,\n            ProjectClientState::Remote { .. } => true,\n        }\n    }\n\n    pub fn create_buffer(&mut self, cx: &mut Context<Self>) -> Task<Result<Entity<Buffer>>> {\n        self.buffer_store\n            .update(cx, |buffer_store, cx| buffer_store.create_buffer(cx))\n    }\n\n    pub fn create_local_buffer(\n        &mut self,\n        text: &str,\n        language: Option<Arc<Language>>,\n        cx: &mut Context<Self>,\n    ) -> Entity<Buffer> {\n        if self.is_via_collab() || self.is_via_ssh() {\n            panic!(\"called create_local_buffer on a remote project\")\n        }\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.create_local_buffer(text, language, cx)\n        })\n    }\n\n    pub fn open_path(\n        &mut self,\n        path: ProjectPath,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<(Option<ProjectEntryId>, AnyEntity)>> {\n        let task = self.open_buffer(path.clone(), cx);\n        cx.spawn(move |_, cx| async move {\n            let buffer = task.await?;\n            let project_entry_id = buffer.read_with(&cx, |buffer, cx| {\n                File::from_dyn(buffer.file()).and_then(|file| file.project_entry_id(cx))\n            })?;\n\n            let buffer: &AnyEntity = &buffer;\n            Ok((project_entry_id, buffer.clone()))\n        })\n    }\n\n    pub fn open_local_buffer(\n        &mut self,\n        abs_path: impl AsRef<Path>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        if let Some((worktree, relative_path)) = self.find_worktree(abs_path.as_ref(), cx) {\n            self.open_buffer((worktree.read(cx).id(), relative_path), cx)\n        } else {\n            Task::ready(Err(anyhow!(\"no such path\")))\n        }\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn open_local_buffer_with_lsp(\n        &mut self,\n        abs_path: impl AsRef<Path>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<(Entity<Buffer>, lsp_store::OpenLspBufferHandle)>> {\n        if let Some((worktree, relative_path)) = self.find_worktree(abs_path.as_ref(), cx) {\n            self.open_buffer_with_lsp((worktree.read(cx).id(), relative_path), cx)\n        } else {\n            Task::ready(Err(anyhow!(\"no such path\")))\n        }\n    }\n\n    pub fn open_buffer(\n        &mut self,\n        path: impl Into<ProjectPath>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.open_buffer(path.into(), cx)\n        })\n    }\n\n    #[cfg(any(test, feature = \"test-support\"))]\n    pub fn open_buffer_with_lsp(\n        &mut self,\n        path: impl Into<ProjectPath>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<(Entity<Buffer>, lsp_store::OpenLspBufferHandle)>> {\n        let buffer = self.open_buffer(path, cx);\n        let lsp_store = self.lsp_store().clone();\n        cx.spawn(|_, mut cx| async move {\n            let buffer = buffer.await?;\n            let handle = lsp_store.update(&mut cx, |lsp_store, cx| {\n                lsp_store.register_buffer_with_language_servers(&buffer, cx)\n            })?;\n            Ok((buffer, handle))\n        })\n    }\n\n    pub fn open_unstaged_diff(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<BufferDiff>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.open_unstaged_diff(buffer, cx)\n        })\n    }\n\n    pub fn open_uncommitted_diff(\n        &mut self,\n        buffer: Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<BufferDiff>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.open_uncommitted_diff(buffer, cx)\n        })\n    }\n\n    pub fn open_buffer_by_id(\n        &mut self,\n        id: BufferId,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        if let Some(buffer) = self.buffer_for_id(id, cx) {\n            Task::ready(Ok(buffer))\n        } else if self.is_local() || self.is_via_ssh() {\n            Task::ready(Err(anyhow!(\"buffer {} does not exist\", id)))\n        } else if let Some(project_id) = self.remote_id() {\n            let request = self.client.request(proto::OpenBufferById {\n                project_id,\n                id: id.into(),\n            });\n            cx.spawn(move |project, mut cx| async move {\n                let buffer_id = BufferId::new(request.await?.buffer_id)?;\n                project\n                    .update(&mut cx, |project, cx| {\n                        project.buffer_store.update(cx, |buffer_store, cx| {\n                            buffer_store.wait_for_remote_buffer(buffer_id, cx)\n                        })\n                    })?\n                    .await\n            })\n        } else {\n            Task::ready(Err(anyhow!(\"cannot open buffer while disconnected\")))\n        }\n    }\n\n    pub fn save_buffers(\n        &self,\n        buffers: HashSet<Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        cx.spawn(move |this, mut cx| async move {\n            let save_tasks = buffers.into_iter().filter_map(|buffer| {\n                this.update(&mut cx, |this, cx| this.save_buffer(buffer, cx))\n                    .ok()\n            });\n            try_join_all(save_tasks).await?;\n            Ok(())\n        })\n    }\n\n    pub fn save_buffer(&self, buffer: Entity<Buffer>, cx: &mut Context<Self>) -> Task<Result<()>> {\n        self.buffer_store\n            .update(cx, |buffer_store, cx| buffer_store.save_buffer(buffer, cx))\n    }\n\n    pub fn save_buffer_as(\n        &mut self,\n        buffer: Entity<Buffer>,\n        path: ProjectPath,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.save_buffer_as(buffer.clone(), path, cx)\n        })\n    }\n\n    pub fn get_open_buffer(&self, path: &ProjectPath, cx: &App) -> Option<Entity<Buffer>> {\n        self.buffer_store.read(cx).get_by_path(path, cx)\n    }\n\n    fn register_buffer(&mut self, buffer: &Entity<Buffer>, cx: &mut Context<Self>) -> Result<()> {\n        {\n            let mut remotely_created_models = self.remotely_created_models.lock();\n            if remotely_created_models.retain_count > 0 {\n                remotely_created_models.buffers.push(buffer.clone())\n            }\n        }\n\n        self.request_buffer_diff_recalculation(buffer, cx);\n\n        cx.subscribe(buffer, |this, buffer, event, cx| {\n            this.on_buffer_event(buffer, event, cx);\n        })\n        .detach();\n\n        Ok(())\n    }\n\n    pub fn open_image(\n        &mut self,\n        path: impl Into<ProjectPath>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<ImageItem>>> {\n        if self.is_disconnected(cx) {\n            return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n        }\n\n        let open_image_task = self.image_store.update(cx, |image_store, cx| {\n            image_store.open_image(path.into(), cx)\n        });\n\n        let weak_project = cx.entity().downgrade();\n        cx.spawn(move |_, mut cx| async move {\n            let image_item = open_image_task.await?;\n            let project = weak_project\n                .upgrade()\n                .ok_or_else(|| anyhow!(\"Project dropped\"))?;\n\n            let metadata =\n                ImageItem::load_image_metadata(image_item.clone(), project, &mut cx).await?;\n            image_item.update(&mut cx, |image_item, cx| {\n                image_item.image_metadata = Some(metadata);\n                cx.emit(ImageItemEvent::MetadataUpdated);\n            })?;\n\n            Ok(image_item)\n        })\n    }\n\n    async fn send_buffer_ordered_messages(\n        this: WeakEntity<Self>,\n        rx: UnboundedReceiver<BufferOrderedMessage>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        const MAX_BATCH_SIZE: usize = 128;\n\n        let mut operations_by_buffer_id = HashMap::default();\n        async fn flush_operations(\n            this: &WeakEntity<Project>,\n            operations_by_buffer_id: &mut HashMap<BufferId, Vec<proto::Operation>>,\n            needs_resync_with_host: &mut bool,\n            is_local: bool,\n            cx: &mut AsyncApp,\n        ) -> Result<()> {\n            for (buffer_id, operations) in operations_by_buffer_id.drain() {\n                let request = this.update(cx, |this, _| {\n                    let project_id = this.remote_id()?;\n                    Some(this.client.request(proto::UpdateBuffer {\n                        buffer_id: buffer_id.into(),\n                        project_id,\n                        operations,\n                    }))\n                })?;\n                if let Some(request) = request {\n                    if request.await.is_err() && !is_local {\n                        *needs_resync_with_host = true;\n                        break;\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        let mut needs_resync_with_host = false;\n        let mut changes = rx.ready_chunks(MAX_BATCH_SIZE);\n\n        while let Some(changes) = changes.next().await {\n            let is_local = this.update(&mut cx, |this, _| this.is_local())?;\n\n            for change in changes {\n                match change {\n                    BufferOrderedMessage::Operation {\n                        buffer_id,\n                        operation,\n                    } => {\n                        if needs_resync_with_host {\n                            continue;\n                        }\n\n                        operations_by_buffer_id\n                            .entry(buffer_id)\n                            .or_insert(Vec::new())\n                            .push(operation);\n                    }\n\n                    BufferOrderedMessage::Resync => {\n                        operations_by_buffer_id.clear();\n                        if this\n                            .update(&mut cx, |this, cx| this.synchronize_remote_buffers(cx))?\n                            .await\n                            .is_ok()\n                        {\n                            needs_resync_with_host = false;\n                        }\n                    }\n\n                    BufferOrderedMessage::LanguageServerUpdate {\n                        language_server_id,\n                        message,\n                    } => {\n                        flush_operations(\n                            &this,\n                            &mut operations_by_buffer_id,\n                            &mut needs_resync_with_host,\n                            is_local,\n                            &mut cx,\n                        )\n                        .await?;\n\n                        this.update(&mut cx, |this, _| {\n                            if let Some(project_id) = this.remote_id() {\n                                this.client\n                                    .send(proto::UpdateLanguageServer {\n                                        project_id,\n                                        language_server_id: language_server_id.0 as u64,\n                                        variant: Some(message),\n                                    })\n                                    .log_err();\n                            }\n                        })?;\n                    }\n                }\n            }\n\n            flush_operations(\n                &this,\n                &mut operations_by_buffer_id,\n                &mut needs_resync_with_host,\n                is_local,\n                &mut cx,\n            )\n            .await?;\n        }\n\n        Ok(())\n    }\n\n    fn on_buffer_store_event(\n        &mut self,\n        _: Entity<BufferStore>,\n        event: &BufferStoreEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            BufferStoreEvent::BufferAdded(buffer) => {\n                self.register_buffer(buffer, cx).log_err();\n            }\n            BufferStoreEvent::BufferChangedFilePath { .. } => {}\n            BufferStoreEvent::BufferDropped(buffer_id) => {\n                if let Some(ref ssh_client) = self.ssh_client {\n                    ssh_client\n                        .read(cx)\n                        .proto_client()\n                        .send(proto::CloseBuffer {\n                            project_id: 0,\n                            buffer_id: buffer_id.to_proto(),\n                        })\n                        .log_err();\n                }\n            }\n        }\n    }\n\n    fn on_image_store_event(\n        &mut self,\n        _: Entity<ImageStore>,\n        event: &ImageStoreEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            ImageStoreEvent::ImageAdded(image) => {\n                cx.subscribe(image, |this, image, event, cx| {\n                    this.on_image_event(image, event, cx);\n                })\n                .detach();\n            }\n        }\n    }\n\n    fn on_lsp_store_event(\n        &mut self,\n        _: Entity<LspStore>,\n        event: &LspStoreEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            LspStoreEvent::DiagnosticsUpdated {\n                language_server_id,\n                path,\n            } => cx.emit(Event::DiagnosticsUpdated {\n                path: path.clone(),\n                language_server_id: *language_server_id,\n            }),\n            LspStoreEvent::LanguageServerAdded(language_server_id, name, worktree_id) => cx.emit(\n                Event::LanguageServerAdded(*language_server_id, name.clone(), *worktree_id),\n            ),\n            LspStoreEvent::LanguageServerRemoved(language_server_id) => {\n                cx.emit(Event::LanguageServerRemoved(*language_server_id))\n            }\n            LspStoreEvent::LanguageServerLog(server_id, log_type, string) => cx.emit(\n                Event::LanguageServerLog(*server_id, log_type.clone(), string.clone()),\n            ),\n            LspStoreEvent::LanguageDetected {\n                buffer,\n                new_language,\n            } => {\n                let Some(_) = new_language else {\n                    cx.emit(Event::LanguageNotFound(buffer.clone()));\n                    return;\n                };\n            }\n            LspStoreEvent::RefreshInlayHints => cx.emit(Event::RefreshInlayHints),\n            LspStoreEvent::LanguageServerPrompt(prompt) => {\n                cx.emit(Event::LanguageServerPrompt(prompt.clone()))\n            }\n            LspStoreEvent::DiskBasedDiagnosticsStarted { language_server_id } => {\n                cx.emit(Event::DiskBasedDiagnosticsStarted {\n                    language_server_id: *language_server_id,\n                });\n            }\n            LspStoreEvent::DiskBasedDiagnosticsFinished { language_server_id } => {\n                cx.emit(Event::DiskBasedDiagnosticsFinished {\n                    language_server_id: *language_server_id,\n                });\n            }\n            LspStoreEvent::LanguageServerUpdate {\n                language_server_id,\n                message,\n            } => {\n                if self.is_local() {\n                    self.enqueue_buffer_ordered_message(\n                        BufferOrderedMessage::LanguageServerUpdate {\n                            language_server_id: *language_server_id,\n                            message: message.clone(),\n                        },\n                    )\n                    .ok();\n                }\n            }\n            LspStoreEvent::Notification(message) => cx.emit(Event::Toast {\n                notification_id: \"lsp\".into(),\n                message: message.clone(),\n            }),\n            LspStoreEvent::SnippetEdit {\n                buffer_id,\n                edits,\n                most_recent_edit,\n            } => {\n                if most_recent_edit.replica_id == self.replica_id() {\n                    cx.emit(Event::SnippetEdit(*buffer_id, edits.clone()))\n                }\n            }\n        }\n    }\n\n    fn on_ssh_event(\n        &mut self,\n        _: Entity<SshRemoteClient>,\n        event: &remote::SshRemoteEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            remote::SshRemoteEvent::Disconnected => {\n                // if self.is_via_ssh() {\n                // self.collaborators.clear();\n                self.worktree_store.update(cx, |store, cx| {\n                    store.disconnected_from_host(cx);\n                });\n                self.buffer_store.update(cx, |buffer_store, cx| {\n                    buffer_store.disconnected_from_host(cx)\n                });\n                self.lsp_store.update(cx, |lsp_store, _cx| {\n                    lsp_store.disconnected_from_ssh_remote()\n                });\n                cx.emit(Event::DisconnectedFromSshRemote);\n            }\n        }\n    }\n\n    fn on_settings_observer_event(\n        &mut self,\n        _: Entity<SettingsObserver>,\n        event: &SettingsObserverEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            SettingsObserverEvent::LocalSettingsUpdated(result) => match result {\n                Err(InvalidSettingsError::LocalSettings { message, path }) => {\n                    let message =\n                        format!(\"Failed to set local settings in {:?}:\\n{}\", path, message);\n                    cx.emit(Event::Toast {\n                        notification_id: \"local-settings\".into(),\n                        message,\n                    });\n                }\n                Ok(_) => cx.emit(Event::HideToast {\n                    notification_id: \"local-settings\".into(),\n                }),\n                Err(_) => {}\n            },\n        }\n    }\n\n    fn on_worktree_store_event(\n        &mut self,\n        _: Entity<WorktreeStore>,\n        event: &WorktreeStoreEvent,\n        cx: &mut Context<Self>,\n    ) {\n        match event {\n            WorktreeStoreEvent::WorktreeAdded(worktree) => {\n                self.on_worktree_added(worktree, cx);\n                cx.emit(Event::WorktreeAdded(worktree.read(cx).id()));\n            }\n            WorktreeStoreEvent::WorktreeRemoved(_, id) => {\n                cx.emit(Event::WorktreeRemoved(*id));\n            }\n            WorktreeStoreEvent::WorktreeReleased(_, id) => {\n                self.on_worktree_released(*id, cx);\n            }\n            WorktreeStoreEvent::WorktreeOrderChanged => cx.emit(Event::WorktreeOrderChanged),\n            WorktreeStoreEvent::WorktreeUpdateSent(_) => {}\n            WorktreeStoreEvent::WorktreeUpdatedEntries(worktree_id, changes) => {\n                self.client()\n                    .telemetry()\n                    .report_discovered_project_events(*worktree_id, changes);\n                cx.emit(Event::WorktreeUpdatedEntries(*worktree_id, changes.clone()))\n            }\n            WorktreeStoreEvent::WorktreeUpdatedGitRepositories(worktree_id) => {\n                cx.emit(Event::WorktreeUpdatedGitRepositories(*worktree_id))\n            }\n            WorktreeStoreEvent::WorktreeDeletedEntry(worktree_id, id) => {\n                cx.emit(Event::DeletedEntry(*worktree_id, *id))\n            }\n        }\n    }\n\n    fn on_worktree_added(&mut self, worktree: &Entity<Worktree>, cx: &mut Context<Self>) {\n        {\n            let mut remotely_created_models = self.remotely_created_models.lock();\n            if remotely_created_models.retain_count > 0 {\n                remotely_created_models.worktrees.push(worktree.clone())\n            }\n        }\n        cx.observe(worktree, |_, _, cx| cx.notify()).detach();\n        cx.notify();\n    }\n\n    fn on_worktree_released(&mut self, id_to_remove: WorktreeId, cx: &mut Context<Self>) {\n        if let Some(ssh) = &self.ssh_client {\n            ssh.read(cx)\n                .proto_client()\n                .send(proto::RemoveWorktree {\n                    worktree_id: id_to_remove.to_proto(),\n                })\n                .log_err();\n        }\n\n        cx.notify();\n    }\n\n    fn on_buffer_event(\n        &mut self,\n        buffer: Entity<Buffer>,\n        event: &BufferEvent,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        if matches!(event, BufferEvent::Edited { .. } | BufferEvent::Reloaded) {\n            self.request_buffer_diff_recalculation(&buffer, cx);\n        }\n\n        let buffer_id = buffer.read(cx).remote_id();\n        match event {\n            BufferEvent::ReloadNeeded => {\n                if !self.is_via_collab() {\n                    self.reload_buffers([buffer.clone()].into_iter().collect(), true, cx)\n                        .detach_and_log_err(cx);\n                }\n            }\n            BufferEvent::Operation {\n                operation,\n                is_local: true,\n            } => {\n                let operation = language::proto::serialize_operation(operation);\n\n                if let Some(ssh) = &self.ssh_client {\n                    ssh.read(cx)\n                        .proto_client()\n                        .send(proto::UpdateBuffer {\n                            project_id: 0,\n                            buffer_id: buffer_id.to_proto(),\n                            operations: vec![operation.clone()],\n                        })\n                        .ok();\n                }\n\n                self.enqueue_buffer_ordered_message(BufferOrderedMessage::Operation {\n                    buffer_id,\n                    operation,\n                })\n                .ok();\n            }\n\n            _ => {}\n        }\n\n        None\n    }\n\n    fn on_image_event(\n        &mut self,\n        image: Entity<ImageItem>,\n        event: &ImageItemEvent,\n        cx: &mut Context<Self>,\n    ) -> Option<()> {\n        match event {\n            ImageItemEvent::ReloadNeeded => {\n                if !self.is_via_collab() {\n                    self.reload_images([image.clone()].into_iter().collect(), cx)\n                        .detach_and_log_err(cx);\n                }\n            }\n            _ => {}\n        }\n\n        None\n    }\n\n    fn request_buffer_diff_recalculation(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) {\n        self.buffers_needing_diff.insert(buffer.downgrade());\n        let first_insertion = self.buffers_needing_diff.len() == 1;\n\n        let settings = ProjectSettings::get_global(cx);\n        let delay = if let Some(delay) = settings.git.gutter_debounce {\n            delay\n        } else {\n            if first_insertion {\n                let this = cx.weak_entity();\n                cx.defer(move |cx| {\n                    if let Some(this) = this.upgrade() {\n                        this.update(cx, |this, cx| {\n                            this.recalculate_buffer_diffs(cx).detach();\n                        });\n                    }\n                });\n            }\n            return;\n        };\n\n        const MIN_DELAY: u64 = 50;\n        let delay = delay.max(MIN_DELAY);\n        let duration = Duration::from_millis(delay);\n\n        self.git_diff_debouncer\n            .fire_new(duration, cx, move |this, cx| {\n                this.recalculate_buffer_diffs(cx)\n            });\n    }\n\n    fn recalculate_buffer_diffs(&mut self, cx: &mut Context<Self>) -> Task<()> {\n        cx.spawn(move |this, mut cx| async move {\n            loop {\n                let task = this\n                    .update(&mut cx, |this, cx| {\n                        let buffers = this\n                            .buffers_needing_diff\n                            .drain()\n                            .filter_map(|buffer| buffer.upgrade())\n                            .collect::<Vec<_>>();\n                        if buffers.is_empty() {\n                            None\n                        } else {\n                            Some(this.buffer_store.update(cx, |buffer_store, cx| {\n                                buffer_store.recalculate_buffer_diffs(buffers, cx)\n                            }))\n                        }\n                    })\n                    .ok()\n                    .flatten();\n\n                if let Some(task) = task {\n                    task.await;\n                } else {\n                    break;\n                }\n            }\n        })\n    }\n\n    pub fn set_language_for_buffer(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        new_language: Arc<Language>,\n        cx: &mut Context<Self>,\n    ) {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.set_language_for_buffer(buffer, new_language, cx)\n        })\n    }\n\n    pub fn restart_language_servers_for_buffers(\n        &mut self,\n        buffers: impl IntoIterator<Item = Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.restart_language_servers_for_buffers(buffers, cx)\n        })\n    }\n\n    pub fn cancel_language_server_work_for_buffers(\n        &mut self,\n        buffers: impl IntoIterator<Item = Entity<Buffer>>,\n        cx: &mut Context<Self>,\n    ) {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.cancel_language_server_work_for_buffers(buffers, cx)\n        })\n    }\n\n    pub fn cancel_language_server_work(\n        &mut self,\n        server_id: LanguageServerId,\n        token_to_cancel: Option<String>,\n        cx: &mut Context<Self>,\n    ) {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.cancel_language_server_work(server_id, token_to_cancel, cx)\n        })\n    }\n\n    fn enqueue_buffer_ordered_message(&mut self, message: BufferOrderedMessage) -> Result<()> {\n        self.buffer_ordered_messages_tx\n            .unbounded_send(message)\n            .map_err(|e| anyhow!(e))\n    }\n\n    pub fn available_toolchains(\n        &self,\n        worktree_id: WorktreeId,\n        language_name: LanguageName,\n        cx: &App,\n    ) -> Task<Option<ToolchainList>> {\n        if let Some(toolchain_store) = self.toolchain_store.clone() {\n            cx.spawn(|cx| async move {\n                cx.update(|cx| {\n                    toolchain_store\n                        .read(cx)\n                        .list_toolchains(worktree_id, language_name, cx)\n                })\n                .ok()?\n                .await\n            })\n        } else {\n            Task::ready(None)\n        }\n    }\n\n    pub async fn toolchain_term(\n        languages: Arc<LanguageRegistry>,\n        language_name: LanguageName,\n    ) -> Option<SharedString> {\n        languages\n            .language_for_name(language_name.as_ref())\n            .await\n            .ok()?\n            .toolchain_lister()\n            .map(|lister| lister.term())\n    }\n\n    pub fn activate_toolchain(\n        &self,\n        worktree_id: WorktreeId,\n        toolchain: Toolchain,\n        cx: &mut App,\n    ) -> Task<Option<()>> {\n        let Some(toolchain_store) = self.toolchain_store.clone() else {\n            return Task::ready(None);\n        };\n        toolchain_store.update(cx, |this, cx| {\n            this.activate_toolchain(worktree_id, toolchain, cx)\n        })\n    }\n    pub fn active_toolchain(\n        &self,\n        worktree_id: WorktreeId,\n        language_name: LanguageName,\n        cx: &App,\n    ) -> Task<Option<Toolchain>> {\n        let Some(toolchain_store) = self.toolchain_store.clone() else {\n            return Task::ready(None);\n        };\n        toolchain_store\n            .read(cx)\n            .active_toolchain(worktree_id, language_name, cx)\n    }\n    pub fn language_server_statuses<'a>(\n        &'a self,\n        cx: &'a App,\n    ) -> impl DoubleEndedIterator<Item = (LanguageServerId, &'a LanguageServerStatus)> {\n        self.lsp_store.read(cx).language_server_statuses()\n    }\n\n    pub fn last_formatting_failure<'a>(&self, cx: &'a App) -> Option<&'a str> {\n        self.lsp_store.read(cx).last_formatting_failure()\n    }\n\n    pub fn reset_last_formatting_failure(&self, cx: &mut App) {\n        self.lsp_store\n            .update(cx, |store, _| store.reset_last_formatting_failure());\n    }\n\n    pub fn reload_buffers(\n        &self,\n        buffers: HashSet<Entity<Buffer>>,\n        push_to_history: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<ProjectTransaction>> {\n        self.buffer_store.update(cx, |buffer_store, cx| {\n            buffer_store.reload_buffers(buffers, push_to_history, cx)\n        })\n    }\n\n    pub fn reload_images(\n        &self,\n        images: HashSet<Entity<ImageItem>>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<()>> {\n        self.image_store\n            .update(cx, |image_store, cx| image_store.reload_images(images, cx))\n    }\n\n    pub fn format(\n        &mut self,\n        buffers: HashSet<Entity<Buffer>>,\n        target: LspFormatTarget,\n        push_to_history: bool,\n        trigger: lsp_store::FormatTrigger,\n        cx: &mut Context<Project>,\n    ) -> Task<anyhow::Result<ProjectTransaction>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.format(buffers, target, push_to_history, trigger, cx)\n        })\n    }\n\n    #[inline(never)]\n    fn definition_impl(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetDefinition { position },\n            cx,\n        )\n    }\n    pub fn definition<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.definition_impl(buffer, position, cx)\n    }\n\n    fn declaration_impl(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetDeclaration { position },\n            cx,\n        )\n    }\n\n    pub fn declaration<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.declaration_impl(buffer, position, cx)\n    }\n\n    fn type_definition_impl(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetTypeDefinition { position },\n            cx,\n        )\n    }\n\n    pub fn type_definition<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.type_definition_impl(buffer, position, cx)\n    }\n\n    pub fn implementation<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<LocationLink>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetImplementation { position },\n            cx,\n        )\n    }\n\n    pub fn references<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<Location>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetReferences { position },\n            cx,\n        )\n    }\n\n    fn document_highlights_impl(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<DocumentHighlight>>> {\n        self.request_lsp(\n            buffer.clone(),\n            LanguageServerToQuery::Primary,\n            GetDocumentHighlights { position },\n            cx,\n        )\n    }\n\n    pub fn document_highlights<T: ToPointUtf16>(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<DocumentHighlight>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.document_highlights_impl(buffer, position, cx)\n    }\n\n    pub fn symbols(&self, query: &str, cx: &mut Context<Self>) -> Task<Result<Vec<Symbol>>> {\n        self.lsp_store\n            .update(cx, |lsp_store, cx| lsp_store.symbols(query, cx))\n    }\n\n    pub fn open_buffer_for_symbol(\n        &mut self,\n        symbol: &Symbol,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.open_buffer_for_symbol(symbol, cx)\n        })\n    }\n\n    pub fn open_server_settings(&mut self, cx: &mut Context<Self>) -> Task<Result<Entity<Buffer>>> {\n        let guard = self.retain_remotely_created_models(cx);\n        let Some(ssh_client) = self.ssh_client.as_ref() else {\n            return Task::ready(Err(anyhow!(\"not an ssh project\")));\n        };\n\n        let proto_client = ssh_client.read(cx).proto_client();\n\n        cx.spawn(|project, mut cx| async move {\n            let buffer = proto_client\n                .request(proto::OpenServerSettings {\n                    project_id: SSH_PROJECT_ID,\n                })\n                .await?;\n\n            let buffer = project\n                .update(&mut cx, |project, cx| {\n                    project.buffer_store.update(cx, |buffer_store, cx| {\n                        anyhow::Ok(\n                            buffer_store\n                                .wait_for_remote_buffer(BufferId::new(buffer.buffer_id)?, cx),\n                        )\n                    })\n                })??\n                .await;\n\n            drop(guard);\n            buffer\n        })\n    }\n\n    pub fn open_local_buffer_via_lsp(\n        &mut self,\n        abs_path: lsp::Url,\n        language_server_id: LanguageServerId,\n        language_server_name: LanguageServerName,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Buffer>>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.open_local_buffer_via_lsp(\n                abs_path,\n                language_server_id,\n                language_server_name,\n                cx,\n            )\n        })\n    }\n\n    pub fn signature_help<T: ToPointUtf16>(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<SignatureHelp>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.signature_help(buffer, position, cx)\n        })\n    }\n\n    pub fn hover<T: ToPointUtf16>(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Vec<Hover>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.lsp_store\n            .update(cx, |lsp_store, cx| lsp_store.hover(buffer, position, cx))\n    }\n\n    pub fn linked_edit(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: Anchor,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<Range<Anchor>>>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.linked_edit(buffer, position, cx)\n        })\n    }\n\n    pub fn completions<T: ToOffset + ToPointUtf16>(\n        &self,\n        buffer: &Entity<Buffer>,\n        position: T,\n        context: CompletionContext,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<Completion>>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.completions(buffer, position, context, cx)\n        })\n    }\n\n    pub fn code_actions<T: Clone + ToOffset>(\n        &mut self,\n        buffer_handle: &Entity<Buffer>,\n        range: Range<T>,\n        kinds: Option<Vec<CodeActionKind>>,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<CodeAction>>> {\n        let buffer = buffer_handle.read(cx);\n        let range = buffer.anchor_before(range.start)..buffer.anchor_before(range.end);\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.code_actions(buffer_handle, range, kinds, cx)\n        })\n    }\n\n    pub fn apply_code_action(\n        &self,\n        buffer_handle: Entity<Buffer>,\n        action: CodeAction,\n        push_to_history: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<ProjectTransaction>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.apply_code_action(buffer_handle, action, push_to_history, cx)\n        })\n    }\n\n    fn prepare_rename_impl(\n        &mut self,\n        buffer: Entity<Buffer>,\n        position: PointUtf16,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<PrepareRenameResponse>> {\n        self.request_lsp(\n            buffer,\n            LanguageServerToQuery::Primary,\n            PrepareRename { position },\n            cx,\n        )\n    }\n    pub fn prepare_rename<T: ToPointUtf16>(\n        &mut self,\n        buffer: Entity<Buffer>,\n        position: T,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<PrepareRenameResponse>> {\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.prepare_rename_impl(buffer, position, cx)\n    }\n\n    pub fn perform_rename<T: ToPointUtf16>(\n        &mut self,\n        buffer: Entity<Buffer>,\n        position: T,\n        new_name: String,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<ProjectTransaction>> {\n        let push_to_history = true;\n        let position = position.to_point_utf16(buffer.read(cx));\n        self.request_lsp(\n            buffer,\n            LanguageServerToQuery::Primary,\n            PerformRename {\n                position,\n                new_name,\n                push_to_history,\n            },\n            cx,\n        )\n    }\n\n    pub fn on_type_format<T: ToPointUtf16>(\n        &mut self,\n        buffer: Entity<Buffer>,\n        position: T,\n        trigger: String,\n        push_to_history: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Option<Transaction>>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.on_type_format(buffer, position, trigger, push_to_history, cx)\n        })\n    }\n\n    pub fn inlay_hints<T: ToOffset>(\n        &mut self,\n        buffer_handle: Entity<Buffer>,\n        range: Range<T>,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<Vec<InlayHint>>> {\n        let buffer = buffer_handle.read(cx);\n        let range = buffer.anchor_before(range.start)..buffer.anchor_before(range.end);\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.inlay_hints(buffer_handle, range, cx)\n        })\n    }\n\n    pub fn resolve_inlay_hint(\n        &self,\n        hint: InlayHint,\n        buffer_handle: Entity<Buffer>,\n        server_id: LanguageServerId,\n        cx: &mut Context<Self>,\n    ) -> Task<anyhow::Result<InlayHint>> {\n        self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.resolve_inlay_hint(hint, buffer_handle, server_id, cx)\n        })\n    }\n\n    pub fn search(&mut self, query: SearchQuery, cx: &mut Context<Self>) -> Receiver<SearchResult> {\n        let (result_tx, result_rx) = smol::channel::unbounded();\n\n        let matching_buffers_rx = if query.is_opened_only() {\n            self.sort_search_candidates(&query, cx)\n        } else {\n            self.find_search_candidate_buffers(&query, MAX_SEARCH_RESULT_FILES + 1, cx)\n        };\n\n        cx.spawn(|_, cx| async move {\n            let mut range_count = 0;\n            let mut buffer_count = 0;\n            let mut limit_reached = false;\n            let query = Arc::new(query);\n            let mut chunks = matching_buffers_rx.ready_chunks(64);\n\n            // Now that we know what paths match the query, we will load at most\n            // 64 buffers at a time to avoid overwhelming the main thread. For each\n            // opened buffer, we will spawn a background task that retrieves all the\n            // ranges in the buffer matched by the query.\n            let mut chunks = pin!(chunks);\n            'outer: while let Some(matching_buffer_chunk) = chunks.next().await {\n                let mut chunk_results = Vec::new();\n                for buffer in matching_buffer_chunk {\n                    let buffer = buffer.clone();\n                    let query = query.clone();\n                    let snapshot = buffer.read_with(&cx, |buffer, _| buffer.snapshot())?;\n                    chunk_results.push(cx.background_executor().spawn(async move {\n                        let ranges = query\n                            .search(&snapshot, None)\n                            .await\n                            .iter()\n                            .map(|range| {\n                                snapshot.anchor_before(range.start)\n                                    ..snapshot.anchor_after(range.end)\n                            })\n                            .collect::<Vec<_>>();\n                        anyhow::Ok((buffer, ranges))\n                    }));\n                }\n\n                let chunk_results = futures::future::join_all(chunk_results).await;\n                for result in chunk_results {\n                    if let Some((buffer, ranges)) = result.log_err() {\n                        range_count += ranges.len();\n                        buffer_count += 1;\n                        result_tx\n                            .send(SearchResult::Buffer { buffer, ranges })\n                            .await?;\n                        if buffer_count > MAX_SEARCH_RESULT_FILES\n                            || range_count > MAX_SEARCH_RESULT_RANGES\n                        {\n                            limit_reached = true;\n                            break 'outer;\n                        }\n                    }\n                }\n            }\n\n            if limit_reached {\n                result_tx.send(SearchResult::LimitReached).await?;\n            }\n\n            anyhow::Ok(())\n        })\n        .detach();\n\n        result_rx\n    }\n\n    fn find_search_candidate_buffers(\n        &mut self,\n        query: &SearchQuery,\n        limit: usize,\n        cx: &mut Context<Project>,\n    ) -> Receiver<Entity<Buffer>> {\n        if self.is_local() {\n            let fs = self.fs.clone();\n            self.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.find_search_candidates(query, limit, fs, cx)\n            })\n        } else {\n            self.find_search_candidates_remote(query, limit, cx)\n        }\n    }\n\n    fn sort_search_candidates(\n        &mut self,\n        search_query: &SearchQuery,\n        cx: &mut Context<Project>,\n    ) -> Receiver<Entity<Buffer>> {\n        let worktree_store = self.worktree_store.read(cx);\n        let mut buffers = search_query\n            .buffers()\n            .into_iter()\n            .flatten()\n            .filter(|buffer| {\n                let b = buffer.read(cx);\n                if let Some(file) = b.file() {\n                    if !search_query.file_matches(file.path()) {\n                        return false;\n                    }\n                    if let Some(entry) = b\n                        .entry_id(cx)\n                        .and_then(|entry_id| worktree_store.entry_for_id(entry_id, cx))\n                    {\n                        if entry.is_ignored && !search_query.include_ignored() {\n                            return false;\n                        }\n                    }\n                }\n                true\n            })\n            .collect::<Vec<_>>();\n        let (tx, rx) = smol::channel::unbounded();\n        buffers.sort_by(|a, b| match (a.read(cx).file(), b.read(cx).file()) {\n            (None, None) => a.read(cx).remote_id().cmp(&b.read(cx).remote_id()),\n            (None, Some(_)) => std::cmp::Ordering::Less,\n            (Some(_), None) => std::cmp::Ordering::Greater,\n            (Some(a), Some(b)) => compare_paths((a.path(), true), (b.path(), true)),\n        });\n        for buffer in buffers {\n            tx.send_blocking(buffer.clone()).unwrap()\n        }\n\n        rx\n    }\n\n    fn find_search_candidates_remote(\n        &mut self,\n        query: &SearchQuery,\n        limit: usize,\n        cx: &mut Context<Project>,\n    ) -> Receiver<Entity<Buffer>> {\n        let (tx, rx) = smol::channel::unbounded();\n\n        let (client, remote_id): (AnyProtoClient, _) = if let Some(ssh_client) = &self.ssh_client {\n            (ssh_client.read(cx).proto_client(), 0)\n        } else if let Some(remote_id) = self.remote_id() {\n            (self.client.clone().into(), remote_id)\n        } else {\n            return rx;\n        };\n\n        let request = client.request(proto::FindSearchCandidates {\n            project_id: remote_id,\n            query: Some(query.to_proto()),\n            limit: limit as _,\n        });\n        let guard = self.retain_remotely_created_models(cx);\n\n        cx.spawn(move |project, mut cx| async move {\n            let response = request.await?;\n            for buffer_id in response.buffer_ids {\n                let buffer_id = BufferId::new(buffer_id)?;\n                let buffer = project\n                    .update(&mut cx, |project, cx| {\n                        project.buffer_store.update(cx, |buffer_store, cx| {\n                            buffer_store.wait_for_remote_buffer(buffer_id, cx)\n                        })\n                    })?\n                    .await?;\n                let _ = tx.send(buffer).await;\n            }\n\n            drop(guard);\n            anyhow::Ok(())\n        })\n        .detach_and_log_err(cx);\n        rx\n    }\n\n    pub fn request_lsp<R: LspCommand>(\n        &mut self,\n        buffer_handle: Entity<Buffer>,\n        server: LanguageServerToQuery,\n        request: R,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<R::Response>>\n    where\n        <R::LspRequest as lsp::request::Request>::Result: Send,\n        <R::LspRequest as lsp::request::Request>::Params: Send,\n    {\n        let guard = self.retain_remotely_created_models(cx);\n        let task = self.lsp_store.update(cx, |lsp_store, cx| {\n            lsp_store.request_lsp(buffer_handle, server, request, cx)\n        });\n        cx.spawn(|_, _| async move {\n            let result = task.await;\n            drop(guard);\n            result\n        })\n    }\n\n    /// Move a worktree to a new position in the worktree order.\n    ///\n    /// The worktree will moved to the opposite side of the destination worktree.\n    ///\n    /// # Example\n    ///\n    /// Given the worktree order `[11, 22, 33]` and a call to move worktree `22` to `33`,\n    /// worktree_order will be updated to produce the indexes `[11, 33, 22]`.\n    ///\n    /// Given the worktree order `[11, 22, 33]` and a call to move worktree `22` to `11`,\n    /// worktree_order will be updated to produce the indexes `[22, 11, 33]`.\n    ///\n    /// # Errors\n    ///\n    /// An error will be returned if the worktree or destination worktree are not found.\n    pub fn move_worktree(\n        &mut self,\n        source: WorktreeId,\n        destination: WorktreeId,\n        cx: &mut Context<'_, Self>,\n    ) -> Result<()> {\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.move_worktree(source, destination, cx)\n        })\n    }\n\n    pub fn find_or_create_worktree(\n        &mut self,\n        abs_path: impl AsRef<Path>,\n        visible: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<(Entity<Worktree>, PathBuf)>> {\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.find_or_create_worktree(abs_path, visible, cx)\n        })\n    }\n\n    pub fn find_worktree(&self, abs_path: &Path, cx: &App) -> Option<(Entity<Worktree>, PathBuf)> {\n        self.worktree_store.read_with(cx, |worktree_store, cx| {\n            worktree_store.find_worktree(abs_path, cx)\n        })\n    }\n\n    pub fn is_shared(&self) -> bool {\n        match &self.client_state {\n            ProjectClientState::Shared { .. } => true,\n            ProjectClientState::Local => false,\n            ProjectClientState::Remote { .. } => true,\n        }\n    }\n\n    /// Returns the resolved version of `path`, that was found in `buffer`, if it exists.\n    pub fn resolve_path_in_buffer(\n        &self,\n        path: &str,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<ResolvedPath>> {\n        let path_buf = PathBuf::from(path);\n        if path_buf.is_absolute() || path.starts_with(\"~\") {\n            self.resolve_abs_path(path, cx)\n        } else {\n            self.resolve_path_in_worktrees(path_buf, buffer, cx)\n        }\n    }\n\n    pub fn resolve_abs_file_path(\n        &self,\n        path: &str,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<ResolvedPath>> {\n        let resolve_task = self.resolve_abs_path(path, cx);\n        cx.background_executor().spawn(async move {\n            let resolved_path = resolve_task.await;\n            resolved_path.filter(|path| path.is_file())\n        })\n    }\n\n    pub fn resolve_abs_path(\n        &self,\n        path: &str,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<ResolvedPath>> {\n        if self.is_local() {\n            let expanded = PathBuf::from(shellexpand::tilde(&path).into_owned());\n            let fs = self.fs.clone();\n            cx.background_executor().spawn(async move {\n                let path = expanded.as_path();\n                let metadata = fs.metadata(path).await.ok().flatten();\n\n                metadata.map(|metadata| ResolvedPath::AbsPath {\n                    path: expanded,\n                    is_dir: metadata.is_dir,\n                })\n            })\n        } else if let Some(ssh_client) = self.ssh_client.as_ref() {\n            let request_path = Path::new(path);\n            let request = ssh_client\n                .read(cx)\n                .proto_client()\n                .request(proto::GetPathMetadata {\n                    project_id: SSH_PROJECT_ID,\n                    path: request_path.to_proto(),\n                });\n            cx.background_executor().spawn(async move {\n                let response = request.await.log_err()?;\n                if response.exists {\n                    Some(ResolvedPath::AbsPath {\n                        path: PathBuf::from_proto(response.path),\n                        is_dir: response.is_dir,\n                    })\n                } else {\n                    None\n                }\n            })\n        } else {\n            return Task::ready(None);\n        }\n    }\n\n    fn resolve_path_in_worktrees(\n        &self,\n        path: PathBuf,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> Task<Option<ResolvedPath>> {\n        let mut candidates = vec![path.clone()];\n\n        if let Some(file) = buffer.read(cx).file() {\n            if let Some(dir) = file.path().parent() {\n                let joined = dir.to_path_buf().join(path);\n                candidates.push(joined);\n            }\n        }\n\n        let worktrees = self.worktrees(cx).collect::<Vec<_>>();\n        cx.spawn(|_, mut cx| async move {\n            for worktree in worktrees {\n                for candidate in candidates.iter() {\n                    let path = worktree\n                        .update(&mut cx, |worktree, _| {\n                            let root_entry_path = &worktree.root_entry()?.path;\n\n                            let resolved = resolve_path(root_entry_path, candidate);\n\n                            let stripped =\n                                resolved.strip_prefix(root_entry_path).unwrap_or(&resolved);\n\n                            worktree.entry_for_path(stripped).map(|entry| {\n                                let project_path = ProjectPath {\n                                    worktree_id: worktree.id(),\n                                    path: entry.path.clone(),\n                                };\n                                ResolvedPath::ProjectPath {\n                                    project_path,\n                                    is_dir: entry.is_dir(),\n                                }\n                            })\n                        })\n                        .ok()?;\n\n                    if path.is_some() {\n                        return path;\n                    }\n                }\n            }\n            None\n        })\n    }\n\n    pub fn list_directory(\n        &self,\n        query: String,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Vec<PathBuf>>> {\n        if self.is_local() {\n            DirectoryLister::Local(self.fs.clone()).list_directory(query, cx)\n        } else if let Some(session) = self.ssh_client.as_ref() {\n            let path_buf = PathBuf::from(query);\n            let request = proto::ListRemoteDirectory {\n                dev_server_id: SSH_PROJECT_ID,\n                path: path_buf.to_proto(),\n            };\n\n            let response = session.read(cx).proto_client().request(request);\n            cx.background_executor().spawn(async move {\n                let response = response.await?;\n                Ok(response.entries.into_iter().map(PathBuf::from).collect())\n            })\n        } else {\n            Task::ready(Err(anyhow!(\"cannot list directory in remote project\")))\n        }\n    }\n\n    pub fn create_worktree(\n        &mut self,\n        abs_path: impl AsRef<Path>,\n        visible: bool,\n        cx: &mut Context<Self>,\n    ) -> Task<Result<Entity<Worktree>>> {\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.create_worktree(abs_path, visible, cx)\n        })\n    }\n\n    pub fn remove_worktree(&mut self, id_to_remove: WorktreeId, cx: &mut Context<Self>) {\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.remove_worktree(id_to_remove, cx);\n        });\n    }\n\n    fn add_worktree(&mut self, worktree: &Entity<Worktree>, cx: &mut Context<Self>) {\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.add(worktree, cx);\n        });\n    }\n\n    pub fn set_active_path(&mut self, entry: Option<ProjectPath>, cx: &mut Context<Self>) {\n        let new_active_entry = entry.and_then(|project_path| {\n            let worktree = self.worktree_for_id(project_path.worktree_id, cx)?;\n            let entry = worktree.read(cx).entry_for_path(project_path.path)?;\n            Some(entry.id)\n        });\n        if new_active_entry != self.active_entry {\n            self.active_entry = new_active_entry;\n            self.lsp_store.update(cx, |lsp_store, _| {\n                lsp_store.set_active_entry(new_active_entry);\n            });\n            cx.emit(Event::ActiveEntryChanged(new_active_entry));\n        }\n    }\n\n    pub fn language_servers_running_disk_based_diagnostics<'a>(\n        &'a self,\n        cx: &'a App,\n    ) -> impl Iterator<Item = LanguageServerId> + 'a {\n        self.lsp_store\n            .read(cx)\n            .language_servers_running_disk_based_diagnostics()\n    }\n\n    pub fn diagnostic_summary(&self, include_ignored: bool, cx: &App) -> DiagnosticSummary {\n        self.lsp_store\n            .read(cx)\n            .diagnostic_summary(include_ignored, cx)\n    }\n\n    pub fn diagnostic_summaries<'a>(\n        &'a self,\n        include_ignored: bool,\n        cx: &'a App,\n    ) -> impl Iterator<Item = (ProjectPath, LanguageServerId, DiagnosticSummary)> + 'a {\n        self.lsp_store\n            .read(cx)\n            .diagnostic_summaries(include_ignored, cx)\n    }\n\n    pub fn active_entry(&self) -> Option<ProjectEntryId> {\n        self.active_entry\n    }\n\n    pub fn entry_for_path(&self, path: &ProjectPath, cx: &App) -> Option<Entry> {\n        self.worktree_store.read(cx).entry_for_path(path, cx)\n    }\n\n    pub fn path_for_entry(&self, entry_id: ProjectEntryId, cx: &App) -> Option<ProjectPath> {\n        let worktree = self.worktree_for_entry(entry_id, cx)?;\n        let worktree = worktree.read(cx);\n        let worktree_id = worktree.id();\n        let path = worktree.entry_for_id(entry_id)?.path.clone();\n        Some(ProjectPath { worktree_id, path })\n    }\n\n    pub fn absolute_path(&self, project_path: &ProjectPath, cx: &App) -> Option<PathBuf> {\n        self.worktree_for_id(project_path.worktree_id, cx)?\n            .read(cx)\n            .absolutize(&project_path.path)\n            .ok()\n    }\n\n    /// Attempts to find a `ProjectPath` corresponding to the given path. If the path\n    /// is a *full path*, meaning it starts with the root name of a worktree, we'll locate\n    /// it in that worktree. Otherwise, we'll attempt to find it as a relative path in\n    /// the first visible worktree that has an entry for that relative path.\n    ///\n    /// We use this to resolve edit steps, when there's a chance an LLM may omit the workree\n    /// root name from paths.\n    ///\n    /// # Arguments\n    ///\n    /// * `path` - A full path that starts with a worktree root name, or alternatively a\n    ///            relative path within a visible worktree.\n    /// * `cx` - A reference to the `AppContext`.\n    ///\n    /// # Returns\n    ///\n    /// Returns `Some(ProjectPath)` if a matching worktree is found, otherwise `None`.\n    pub fn find_project_path(&self, path: &Path, cx: &App) -> Option<ProjectPath> {\n        let worktree_store = self.worktree_store.read(cx);\n\n        for worktree in worktree_store.visible_worktrees(cx) {\n            let worktree_root_name = worktree.read(cx).root_name();\n            if let Ok(relative_path) = path.strip_prefix(worktree_root_name) {\n                return Some(ProjectPath {\n                    worktree_id: worktree.read(cx).id(),\n                    path: relative_path.into(),\n                });\n            }\n        }\n\n        for worktree in worktree_store.visible_worktrees(cx) {\n            let worktree = worktree.read(cx);\n            if let Some(entry) = worktree.entry_for_path(path) {\n                return Some(ProjectPath {\n                    worktree_id: worktree.id(),\n                    path: entry.path.clone(),\n                });\n            }\n        }\n\n        None\n    }\n\n    pub fn get_workspace_root(&self, project_path: &ProjectPath, cx: &App) -> Option<PathBuf> {\n        Some(\n            self.worktree_for_id(project_path.worktree_id, cx)?\n                .read(cx)\n                .abs_path()\n                .to_path_buf(),\n        )\n    }\n\n    pub fn get_first_worktree_root_repo(&self, cx: &App) -> Option<Arc<dyn GitRepository>> {\n        let worktree = self.visible_worktrees(cx).next()?.read(cx).as_local()?;\n        let root_entry = worktree.root_git_entry()?;\n        worktree.get_local_repo(&root_entry)?.repo().clone().into()\n    }\n\n    pub fn branches(&self, project_path: ProjectPath, cx: &App) -> Task<Result<Vec<Branch>>> {\n        self.worktree_store().read(cx).branches(project_path, cx)\n    }\n\n    pub fn update_or_create_branch(\n        &self,\n        repository: ProjectPath,\n        new_branch: String,\n        cx: &App,\n    ) -> Task<Result<()>> {\n        self.worktree_store()\n            .read(cx)\n            .update_or_create_branch(repository, new_branch, cx)\n    }\n\n    pub fn blame_buffer(\n        &self,\n        buffer: &Entity<Buffer>,\n        version: Option<clock::Global>,\n        cx: &App,\n    ) -> Task<Result<Option<Blame>>> {\n        self.buffer_store.read(cx).blame_buffer(buffer, version, cx)\n    }\n\n    pub fn get_permalink_to_line(\n        &self,\n        buffer: &Entity<Buffer>,\n        selection: Range<u32>,\n        cx: &App,\n    ) -> Task<Result<url::Url>> {\n        self.buffer_store\n            .read(cx)\n            .get_permalink_to_line(buffer, selection, cx)\n    }\n\n    // RPC message handlers\n\n    async fn handle_unshare_project(\n        this: Entity<Self>,\n        _: TypedEnvelope<proto::UnshareProject>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            if this.is_local() || this.is_via_ssh() {\n                this.unshare(cx)?;\n            } else {\n                this.disconnected_from_host(cx);\n            }\n            Ok(())\n        })?\n    }\n\n    async fn handle_add_collaborator(\n        this: Entity<Self>,\n        mut envelope: TypedEnvelope<proto::AddProjectCollaborator>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let collaborator = envelope\n            .payload\n            .collaborator\n            .take()\n            .ok_or_else(|| anyhow!(\"empty collaborator\"))?;\n\n        let collaborator = Collaborator::from_proto(collaborator)?;\n        this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, _| {\n                buffer_store.forget_shared_buffers_for(&collaborator.peer_id);\n            });\n            cx.emit(Event::CollaboratorJoined(collaborator.peer_id));\n            this.collaborators\n                .insert(collaborator.peer_id, collaborator);\n            cx.notify();\n        })?;\n\n        Ok(())\n    }\n\n    async fn handle_update_project_collaborator(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateProjectCollaborator>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        let old_peer_id = envelope\n            .payload\n            .old_peer_id\n            .ok_or_else(|| anyhow!(\"missing old peer id\"))?;\n        let new_peer_id = envelope\n            .payload\n            .new_peer_id\n            .ok_or_else(|| anyhow!(\"missing new peer id\"))?;\n        this.update(&mut cx, |this, cx| {\n            let collaborator = this\n                .collaborators\n                .remove(&old_peer_id)\n                .ok_or_else(|| anyhow!(\"received UpdateProjectCollaborator for unknown peer\"))?;\n            let is_host = collaborator.is_host;\n            this.collaborators.insert(new_peer_id, collaborator);\n\n            log::info!(\"peer {} became {}\", old_peer_id, new_peer_id,);\n            this.buffer_store.update(cx, |buffer_store, _| {\n                buffer_store.update_peer_id(&old_peer_id, new_peer_id)\n            });\n\n            if is_host {\n                this.buffer_store\n                    .update(cx, |buffer_store, _| buffer_store.discard_incomplete());\n                this.enqueue_buffer_ordered_message(BufferOrderedMessage::Resync)\n                    .unwrap();\n                cx.emit(Event::HostReshared);\n            }\n\n            cx.emit(Event::CollaboratorUpdated {\n                old_peer_id,\n                new_peer_id,\n            });\n            cx.notify();\n            Ok(())\n        })?\n    }\n\n    async fn handle_remove_collaborator(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::RemoveProjectCollaborator>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            let peer_id = envelope\n                .payload\n                .peer_id\n                .ok_or_else(|| anyhow!(\"invalid peer id\"))?;\n            let replica_id = this\n                .collaborators\n                .remove(&peer_id)\n                .ok_or_else(|| anyhow!(\"unknown peer {:?}\", peer_id))?\n                .replica_id;\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.forget_shared_buffers_for(&peer_id);\n                for buffer in buffer_store.buffers() {\n                    buffer.update(cx, |buffer, cx| buffer.remove_peer(replica_id, cx));\n                }\n            });\n\n            cx.emit(Event::CollaboratorLeft(peer_id));\n            cx.notify();\n            Ok(())\n        })?\n    }\n\n    async fn handle_update_project(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateProject>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            // Don't handle messages that were sent before the response to us joining the project\n            if envelope.message_id > this.join_project_response_message_id {\n                this.set_worktrees_from_proto(envelope.payload.worktrees, cx)?;\n            }\n            Ok(())\n        })?\n    }\n\n    async fn handle_toast(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::Toast>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |_, cx| {\n            cx.emit(Event::Toast {\n                notification_id: envelope.payload.notification_id.into(),\n                message: envelope.payload.message,\n            });\n            Ok(())\n        })?\n    }\n\n    async fn handle_language_server_prompt_request(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::LanguageServerPromptRequest>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::LanguageServerPromptResponse> {\n        let (tx, mut rx) = smol::channel::bounded(1);\n        let actions: Vec<_> = envelope\n            .payload\n            .actions\n            .into_iter()\n            .map(|action| MessageActionItem {\n                title: action,\n                properties: Default::default(),\n            })\n            .collect();\n        this.update(&mut cx, |_, cx| {\n            cx.emit(Event::LanguageServerPrompt(LanguageServerPromptRequest {\n                level: proto_to_prompt(envelope.payload.level.context(\"Invalid prompt level\")?),\n                message: envelope.payload.message,\n                actions: actions.clone(),\n                lsp_name: envelope.payload.lsp_name,\n                response_channel: tx,\n            }));\n\n            anyhow::Ok(())\n        })??;\n\n        // We drop `this` to avoid holding a reference in this future for too\n        // long.\n        // If we keep the reference, we might not drop the `Project` early\n        // enough when closing a window and it will only get releases on the\n        // next `flush_effects()` call.\n        drop(this);\n\n        let mut rx = pin!(rx);\n        let answer = rx.next().await;\n\n        Ok(LanguageServerPromptResponse {\n            action_response: answer.and_then(|answer| {\n                actions\n                    .iter()\n                    .position(|action| *action == answer)\n                    .map(|index| index as u64)\n            }),\n        })\n    }\n\n    async fn handle_hide_toast(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::HideToast>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |_, cx| {\n            cx.emit(Event::HideToast {\n                notification_id: envelope.payload.notification_id.into(),\n            });\n            Ok(())\n        })?\n    }\n\n    // Collab sends UpdateWorktree protos as messages\n    async fn handle_update_worktree(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateWorktree>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n            if let Some(worktree) = this.worktree_for_id(worktree_id, cx) {\n                worktree.update(cx, |worktree, _| {\n                    let worktree = worktree.as_remote_mut().unwrap();\n                    worktree.update_from_remote(envelope.payload);\n                });\n            }\n            Ok(())\n        })?\n    }\n\n    async fn handle_update_buffer_from_ssh(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateBuffer>,\n        cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let buffer_store = this.read_with(&cx, |this, cx| {\n            if let Some(remote_id) = this.remote_id() {\n                let mut payload = envelope.payload.clone();\n                payload.project_id = remote_id;\n                cx.background_executor()\n                    .spawn(this.client.request(payload))\n                    .detach_and_log_err(cx);\n            }\n            this.buffer_store.clone()\n        })?;\n        BufferStore::handle_update_buffer(buffer_store, envelope, cx).await\n    }\n\n    async fn handle_update_buffer(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::UpdateBuffer>,\n        cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let buffer_store = this.read_with(&cx, |this, cx| {\n            if let Some(ssh) = &this.ssh_client {\n                let mut payload = envelope.payload.clone();\n                payload.project_id = SSH_PROJECT_ID;\n                cx.background_executor()\n                    .spawn(ssh.read(cx).proto_client().request(payload))\n                    .detach_and_log_err(cx);\n            }\n            this.buffer_store.clone()\n        })?;\n        BufferStore::handle_update_buffer(buffer_store, envelope, cx).await\n    }\n\n    fn retain_remotely_created_models(\n        &mut self,\n        cx: &mut Context<Self>,\n    ) -> RemotelyCreatedModelGuard {\n        {\n            let mut remotely_create_models = self.remotely_created_models.lock();\n            if remotely_create_models.retain_count == 0 {\n                remotely_create_models.buffers = self.buffer_store.read(cx).buffers().collect();\n                remotely_create_models.worktrees =\n                    self.worktree_store.read(cx).worktrees().collect();\n            }\n            remotely_create_models.retain_count += 1;\n        }\n        RemotelyCreatedModelGuard {\n            remote_models: Arc::downgrade(&self.remotely_created_models),\n        }\n    }\n\n    async fn handle_create_buffer_for_peer(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::CreateBufferForPeer>,\n        mut cx: AsyncApp,\n    ) -> Result<()> {\n        this.update(&mut cx, |this, cx| {\n            this.buffer_store.update(cx, |buffer_store, cx| {\n                buffer_store.handle_create_buffer_for_peer(\n                    envelope,\n                    this.replica_id(),\n                    this.capability(),\n                    cx,\n                )\n            })\n        })?\n    }\n\n    async fn handle_synchronize_buffers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::SynchronizeBuffers>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::SynchronizeBuffersResponse> {\n        let response = this.update(&mut cx, |this, cx| {\n            let client = this.client.clone();\n            this.buffer_store.update(cx, |this, cx| {\n                this.handle_synchronize_buffers(envelope, cx, client)\n            })\n        })??;\n\n        Ok(response)\n    }\n\n    async fn handle_search_candidate_buffers(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::FindSearchCandidates>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::FindSearchCandidatesResponse> {\n        let peer_id = envelope.original_sender_id()?;\n        let message = envelope.payload;\n        let query = SearchQuery::from_proto(\n            message\n                .query\n                .ok_or_else(|| anyhow!(\"missing query field\"))?,\n        )?;\n        let results = this.update(&mut cx, |this, cx| {\n            this.find_search_candidate_buffers(&query, message.limit as _, cx)\n        })?;\n\n        let mut response = proto::FindSearchCandidatesResponse {\n            buffer_ids: Vec::new(),\n        };\n\n        while let Ok(buffer) = results.recv().await {\n            this.update(&mut cx, |this, cx| {\n                let buffer_id = this.create_buffer_for_peer(&buffer, peer_id, cx);\n                response.buffer_ids.push(buffer_id.to_proto());\n            })?;\n        }\n\n        Ok(response)\n    }\n\n    async fn handle_open_buffer_by_id(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenBufferById>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferResponse> {\n        let peer_id = envelope.original_sender_id()?;\n        let buffer_id = BufferId::new(envelope.payload.id)?;\n        let buffer = this\n            .update(&mut cx, |this, cx| this.open_buffer_by_id(buffer_id, cx))?\n            .await?;\n        Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n    }\n\n    async fn handle_open_buffer_by_path(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenBufferByPath>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferResponse> {\n        let peer_id = envelope.original_sender_id()?;\n        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n        let open_buffer = this.update(&mut cx, |this, cx| {\n            this.open_buffer(\n                ProjectPath {\n                    worktree_id,\n                    path: Arc::<Path>::from_proto(envelope.payload.path),\n                },\n                cx,\n            )\n        })?;\n\n        let buffer = open_buffer.await?;\n        Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n    }\n\n    async fn handle_open_new_buffer(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenNewBuffer>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferResponse> {\n        let buffer = this\n            .update(&mut cx, |this, cx| this.create_buffer(cx))?\n            .await?;\n        let peer_id = envelope.original_sender_id()?;\n\n        Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n    }\n\n    async fn handle_stage(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::Stage>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n        let repository_handle =\n            Self::repository_for_request(&this, worktree_id, work_directory_id, &mut cx)?;\n\n        let entries = envelope\n            .payload\n            .paths\n            .into_iter()\n            .map(PathBuf::from)\n            .map(RepoPath::new)\n            .collect();\n\n        repository_handle\n            .update(&mut cx, |repository_handle, _| {\n                repository_handle.stage_entries(entries)\n            })?\n            .await??;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_unstage(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::Unstage>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n        let repository_handle =\n            Self::repository_for_request(&this, worktree_id, work_directory_id, &mut cx)?;\n\n        let entries = envelope\n            .payload\n            .paths\n            .into_iter()\n            .map(PathBuf::from)\n            .map(RepoPath::new)\n            .collect();\n\n        repository_handle\n            .update(&mut cx, |repository_handle, _| {\n                repository_handle.unstage_entries(entries)\n            })?\n            .await??;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_commit(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::Commit>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::Ack> {\n        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n        let repository_handle =\n            Self::repository_for_request(&this, worktree_id, work_directory_id, &mut cx)?;\n\n        let message = SharedString::from(envelope.payload.message);\n        let name = envelope.payload.name.map(SharedString::from);\n        let email = envelope.payload.email.map(SharedString::from);\n        repository_handle\n            .update(&mut cx, |repository_handle, _| {\n                repository_handle.commit(message, name.zip(email))\n            })?\n            .await??;\n        Ok(proto::Ack {})\n    }\n\n    async fn handle_open_commit_message_buffer(\n        this: Entity<Self>,\n        envelope: TypedEnvelope<proto::OpenCommitMessageBuffer>,\n        mut cx: AsyncApp,\n    ) -> Result<proto::OpenBufferResponse> {\n        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n        let repository_handle =\n            Self::repository_for_request(&this, worktree_id, work_directory_id, &mut cx)?;\n        let buffer = repository_handle\n            .update(&mut cx, |repository_handle, cx| {\n                repository_handle.open_commit_buffer(None, this.read(cx).buffer_store.clone(), cx)\n            })?\n            .await?;\n\n        let peer_id = envelope.original_sender_id()?;\n        Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n    }\n\n    fn repository_for_request(\n        this: &Entity<Self>,\n        worktree_id: WorktreeId,\n        work_directory_id: ProjectEntryId,\n        cx: &mut AsyncApp,\n    ) -> Result<Entity<Repository>> {\n        this.update(cx, |project, cx| {\n            let repository_handle = project\n                .git_state()\n                .read(cx)\n                .all_repositories()\n                .into_iter()\n                .find(|repository_handle| {\n                    let repository_handle = repository_handle.read(cx);\n                    repository_handle.worktree_id == worktree_id\n                        && repository_handle.repository_entry.work_directory_id()\n                            == work_directory_id\n                })\n                .context(\"missing repository handle\")?;\n            anyhow::Ok(repository_handle)\n        })?\n    }\n\n    fn respond_to_open_buffer_request(\n        this: Entity<Self>,\n        buffer: Entity<Buffer>,\n        peer_id: proto::PeerId,\n        cx: &mut AsyncApp,\n    ) -> Result<proto::OpenBufferResponse> {\n        this.update(cx, |this, cx| {\n            let is_private = buffer\n                .read(cx)\n                .file()\n                .map(|f| f.is_private())\n                .unwrap_or_default();\n            if is_private {\n                Err(anyhow!(ErrorCode::UnsharedItem))\n            } else {\n                Ok(proto::OpenBufferResponse {\n                    buffer_id: this.create_buffer_for_peer(&buffer, peer_id, cx).into(),\n                })\n            }\n        })?\n    }\n\n    fn create_buffer_for_peer(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        peer_id: proto::PeerId,\n        cx: &mut App,\n    ) -> BufferId {\n        self.buffer_store\n            .update(cx, |buffer_store, cx| {\n                buffer_store.create_buffer_for_peer(buffer, peer_id, cx)\n            })\n            .detach_and_log_err(cx);\n        buffer.read(cx).remote_id()\n    }\n\n    fn synchronize_remote_buffers(&mut self, cx: &mut Context<Self>) -> Task<Result<()>> {\n        let project_id = match self.client_state {\n            ProjectClientState::Remote {\n                sharing_has_stopped,\n                remote_id,\n                ..\n            } => {\n                if sharing_has_stopped {\n                    return Task::ready(Err(anyhow!(\n                        \"can't synchronize remote buffers on a readonly project\"\n                    )));\n                } else {\n                    remote_id\n                }\n            }\n            ProjectClientState::Shared { .. } | ProjectClientState::Local => {\n                return Task::ready(Err(anyhow!(\n                    \"can't synchronize remote buffers on a local project\"\n                )))\n            }\n        };\n\n        let client = self.client.clone();\n        cx.spawn(move |this, mut cx| async move {\n            let (buffers, incomplete_buffer_ids) = this.update(&mut cx, |this, cx| {\n                this.buffer_store.read(cx).buffer_version_info(cx)\n            })?;\n            let response = client\n                .request(proto::SynchronizeBuffers {\n                    project_id,\n                    buffers,\n                })\n                .await?;\n\n            let send_updates_for_buffers = this.update(&mut cx, |this, cx| {\n                response\n                    .buffers\n                    .into_iter()\n                    .map(|buffer| {\n                        let client = client.clone();\n                        let buffer_id = match BufferId::new(buffer.id) {\n                            Ok(id) => id,\n                            Err(e) => {\n                                return Task::ready(Err(e));\n                            }\n                        };\n                        let remote_version = language::proto::deserialize_version(&buffer.version);\n                        if let Some(buffer) = this.buffer_for_id(buffer_id, cx) {\n                            let operations =\n                                buffer.read(cx).serialize_ops(Some(remote_version), cx);\n                            cx.background_executor().spawn(async move {\n                                let operations = operations.await;\n                                for chunk in split_operations(operations) {\n                                    client\n                                        .request(proto::UpdateBuffer {\n                                            project_id,\n                                            buffer_id: buffer_id.into(),\n                                            operations: chunk,\n                                        })\n                                        .await?;\n                                }\n                                anyhow::Ok(())\n                            })\n                        } else {\n                            Task::ready(Ok(()))\n                        }\n                    })\n                    .collect::<Vec<_>>()\n            })?;\n\n            // Any incomplete buffers have open requests waiting. Request that the host sends\n            // creates these buffers for us again to unblock any waiting futures.\n            for id in incomplete_buffer_ids {\n                cx.background_executor()\n                    .spawn(client.request(proto::OpenBufferById {\n                        project_id,\n                        id: id.into(),\n                    }))\n                    .detach();\n            }\n\n            futures::future::join_all(send_updates_for_buffers)\n                .await\n                .into_iter()\n                .collect()\n        })\n    }\n\n    pub fn worktree_metadata_protos(&self, cx: &App) -> Vec<proto::WorktreeMetadata> {\n        self.worktree_store.read(cx).worktree_metadata_protos(cx)\n    }\n\n    /// Iterator of all open buffers that have unsaved changes\n    pub fn dirty_buffers<'a>(&'a self, cx: &'a App) -> impl Iterator<Item = ProjectPath> + 'a {\n        self.buffer_store.read(cx).buffers().filter_map(|buf| {\n            let buf = buf.read(cx);\n            if buf.is_dirty() {\n                buf.project_path(cx)\n            } else {\n                None\n            }\n        })\n    }\n\n    fn set_worktrees_from_proto(\n        &mut self,\n        worktrees: Vec<proto::WorktreeMetadata>,\n        cx: &mut Context<Project>,\n    ) -> Result<()> {\n        cx.notify();\n        self.worktree_store.update(cx, |worktree_store, cx| {\n            worktree_store.set_worktrees_from_proto(worktrees, self.replica_id(), cx)\n        })\n    }\n\n    fn set_collaborators_from_proto(\n        &mut self,\n        messages: Vec<proto::Collaborator>,\n        cx: &mut Context<Self>,\n    ) -> Result<()> {\n        let mut collaborators = HashMap::default();\n        for message in messages {\n            let collaborator = Collaborator::from_proto(message)?;\n            collaborators.insert(collaborator.peer_id, collaborator);\n        }\n        for old_peer_id in self.collaborators.keys() {\n            if !collaborators.contains_key(old_peer_id) {\n                cx.emit(Event::CollaboratorLeft(*old_peer_id));\n            }\n        }\n        self.collaborators = collaborators;\n        Ok(())\n    }\n\n    pub fn supplementary_language_servers<'a>(\n        &'a self,\n        cx: &'a App,\n    ) -> impl 'a + Iterator<Item = (LanguageServerId, LanguageServerName)> {\n        self.lsp_store.read(cx).supplementary_language_servers()\n    }\n\n    pub fn language_servers_for_local_buffer<'a>(\n        &'a self,\n        buffer: &'a Buffer,\n        cx: &'a App,\n    ) -> impl Iterator<Item = (&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n        self.lsp_store\n            .read(cx)\n            .language_servers_for_local_buffer(buffer, cx)\n    }\n\n    pub fn buffer_store(&self) -> &Entity<BufferStore> {\n        &self.buffer_store\n    }\n\n    pub fn git_state(&self) -> &Entity<GitState> {\n        &self.git_state\n    }\n\n    pub fn active_repository(&self, cx: &App) -> Option<Entity<Repository>> {\n        self.git_state.read(cx).active_repository()\n    }\n\n    pub fn all_repositories(&self, cx: &App) -> Vec<Entity<Repository>> {\n        self.git_state.read(cx).all_repositories()\n    }\n}\n\nfn deserialize_code_actions(code_actions: &HashMap<String, bool>) -> Vec<lsp::CodeActionKind> {\n    code_actions\n        .iter()\n        .flat_map(|(kind, enabled)| {\n            if *enabled {\n                Some(kind.clone().into())\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\npub struct PathMatchCandidateSet {\n    pub snapshot: Snapshot,\n    pub include_ignored: bool,\n    pub include_root_name: bool,\n    pub candidates: Candidates,\n}\n\npub enum Candidates {\n    /// Only consider directories.\n    Directories,\n    /// Only consider files.\n    Files,\n    /// Consider directories and files.\n    Entries,\n}\n\nimpl<'a> fuzzy::PathMatchCandidateSet<'a> for PathMatchCandidateSet {\n    type Candidates = PathMatchCandidateSetIter<'a>;\n\n    fn id(&self) -> usize {\n        self.snapshot.id().to_usize()\n    }\n\n    fn len(&self) -> usize {\n        match self.candidates {\n            Candidates::Files => {\n                if self.include_ignored {\n                    self.snapshot.file_count()\n                } else {\n                    self.snapshot.visible_file_count()\n                }\n            }\n\n            Candidates::Directories => {\n                if self.include_ignored {\n                    self.snapshot.dir_count()\n                } else {\n                    self.snapshot.visible_dir_count()\n                }\n            }\n\n            Candidates::Entries => {\n                if self.include_ignored {\n                    self.snapshot.entry_count()\n                } else {\n                    self.snapshot.visible_entry_count()\n                }\n            }\n        }\n    }\n\n    fn prefix(&self) -> Arc<str> {\n        if self.snapshot.root_entry().map_or(false, |e| e.is_file()) {\n            self.snapshot.root_name().into()\n        } else if self.include_root_name {\n            format!(\"{}{}\", self.snapshot.root_name(), std::path::MAIN_SEPARATOR).into()\n        } else {\n            Arc::default()\n        }\n    }\n\n    fn candidates(&'a self, start: usize) -> Self::Candidates {\n        PathMatchCandidateSetIter {\n            traversal: match self.candidates {\n                Candidates::Directories => self.snapshot.directories(self.include_ignored, start),\n                Candidates::Files => self.snapshot.files(self.include_ignored, start),\n                Candidates::Entries => self.snapshot.entries(self.include_ignored, start),\n            },\n        }\n    }\n}\n\npub struct PathMatchCandidateSetIter<'a> {\n    traversal: Traversal<'a>,\n}\n\nimpl<'a> Iterator for PathMatchCandidateSetIter<'a> {\n    type Item = fuzzy::PathMatchCandidate<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.traversal\n            .next()\n            .map(|entry| fuzzy::PathMatchCandidate {\n                is_dir: entry.kind.is_dir(),\n                path: &entry.path,\n                char_bag: entry.char_bag,\n            })\n    }\n}\n\nimpl EventEmitter<Event> for Project {}\n\nimpl<'a> From<&'a ProjectPath> for SettingsLocation<'a> {\n    fn from(val: &'a ProjectPath) -> Self {\n        SettingsLocation {\n            worktree_id: val.worktree_id,\n            path: val.path.as_ref(),\n        }\n    }\n}\n\nimpl<P: AsRef<Path>> From<(WorktreeId, P)> for ProjectPath {\n    fn from((worktree_id, path): (WorktreeId, P)) -> Self {\n        Self {\n            worktree_id,\n            path: path.as_ref().into(),\n        }\n    }\n}\n\npub fn relativize_path(base: &Path, path: &Path) -> PathBuf {\n    let mut path_components = path.components();\n    let mut base_components = base.components();\n    let mut components: Vec<Component> = Vec::new();\n    loop {\n        match (path_components.next(), base_components.next()) {\n            (None, None) => break,\n            (Some(a), None) => {\n                components.push(a);\n                components.extend(path_components.by_ref());\n                break;\n            }\n            (None, _) => components.push(Component::ParentDir),\n            (Some(a), Some(b)) if components.is_empty() && a == b => (),\n            (Some(a), Some(Component::CurDir)) => components.push(a),\n            (Some(a), Some(_)) => {\n                components.push(Component::ParentDir);\n                for _ in base_components {\n                    components.push(Component::ParentDir);\n                }\n                components.push(a);\n                components.extend(path_components.by_ref());\n                break;\n            }\n        }\n    }\n    components.iter().map(|c| c.as_os_str()).collect()\n}\n\nfn resolve_path(base: &Path, path: &Path) -> PathBuf {\n    let mut result = base.to_path_buf();\n    for component in path.components() {\n        match component {\n            Component::ParentDir => {\n                result.pop();\n            }\n            Component::CurDir => (),\n            _ => result.push(component),\n        }\n    }\n    result\n}\n\n/// ResolvedPath is a path that has been resolved to either a ProjectPath\n/// or an AbsPath and that *exists*.\n#[derive(Debug, Clone)]\npub enum ResolvedPath {\n    ProjectPath {\n        project_path: ProjectPath,\n        is_dir: bool,\n    },\n    AbsPath {\n        path: PathBuf,\n        is_dir: bool,\n    },\n}\n\nimpl ResolvedPath {\n    pub fn abs_path(&self) -> Option<&Path> {\n        match self {\n            Self::AbsPath { path, .. } => Some(path.as_path()),\n            _ => None,\n        }\n    }\n\n    pub fn project_path(&self) -> Option<&ProjectPath> {\n        match self {\n            Self::ProjectPath { project_path, .. } => Some(&project_path),\n            _ => None,\n        }\n    }\n\n    pub fn is_file(&self) -> bool {\n        !self.is_dir()\n    }\n\n    pub fn is_dir(&self) -> bool {\n        match self {\n            Self::ProjectPath { is_dir, .. } => *is_dir,\n            Self::AbsPath { is_dir, .. } => *is_dir,\n        }\n    }\n}\n\nimpl ProjectItem for Buffer {\n    fn try_open(\n        project: &Entity<Project>,\n        path: &ProjectPath,\n        cx: &mut App,\n    ) -> Option<Task<Result<Entity<Self>>>> {\n        Some(project.update(cx, |project, cx| project.open_buffer(path.clone(), cx)))\n    }\n\n    fn entry_id(&self, cx: &App) -> Option<ProjectEntryId> {\n        File::from_dyn(self.file()).and_then(|file| file.project_entry_id(cx))\n    }\n\n    fn project_path(&self, cx: &App) -> Option<ProjectPath> {\n        File::from_dyn(self.file()).map(|file| ProjectPath {\n            worktree_id: file.worktree_id(cx),\n            path: file.path().clone(),\n        })\n    }\n\n    fn is_dirty(&self) -> bool {\n        self.is_dirty()\n    }\n}\n\nimpl Completion {\n    /// A key that can be used to sort completions when displaying\n    /// them to the user.\n    pub fn sort_key(&self) -> (usize, &str) {\n        let kind_key = match self.lsp_completion.kind {\n            Some(lsp::CompletionItemKind::KEYWORD) => 0,\n            Some(lsp::CompletionItemKind::VARIABLE) => 1,\n            _ => 2,\n        };\n        (kind_key, &self.label.text[self.label.filter_range.clone()])\n    }\n\n    /// Whether this completion is a snippet.\n    pub fn is_snippet(&self) -> bool {\n        self.lsp_completion.insert_text_format == Some(lsp::InsertTextFormat::SNIPPET)\n    }\n\n    /// Returns the corresponding color for this completion.\n    ///\n    /// Will return `None` if this completion's kind is not [`CompletionItemKind::COLOR`].\n    pub fn color(&self) -> Option<Hsla> {\n        match self.lsp_completion.kind {\n            Some(CompletionItemKind::COLOR) => color_extractor::extract_color(&self.lsp_completion),\n            _ => None,\n        }\n    }\n}\n\npub fn sort_worktree_entries(entries: &mut [impl AsRef<Entry>]) {\n    entries.sort_by(|entry_a, entry_b| {\n        let entry_a = entry_a.as_ref();\n        let entry_b = entry_b.as_ref();\n        compare_paths(\n            (&entry_a.path, entry_a.is_file()),\n            (&entry_b.path, entry_b.is_file()),\n        )\n    });\n}\n\nfn proto_to_prompt(level: proto::language_server_prompt_request::Level) -> gpui::PromptLevel {\n    match level {\n        proto::language_server_prompt_request::Level::Info(_) => gpui::PromptLevel::Info,\n        proto::language_server_prompt_request::Level::Warning(_) => gpui::PromptLevel::Warning,\n        proto::language_server_prompt_request::Level::Critical(_) => gpui::PromptLevel::Critical,\n    }\n}\n```\n\nHow do I instantiate a project?\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":106}}},{"id":{"replica_id":0,"value":37},"start":617913,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":107}}},{"id":{"replica_id":0,"value":38},"start":620497,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":108}}},{"id":{"replica_id":0,"value":104},"start":778034,"metadata":{"role":"assistant","status":{"Error":"cloud language model completion failed with status 400 Bad Request: prompt is too long: 206381 tokens > 200000 maximum"},"timestamp":{"replica_id":0,"value":111}}},{"id":{"replica_id":0,"value":105},"start":778035,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":110}}}],"summary":"Enable Editor Syntax Highlighting","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":2037},"icon":"Library","label":"Engineering","metadata":null},{"range":{"start":2038,"end":617850},"icon":"File","label":"zed/crates/editor/src/editor.rs","metadata":{"path":"zed/crates/editor/src/editor.rs"}},{"range":{"start":620497,"end":778001},"icon":"File","label":"zed/crates/project/src/project.rs","metadata":{"path":"zed/crates/project/src/project.rs"}}]}